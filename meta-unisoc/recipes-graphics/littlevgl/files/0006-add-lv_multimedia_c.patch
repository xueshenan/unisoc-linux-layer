diff --git a/src/lv_widgets/lv_multimedia.c b/src/lv_widgets/lv_multimedia.c
new file mode 100644
index 0000000..ca3dfb6
--- /dev/null
+++ b/src/lv_widgets/lv_multimedia.c
@@ -0,0 +1,505 @@
+/**
+ * @file lv_multimedia.c
+ *
+ */
+
+/*********************
+ *      INCLUDES
+ *********************/
+#include "lv_multimedia.h"
+#if 1
+
+
+/*********************
+ *      DEFINES
+ *********************/
+static lv_signal_cb_t ancestor_signal;
+static lv_design_cb_t ancestor_design;
+#define LV_OBJX_NAME "lv_multimedia"
+//static uint8_t *DataMul;
+
+/**********************
+ *      TYPEDEFS
+ **********************/
+static lv_design_res_t lv_multimedia_design(lv_obj_t * img, const lv_area_t * clip_area, lv_design_mode_t mode);
+static lv_res_t lv_multimedia_signal(lv_obj_t * img, lv_signal_t sign, void * param);
+static lv_style_list_t * lv_multimedia_get_style(lv_obj_t * img, uint8_t type);
+
+
+/**
+ * Create an multimedia objects
+ * @param par pointer to an object, it will be the parent of the new button
+ * @param copy pointer to a multimedia object, if not NULL then the new object will be copied from it
+ * @return pointer to the created multimedia
+ */
+lv_obj_t * lv_multimedia_create(lv_obj_t * par, const lv_obj_t * copy)
+{
+    LV_LOG_TRACE("image create started");
+
+    /*Create a basic object*/
+    lv_obj_t * cam = lv_obj_create(par, copy);
+    LV_ASSERT_MEM(cam);
+    if(cam == NULL) return NULL;
+
+    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(cam);
+
+    /*Extend the basic object to image object*/
+    lv_img_ext_t * ext = lv_obj_allocate_ext_attr(cam, sizeof(lv_img_ext_t));
+    LV_ASSERT_MEM(ext);
+    if(ext == NULL) {
+        lv_obj_del(cam);
+        return NULL;
+    }
+
+    ext->src       = NULL;
+    ext->src_type  = LV_IMG_SRC_UNKNOWN;
+    ext->cf        = LV_IMG_CF_UNKNOWN;
+    ext->w         = lv_obj_get_width(cam);
+    ext->h         = lv_obj_get_height(cam);
+    ext->angle = 0;
+    ext->zoom = LV_IMG_ZOOM_NONE;
+    ext->antialias = LV_ANTIALIAS ? 1 : 0;
+    ext->auto_size = 1;
+    ext->offset.x  = 0;
+    ext->offset.y  = 0;
+    ext->pivot.x = 0;
+    ext->pivot.y = 0;
+
+    /*Init the new object*/
+    lv_obj_set_signal_cb(cam, lv_multimedia_signal);
+    lv_obj_set_design_cb(cam, lv_multimedia_design);
+
+    if(copy == NULL) {
+        lv_theme_apply(cam, LV_THEME_IMAGE);
+        lv_obj_set_click(cam, false);
+        lv_obj_set_adv_hittest(cam, true); /*Images have fast hit-testing*/
+        /* Enable auto size for non screens
+         * because image screens are wallpapers
+         * and must be screen sized*/
+        if(par != NULL) {
+            ext->auto_size = 1;
+        }
+        else {
+            ext->auto_size = 0;
+        }
+    }
+    else {
+        lv_img_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
+        ext->auto_size     = copy_ext->auto_size;
+        ext->zoom          = copy_ext->zoom;
+        ext->angle         = copy_ext->angle;
+        ext->antialias     = copy_ext->antialias;
+        ext->offset.x     = copy_ext->offset.x;
+        ext->offset.y     = copy_ext->offset.y;
+        ext->pivot.x     = copy_ext->pivot.x;
+        ext->pivot.y     = copy_ext->pivot.y;
+        lv_img_set_src(cam, copy_ext->src);
+
+        /*Refresh the style with new signal function*/
+        lv_obj_refresh_style(cam, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
+    }
+
+    LV_LOG_INFO("image created");
+
+    return cam;
+}
+
+/**
+ * Handle the drawing related tasks of the multimedia
+ * @param multimedia pointer to an object
+ * @param clip_area the object will be drawn only in this area
+ * @param mode LV_DESIGN_COVER_CHK: only check if the object fully covers the 'mask_p' area
+ *                                  (return 'true' if yes)
+ *             LV_DESIGN_DRAW: draw the object (always return 'true')
+ *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
+ * @param return an element of `lv_design_res_t`
+ */
+static lv_design_res_t lv_multimedia_design(lv_obj_t * img, const lv_area_t * clip_area, lv_design_mode_t mode)
+{
+    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
+
+    if(mode == LV_DESIGN_COVER_CHK) {
+
+        if(lv_obj_get_style_clip_corner(img, LV_IMG_PART_MAIN)) return LV_DESIGN_RES_MASKED;
+
+        if(ext->src_type == LV_IMG_SRC_UNKNOWN || ext->src_type == LV_IMG_SRC_SYMBOL) return LV_DESIGN_RES_NOT_COVER;
+
+        /*Non true color format might have "holes"*/
+        if(ext->cf != LV_IMG_CF_TRUE_COLOR && ext->cf != LV_IMG_CF_RAW) return LV_DESIGN_RES_NOT_COVER;
+
+        int32_t angle_final = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
+        angle_final += ext->angle;
+
+        if(angle_final == 0) return LV_DESIGN_RES_NOT_COVER;
+
+        int32_t zoom_final = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
+        zoom_final = (zoom_final * ext->zoom) >> 8;
+
+        if(zoom_final != LV_IMG_ZOOM_NONE) {
+            if(_lv_area_is_in(clip_area, &img->coords, 0) == false) return LV_DESIGN_RES_NOT_COVER;
+        }
+        else {
+            lv_area_t a;
+            _lv_img_buf_get_transformed_area(&a, lv_obj_get_width(img), lv_obj_get_height(img), 0, zoom_final, &ext->pivot);
+            a.x1 += img->coords.x1;
+            a.y1 += img->coords.y1;
+            a.x2 += img->coords.x1;
+            a.y2 += img->coords.y1;
+
+            if(_lv_area_is_in(clip_area, &a, 0) == false) return LV_DESIGN_RES_NOT_COVER;
+        }
+
+        if(lv_obj_get_style_image_opa(img, LV_IMG_PART_MAIN) != LV_OPA_COVER) return LV_DESIGN_RES_NOT_COVER;
+
+        return LV_DESIGN_RES_COVER;
+    }
+    else if(mode == LV_DESIGN_DRAW_MAIN) {
+        if(ext->h == 0 || ext->w == 0) return true;
+        lv_area_t img_coords;
+
+        lv_obj_get_coords(img, &img_coords);
+
+        lv_draw_rect_dsc_t bg_dsc;
+        lv_draw_rect_dsc_init(&bg_dsc);
+        lv_obj_init_draw_rect_dsc(img, LV_IMG_PART_MAIN, &bg_dsc);
+
+        /*If the border is drawn later disable loading its properties*/
+        if(lv_obj_get_style_border_post(img, LV_OBJ_PART_MAIN)) {
+            bg_dsc.border_opa = LV_OPA_TRANSP;
+        }
+
+
+        int32_t zoom_final = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
+        zoom_final = (zoom_final * ext->zoom) >> 8;
+
+        if(zoom_final == 0) return LV_DESIGN_RES_OK;
+
+        int32_t angle_final = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
+        angle_final += ext->angle;
+
+        lv_area_t bg_coords;
+        _lv_img_buf_get_transformed_area(&bg_coords, lv_area_get_width(&img_coords), lv_area_get_height(&img_coords),
+                                         angle_final, zoom_final, &ext->pivot);
+        bg_coords.x1 += img_coords.x1;
+        bg_coords.y1 += img_coords.y1;
+        bg_coords.x2 += img_coords.x1;
+        bg_coords.y2 += img_coords.y1;
+        bg_coords.x1 -= lv_obj_get_style_pad_left(img, LV_IMG_PART_MAIN);
+        bg_coords.x2 += lv_obj_get_style_pad_right(img, LV_IMG_PART_MAIN);
+        bg_coords.y1 -= lv_obj_get_style_pad_top(img, LV_IMG_PART_MAIN);
+        bg_coords.y2 += lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
+
+        lv_draw_rect(&bg_coords, clip_area, &bg_dsc);
+
+        if(lv_obj_get_style_clip_corner(img, LV_OBJ_PART_MAIN)) {
+            lv_draw_mask_radius_param_t * mp = _lv_mem_buf_get(sizeof(lv_draw_mask_radius_param_t));
+
+            lv_coord_t r = lv_obj_get_style_radius(img, LV_OBJ_PART_MAIN);
+
+            lv_draw_mask_radius_init(mp, &bg_coords, r, false);
+            /*Add the mask and use `img+8` as custom id. Don't use `obj` directly because it might be used by the user*/
+            lv_draw_mask_add(mp, img + 8);
+        }
+
+        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_VARIABLE) {
+            img_coords.x1 += ext->offset.x;
+            img_coords.y1 += ext->offset.y;
+
+            if(img_coords.x1 > img->coords.x1) img_coords.x1 -= ext->w;
+            if(img_coords.y1 > img->coords.y1) img_coords.y1 -= ext->h;
+
+            LV_LOG_TRACE("lv_img_design: start to draw image");
+
+            lv_draw_img_dsc_t img_dsc;
+            lv_draw_img_dsc_init(&img_dsc);
+            lv_obj_init_draw_img_dsc(img, LV_IMG_PART_MAIN, &img_dsc);
+
+            img_dsc.zoom = zoom_final;
+
+            if(img_dsc.zoom == 0) return LV_DESIGN_RES_OK;
+
+            img_dsc.angle = angle_final;
+
+            img_dsc.pivot.x = ext->pivot.x;
+            img_dsc.pivot.y = ext->pivot.y;
+            img_dsc.antialias = ext->antialias;
+
+            lv_area_t cords_tmp;
+            cords_tmp.y1 = img_coords.y1;
+            cords_tmp.y2 = img_coords.y1 + ext->h - 1;
+
+            for(; cords_tmp.y1 <= img_coords.y2; cords_tmp.y1 += ext->h, cords_tmp.y2 += ext->h) {
+                cords_tmp.x1 = img_coords.x1;
+                cords_tmp.x2 = img_coords.x1 + ext->w - 1;
+                for(; cords_tmp.x1 <= img_coords.x2; cords_tmp.x1 += ext->w, cords_tmp.x2 += ext->w) {
+                    lv_draw_img(&cords_tmp, clip_area, ext->src, &img_dsc);
+                }
+            }
+        }
+        else if(ext->src_type == LV_IMG_SRC_SYMBOL) {
+            LV_LOG_TRACE("lv_img_design: start to draw symbol");
+            lv_draw_label_dsc_t label_dsc;
+            lv_draw_label_dsc_init(&label_dsc);
+            lv_obj_init_draw_label_dsc(img, LV_IMG_PART_MAIN, &label_dsc);
+
+            label_dsc.color = lv_obj_get_style_image_recolor(img, LV_IMG_PART_MAIN);
+            lv_draw_label(&img_coords, clip_area, &label_dsc, ext->src, NULL);
+        }
+        else {
+            /*Trigger the error handler of image drawer*/
+            LV_LOG_WARN("lv_img_design: image source type is unknown");
+            lv_draw_img(&img->coords, clip_area, NULL, NULL);
+        }
+    }
+    else if(mode == LV_DESIGN_DRAW_POST) {
+        if(lv_obj_get_style_clip_corner(img, LV_OBJ_PART_MAIN)) {
+            lv_draw_mask_radius_param_t * param = lv_draw_mask_remove_custom(img + 8);
+            _lv_mem_buf_release(param);
+        }
+
+        lv_draw_rect_dsc_t draw_dsc;
+        lv_draw_rect_dsc_init(&draw_dsc);
+
+        /*If the border is drawn later disable loading other properties*/
+        if(lv_obj_get_style_border_post(img, LV_OBJ_PART_MAIN)) {
+            draw_dsc.bg_opa = LV_OPA_TRANSP;
+            draw_dsc.pattern_opa = LV_OPA_TRANSP;
+            draw_dsc.shadow_opa = LV_OPA_TRANSP;
+            lv_obj_init_draw_rect_dsc(img, LV_OBJ_PART_MAIN, &draw_dsc);
+            lv_draw_rect(&img->coords, clip_area, &draw_dsc);
+        }
+    }
+
+    return LV_DESIGN_RES_OK;
+}
+
+/**
+ * Signal function of the image
+ * @param img pointer to an image object
+ * @param sign a signal type from lv_signal_t enum
+ * @param param pointer to a signal specific variable
+ * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
+ */
+static lv_res_t lv_multimedia_signal(lv_obj_t * img, lv_signal_t sign, void * param)
+{
+    lv_res_t res;
+    if(sign == LV_SIGNAL_GET_STYLE) {
+
+        lv_get_style_info_t * info = param;
+        info->result = lv_multimedia_get_style(img, info->part);
+        if(info->result != NULL) return LV_RES_OK;
+        else return ancestor_signal(img, sign, param);
+    }
+
+    /* Include the ancient signal function */
+    res = ancestor_signal(img, sign, param);
+    if(res != LV_RES_OK) return res;
+
+    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
+
+    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
+    if(sign == LV_SIGNAL_CLEANUP) {
+        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
+            lv_mem_free(ext->src);
+            ext->src      = NULL;
+            ext->src_type = LV_IMG_SRC_UNKNOWN;
+        }
+    }
+    else if(sign == LV_SIGNAL_STYLE_CHG) {
+        /*Refresh the file name to refresh the symbol text size*/
+        if(ext->src_type == LV_IMG_SRC_SYMBOL) {
+            lv_img_set_src(img, ext->src);
+        }
+    }
+    else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
+
+        lv_style_int_t transf_zoom = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
+        transf_zoom = (transf_zoom * ext->zoom) >> 8;
+
+        lv_style_int_t transf_angle = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
+        transf_angle += ext->angle;
+
+        /*If the image has angle provide enough room for the rotated corners */
+        if(transf_angle || transf_zoom != LV_IMG_ZOOM_NONE) {
+            lv_area_t a;
+            _lv_img_buf_get_transformed_area(&a, ext->w, ext->h, transf_angle, transf_zoom, &ext->pivot);
+            lv_coord_t pad_ori = img->ext_draw_pad;
+            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori - a.x1);
+            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori - a.y1);
+            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori + a.x2 - ext->w);
+            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori + a.y2 - ext->h);
+        }
+
+        /*Handle the padding of the background*/
+        lv_style_int_t left = lv_obj_get_style_pad_left(img, LV_IMG_PART_MAIN);
+        lv_style_int_t right = lv_obj_get_style_pad_right(img, LV_IMG_PART_MAIN);
+        lv_style_int_t top = lv_obj_get_style_pad_top(img, LV_IMG_PART_MAIN);
+        lv_style_int_t bottom = lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
+
+        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, left);
+        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, right);
+        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, top);
+        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, bottom);
+
+
+    }
+    else if(sign == LV_SIGNAL_HIT_TEST) {
+        lv_hit_test_info_t * info = param;
+        lv_style_int_t zoom = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
+        zoom = (zoom * ext->zoom) >> 8;
+
+        lv_style_int_t angle = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
+        angle += ext->angle;
+
+        /* If the object is exactly image sized (not cropped, not mosaic) and transformed
+         * perform hit test on it's transformed area */
+        if(ext->w == lv_obj_get_width(img) && ext->h == lv_obj_get_height(img) &&
+           (zoom != LV_IMG_ZOOM_NONE || angle != 0 || ext->pivot.x != ext->w / 2 || ext->pivot.y != ext->h / 2)) {
+
+            lv_area_t coords;
+            _lv_img_buf_get_transformed_area(&coords, ext->w, ext->h, angle, zoom, &ext->pivot);
+            coords.x1 += img->coords.x1;
+            coords.y1 += img->coords.y1;
+            coords.x2 += img->coords.x1;
+            coords.y2 += img->coords.y1;
+
+            info->result = _lv_area_is_point_on(&coords, info->point, 0);
+        }
+        else
+            info->result = lv_obj_is_point_on_coords(img, info->point);
+    }
+
+    return res;
+}
+
+static lv_style_list_t * lv_multimedia_get_style(lv_obj_t * img, uint8_t type)
+{
+    lv_style_list_t * style_dsc_p;
+    switch(type) {
+        case LV_IMG_PART_MAIN:
+            style_dsc_p = &img->style_list;
+            break;
+        default:
+            style_dsc_p = NULL;
+    }
+
+    return style_dsc_p;
+}
+
+
+
+
+/**
+ * Convert YUV- NV21 video data to RGBA format
+ * @param sour_data: YUVnv21 sour_data
+ * @param Outputmultimedia: RGBA Multimediaera structure
+ * @param type: Source data formatsss
+ */
+int NV212RGBA_type(uint8_t *input, lv_cam_dsc_t *outputcam )
+{
+    int nv_off = outputcam->header.w * outputcam->header.h;
+    int  i, j, y_index = 0;
+    int y, u, v;
+    int r, g, b, nv_index = 0;
+    int offr=0,offg=1,offb=2,offa=3;
+
+    for (i = 0; i < outputcam->header.h; i++) {
+        for (j = 0; j < outputcam->header.w; j++,++y_index) {
+            nv_index = i / 2 * outputcam->header.w + j - j % 2;
+
+            y = input[y_index];
+            u = input[nv_off + nv_index];
+            v = input[nv_off + nv_index + 1];
+
+            r = y + ((351 * (v - 128)) >> 8);                            //r
+            g = y - ((179 * (v - 128) + 86 * (u - 128)) >> 8); //g
+            b = y + ((443 * (u - 128)) >> 8);                            //b
+
+            r = ((r>255) ? 255 : (r<0) ? 0 : r);
+            g = ((g>255) ? 255 : (g<0) ? 0 : g);
+            b = ((b>255) ? 255 : (b<0) ? 0 : b);
+
+            outputcam->data[y_index * 4 + offr] = (uint8_t)r;
+            outputcam->data[y_index * 4 + offg] = (uint8_t)g;
+            outputcam->data[y_index * 4 + offb] = (uint8_t)b;
+            outputcam->data[y_index * 4 + offa] = 0xFF;
+
+        }
+    }
+    return 1;
+}
+
+/**
+ * Convert RGBA video data to BGRA format
+ * @param sour_data: RGBA  sour_data
+ * @param Outputmultimedia: RGBA Multimediaera structure
+ * @param type: Source data format
+ */
+void RGBA2BGRA_type(uint8_t * sour_data,lv_cam_dsc_t *outputmultimedia)
+{
+    uint32_t num_long = outputmultimedia->header.h * outputmultimedia->header.w;
+    uint32_t place=0,i=0;
+    int offr=2,offg=1,offb=0,offa=3;
+    for(i=0,place=0;i<outputmultimedia->data_size;i+=4){
+        outputmultimedia->data[place]=sour_data[i+offr];
+        place++;
+        outputmultimedia->data[place]=sour_data[i+offg];
+        place++;
+        outputmultimedia->data[place]=sour_data[i+offb];
+        place++;
+        outputmultimedia->data[place]=sour_data[i+offa];
+        place++;
+    }
+}
+
+/**
+* Convert RGBA video data to RGBA format
+* @param sour_data: RGBA  sour_data
+* @param mul_w: The width of an image
+* @param mul_h: The height of an image
+* @param mul_size: Source data size
+* @param type: Source data format
+* @param out_data: the Image BUF position after conversion
+*/
+int lv_show_multimedia(lv_obj_t * mul_demo ,uint8_t * sour_data,uint8_t *DataMul,int mul_w, int mul_h, uint32_t mul_size, int type)
+{
+    if((mul_demo == NULL) || (mul_w<=0)|| (mul_h<=0)|| (mul_size<=0)){
+        return -1;
+    }
+    static lv_cam_dsc_t outputmultimedia ;
+
+    outputmultimedia.header.always_zero = 0;
+    outputmultimedia.header.w           = mul_w;
+    outputmultimedia.header.h           = mul_h;
+    outputmultimedia.header.cf          = LV_IMG_CF_TRUE_COLOR;
+    outputmultimedia.data_size          = mul_size;
+    outputmultimedia.data               = DataMul;
+
+       if(LV_COLOR_SIZE ==32){
+        switch(type){
+            case MulTypeBGR32:{
+                RGBA2BGRA_type(sour_data,&outputmultimedia);
+                break;
+            }
+            case MulTypeRGB32:{
+                       outputmultimedia.data = sour_data;
+                break;
+            }
+            case MulTypeYUVnv21:{
+                NV212RGBA_type(sour_data,&outputmultimedia);
+                break;
+            }
+            default:{
+                return -1;
+            }
+        }
+       }
+
+
+    lv_img_set_src(mul_demo, &outputmultimedia);
+    return 0;
+}
+
+
+#endif
+
