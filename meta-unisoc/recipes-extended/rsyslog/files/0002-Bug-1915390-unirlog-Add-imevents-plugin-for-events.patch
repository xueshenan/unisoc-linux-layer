From bab9b99e54a3ed3413a555c9226ef3e181bf254b Mon Sep 17 00:00:00 2001
From: "etham.li" <etham.li@unisoc.com>
Date: Wed, 22 Jun 2022 17:01:23 +0800
Subject: [PATCH] Bug #1915390 - [unirlog] Add imevents plugin for events

[root cause  ]: Add imevents plugin for events
[changes     ]: Add imevents plugin for events
[side effects]: no
[self test   ]: build pass
[download normally]:yes
[power on/off normally]:yes
[do common repository/branch inspection]:no
[is there dependence]:no
[confirm dependent commit]:no
[board]:trunk
[test case]:build pass
[reviewers]:zhenghai.yang

commit_template_version:v1
---
 Makefile.am                  |   7 +-
 configure.ac                 |  13 +
 plugins/imevents/Makefile.am |   6 +
 plugins/imevents/imevents.c  | 480 +++++++++++++++++++++++++++++++++++
 plugins/imevents/uevent.c    |  96 +++++++
 plugins/imevents/uevent.h    |  17 ++
 6 files changed, 618 insertions(+), 1 deletion(-)
 create mode 100755 plugins/imevents/Makefile.am
 create mode 100755 plugins/imevents/imevents.c
 create mode 100755 plugins/imevents/uevent.c
 create mode 100755 plugins/imevents/uevent.h

diff --git a/Makefile.am b/Makefile.am
index f216884..bb8e439 100755
--- a/Makefile.am
+++ b/Makefile.am
@@ -34,6 +34,10 @@ if ENABLE_IMTEST
 SUBDIRS += plugins/imtest
 endif
 
+if ENABLE_IMEVENTS
+SUBDIRS += plugins/imevents
+endif
+
 if ENABLE_IMKMSG
 SUBDIRS += contrib/imkmsg
 endif
@@ -393,7 +397,8 @@ DISTCHECK_CONFIGURE_FLAGS+= \
 	--enable-pmnull \
 	--enable-pmsnare \
 	--enable-usertools \
-	--enable-test
+	--enable-test \
+	--enable-events
 
 else
 DISTCHECK_CONFIGURE_FLAGS+= \
diff --git a/configure.ac b/configure.ac
index f777ad6..e0bf5dd 100755
--- a/configure.ac
+++ b/configure.ac
@@ -591,6 +591,18 @@ AC_ARG_ENABLE(test,
 )
 AM_CONDITIONAL(ENABLE_IMTEST, test x$enable_test = xyes)
 
+# events
+AC_ARG_ENABLE(test,
+        [AS_HELP_STRING([--enable-events],[Integrated events functionality @<:@default=yes@:>@])],
+        [case "${enableval}" in
+         yes) enable_events="yes" ;;
+          no) enable_events="no" ;;
+           *) AC_MSG_ERROR(bad value ${enableval} for --enable-events) ;;
+         esac],
+        [enable_events="yes"]
+)
+AM_CONDITIONAL(ENABLE_IMEVENTS, test x$enable_events = xyes)
+
 # kmsg
 AC_ARG_ENABLE(kmsg,
         [AS_HELP_STRING([--enable-kmsg],[Kmsg structured kernel logs functionality @<:@default=no@:>@])],
@@ -2686,6 +2698,7 @@ AC_CONFIG_FILES([Makefile \
 		plugins/immark/Makefile \
 		plugins/imklog/Makefile \
 		plugins/imtest/Makefile \
+		plugins/imevents/Makefile \
 		plugins/omhdfs/Makefile \
 		plugins/omkafka/Makefile \
 		plugins/omprog/Makefile \
diff --git a/plugins/imevents/Makefile.am b/plugins/imevents/Makefile.am
new file mode 100755
index 0000000..321b1c1
--- /dev/null
+++ b/plugins/imevents/Makefile.am
@@ -0,0 +1,6 @@
+pkglib_LTLIBRARIES = imevents.la
+
+imevents_la_SOURCES = imevents.c uevent.c uevent.h
+imevents_la_CPPFLAGS = -I$(top_srcdir) $(PTHREADS_CFLAGS) $(RSRT_CFLAGS)
+imevents_la_LDFLAGS = -module -avoid-version
+imevents_la_LIBADD = 
diff --git a/plugins/imevents/imevents.c b/plugins/imevents/imevents.c
new file mode 100755
index 0000000..056d4c2
--- /dev/null
+++ b/plugins/imevents/imevents.c
@@ -0,0 +1,480 @@
+/*
+ * SPDX-FileCopyrightText: 2022 Unisoc (Shanghai) Technologies Co., Ltd.
+ *
+ * SPDX-License-Identifier: LicenseRef-Unisoc-General-1.0
+ *
+ */
+#include "config.h"
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <poll.h>
+#include <sys/socket.h>
+
+#include "uevent.h"
+#include "rsyslog.h"
+#include "dirty.h"
+#include "cfsysline.h"
+#include "obj.h"
+#include "msg.h"
+#include "glbl.h"
+#include "prop.h"
+#include "errmsg.h"
+#include "stream.h"
+#include "unicode-helper.h"
+#include "module-template.h"
+#include "stringbuf.h"
+
+MODULE_TYPE_INPUT
+MODULE_TYPE_NOKEEP
+MODULE_CNFNAME("imevents")
+
+/* Module static data */
+DEF_IMOD_STATIC_DATA
+DEFobjCurrIf(glbl)
+DEFobjCurrIf(strm)
+DEFobjCurrIf(prop)
+
+static int bLegacyCnfModGlobalsPermitted;
+
+static struct configSettings_s {
+	uchar *pszFileTag;
+	int iFacility;
+} cs;
+
+/* input params config settings */
+struct instanceConf_s {
+	uchar *pszTag;
+	int iFacility;
+	struct instanceConf_s *next;
+};
+
+#define EVENTMODE_USB 0
+#define EVENTMODE_CHARGE 1
+#define UEVENT_MSG_LEN 1024
+#define UEVENT_OPEN_SOCKET_LENGTH (256*1024)
+
+static int m_uevent_fd_;
+
+/* module params config settings */
+struct modConfData_s {
+	rsconf_t *pConf;	/* our overall config object */
+	instanceConf_t *root, *tail;
+	uint8_t EventMode;
+	sbool configSetViaV2Method;
+};
+
+static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
+static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */
+
+/* global property */
+static prop_t *pInputName = NULL;/* there is only one global inputName for all messages generated by this module */
+
+/* module-global parameters */
+static struct cnfparamdescr modpdescr[] = {
+	{ "eventmode", eCmdHdlrGetWord, 0 }
+};
+static struct cnfparamblk modpblk =
+	{ CNFPARAMBLK_VERSION,
+	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
+	  modpdescr
+	};
+
+/* input instance parameters */
+static struct cnfparamdescr inppdescr[] = {
+	{ "tag", eCmdHdlrString, CNFPARAM_REQUIRED },
+	{ "facility", eCmdHdlrFacility, 0 }
+};
+static struct cnfparamblk inppblk =
+	{ CNFPARAMBLK_VERSION,
+	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
+	  inppdescr
+	};
+
+/************************************************************/
+/* function define                                          */
+/************************************************************/
+
+/* log an imtest-internal message */
+static rsRetVal imtestLogIntMsg(syslog_pri_t priority, const char *fmt, ...)
+{
+	DEFiRet;
+	va_list ap;
+	uchar msgBuf[2048];
+
+	va_start(ap, fmt);
+	vsnprintf((char*)msgBuf, sizeof(msgBuf), fmt, ap);
+	va_end(ap);
+
+	logmsgInternal(NO_ERRCODE, priority, msgBuf, 0);
+
+	RETiRet;
+}
+
+/* create input instance, set default parameters, and
+ * add it to the list of instances.
+ */
+static rsRetVal
+createInstance(instanceConf_t **pinst)
+{
+	DBGPRINTF("imevents: createInstance\n");
+	instanceConf_t *inst;
+	DEFiRet;
+	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
+	inst->next = NULL;
+	inst->pszTag = NULL;
+	inst->iFacility = 128;
+
+	if(loadModConf->tail == NULL) {
+		loadModConf->tail = loadModConf->root = inst;
+	} else {
+		loadModConf->tail->next = inst;
+		loadModConf->tail = inst;
+	}
+
+	*pinst = inst;
+finalize_it:
+	RETiRet;
+}
+
+/* enqueue the the /dev/kmsg message into the main message-queue.*/
+static rsRetVal
+enqMsg(uchar *msg, instanceConf_t *inst)
+{
+	//imtestLogIntMsg(LOG_INFO, "imevents: emter enqMsg\n");
+	smsg_t *pMsg; //define message object
+	int iSeverity = LOG_INFO;
+	DEFiRet;
+	//imtestLogIntMsg(LOG_INFO, "imevents: enqMsg input tag = %s", inst->pszTag);
+	//imtestLogIntMsg(LOG_INFO, "imevents: enqMsg input facility = %d", inst->iFacility);
+	//imtestLogIntMsg(LOG_INFO, "imevents: enqMsg input msg = %s", msg);
+
+	assert(msg != NULL);
+	assert(inst->pszTag != NULL);
+	assert(inst->iFacility != NULL);
+
+	CHKiRet(msgConstruct(&pMsg));//init message objcet
+
+	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY); //set flow control state
+	MsgSetInputName(pMsg, pInputName);
+	MsgSetRawMsgWOSize(pMsg, (char*)msg);
+	MsgSetMSGoffs(pMsg, 0);
+	MsgSetTAG(pMsg, inst->pszTag, ustrlen(inst->pszTag));
+	msgSetPRI(pMsg, inst->iFacility | iSeverity);
+
+	CHKiRet(submitMsg2(pMsg)); //send pmsg
+	//imtestLogIntMsg(LOG_INFO, "imevents: enqMsg end");
+finalize_it:
+	RETiRet;
+}
+
+static void parse_event(const char *msg, instanceConf_t *inst) {
+	//imtestLogIntMsg(LOG_INFO, "imevents: enter parse_event\n");
+	while (*msg) {
+	  enqMsg(msg, inst);
+	  /* advance to after the next \0 */
+	  while (*msg++);
+	}
+}
+
+static int handle_uevent_fd(instanceConf_t *inst) {
+	DBGPRINTF("imevents: enter handle_uevent_fd, tag = %s, facility = %d\n", 
+						inst->pszTag, inst->iFacility);
+	char msg[UEVENT_MSG_LEN + 2];
+	int n;
+	uid_t uid = -1;
+	while ((n = uevent_kernel_recv(m_uevent_fd_, msg, UEVENT_MSG_LEN, true, &uid))
+		> 0) {
+		if (n >= UEVENT_MSG_LEN) { /* overflow -- discard */
+		  DBGPRINTF("imevents: uevent_kernel_recv overflow!discard it!\n");
+		  continue;
+		}
+		//imtestLogIntMsg(LOG_INFO, "imevents: enter handle_uevent_fd : length = %d\n", n);
+		msg[n] = '\0';
+		msg[n + 1] = '\0';
+		parse_event(msg, inst);
+	}
+	return 0;
+}
+
+static rsRetVal
+GetEvent(modConfData_t *modConf, instanceConf_t *inst)
+{
+	DBGPRINTF("imevents: enter GetEvent\n");
+	DEFiRet;
+	int nr;
+	struct pollfd ufd;
+	ufd.events = POLLIN;
+	ufd.fd = m_uevent_fd_;
+
+	while (true) {
+	  ufd.revents = 0;
+	  nr = poll(&ufd, 1, -1);
+	  if (nr <= 0)
+		continue;
+	  if (ufd.revents == POLLIN)
+		handle_uevent_fd(inst);
+	}
+	RETiRet;
+}
+
+static rsRetVal
+OpenUevent()
+{
+	DBGPRINTF("imevents: OpenUevent\n");
+	DEFiRet;
+	m_uevent_fd_ = uevent_open_socket(UEVENT_OPEN_SOCKET_LENGTH, true);
+	if (-1 == m_uevent_fd_) {
+		DBGPRINTF("imevents: uevent socket init failed !\n");
+		iRet = RS_RET_ERR;
+	}
+
+finalize_it:
+	if(iRet != RS_RET_OK) {
+		DBGPRINTF("imevents: error %d trying to OpenUevent", iRet);
+	}
+	RETiRet;
+}
+
+/*
+ * Initialize input parameters by rsyslog.conf
+*/
+BEGINnewInpInst
+	struct cnfparamvals *pvals;
+	instanceConf_t *inst;
+	int i;
+CODESTARTnewInpInst
+	DBGPRINTF("imevents: CODESTARTnewInpInst\n");
+	pvals = nvlstGetParams(lst, &inppblk, NULL);
+	if(pvals == NULL) {
+		DBGPRINTF("imevents: error processing input config parameters [input(...)]");
+		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
+	}
+
+	DBGPRINTF("imevents: input param inppblk\n");
+	cnfparamsPrint(&inppblk, pvals);
+	CHKiRet(createInstance(&inst));
+
+	for(i = 0 ; i < inppblk.nParams ; ++i) {
+		if(!pvals[i].bUsed)
+			continue;
+		if(!strcmp(inppblk.descr[i].name, "tag")) {
+			inst->pszTag = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
+		} else if(!strcmp(inppblk.descr[i].name, "facility")) {
+			inst->iFacility = pvals[i].val.d.n;
+		} else {
+			DBGPRINTF("imevents: program error, non-handled "
+			  "param '%s'\n", inppblk.descr[i].name);
+		}
+	}
+finalize_it:
+CODE_STD_FINALIZERnewInpInst
+	DBGPRINTF("imevents: CODE_STD_FINALIZERnewInpInst\n");
+	cnfparamvalsDestruct(pvals, &inppblk);
+ENDnewInpInst
+
+/*
+ * Initialize module parameters
+*/
+BEGINbeginCnfLoad
+CODESTARTbeginCnfLoad
+	DBGPRINTF("imevents: CODESTARTbeginCnfLoad\n");
+	loadModConf = pModConf;
+	pModConf->pConf = pConf;
+
+	/* init our settings */
+	loadModConf->EventMode = EVENTMODE_USB;
+	loadModConf->configSetViaV2Method = 0;
+	DBGPRINTF("imevents: EventMode = %d\n", loadModConf->EventMode);
+	/* init legacy config vars */
+	cs.pszFileTag = NULL;
+	cs.iFacility = 128;
+ENDbeginCnfLoad
+
+/*
+ * Initialize module parameters by rsyslog.conf
+*/
+BEGINsetModCnf
+	struct cnfparamvals *pvals = NULL;
+	int i;
+	DBGPRINTF("imevents: BEGINsetModCnf\n");
+CODESTARTsetModCnf
+	DBGPRINTF("imevents: CODESTARTsetModCnf\n");
+	loadModConf->EventMode = EVENTMODE_USB;
+	pvals = nvlstGetParams(lst, &modpblk, NULL);
+	if(pvals == NULL) {
+		DBGPRINTF("imevents: error processing module config parameters [module(...)]");
+		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
+	}
+
+	DBGPRINTF("imevents: module (global) param modpblk\n");
+	cnfparamsPrint(&modpblk, pvals);
+
+	for(i = 0 ; i < modpblk.nParams ; ++i) {
+		if(!pvals[i].bUsed)
+			continue;
+		if(!strcmp(modpblk.descr[i].name, "eventmode")) {
+			if(!es_strconstcmp(pvals[i].val.d.estr, "usb"))
+				loadModConf->EventMode = EVENTMODE_USB;
+			else if(!es_strconstcmp(pvals[i].val.d.estr, "charge"))
+				loadModConf->EventMode = EVENTMODE_CHARGE;
+			else {
+				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
+				DBGPRINTF("imevents: unknown mode '%s'", cstr);
+				free(cstr);
+			}
+		} else {
+			DBGPRINTF("imevents: program error, non-handled "
+			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
+		}
+	}
+	/* remove all of our legacy handlers, as they can not used in addition
+	 * the the new-style config method.
+	 */
+	bLegacyCnfModGlobalsPermitted = 0;
+	loadModConf->configSetViaV2Method = 1;
+finalize_it:
+	if(pvals != NULL)
+		cnfparamvalsDestruct(pvals, &modpblk);
+ENDsetModCnf
+
+/*
+ * End module/input parameters configure end load
+*/
+BEGINendCnfLoad
+CODESTARTendCnfLoad
+	loadModConf = NULL;
+	/* free legacy config vars */
+	free(cs.pszFileTag);
+ENDendCnfLoad
+
+/*
+ * Check Conf
+*/
+BEGINcheckCnf
+CODESTARTcheckCnf
+	DBGPRINTF("imevents: CODESTARTcheckCnf");
+	if(pModConf->root == NULL) {
+		DBGPRINTF("imevents: no files configured to be monitored no input will be gathered");
+		iRet = RS_RET_NO_LISTNERS;
+	}
+ENDcheckCnf
+
+BEGINactivateCnfPrePrivDrop
+CODESTARTactivateCnfPrePrivDrop
+ENDactivateCnfPrePrivDrop
+
+BEGINactivateCnf
+	DBGPRINTF("imevents: BEGINactivateCnf\n");
+	instanceConf_t *inst;
+CODESTARTactivateCnf
+	DBGPRINTF("imevents: CODESTARTactivateCnf\n");
+	runModConf = pModConf;
+	if(runModConf->root == NULL) {
+		DBGPRINTF("imevents: no file monitors configured, input not activated\n");
+		ABORT_FINALIZE(RS_RET_NO_RUN);
+	}
+	for(inst = runModConf->root ; inst != NULL ; inst = inst->next) {
+		OpenUevent();
+	}
+finalize_it:
+ENDactivateCnf
+
+BEGINfreeCnf
+	DBGPRINTF("imevents: BEGINfreeCnf\n");
+	instanceConf_t *inst, *del;
+CODESTARTfreeCnf
+	DBGPRINTF("imevents: CODESTARTfreeCnf\n");
+	for(inst = pModConf->root ; inst != NULL ; ) {
+		free(inst->pszTag);
+		del = inst;
+		inst = inst->next;
+		free(del);
+	}
+ENDfreeCnf
+
+BEGINrunInput
+	DBGPRINTF("imevents: BEGINrunInput\n");
+	instanceConf_t *inst;
+CODESTARTrunInput
+	DBGPRINTF("imevents: CODESTARTrunInput start\n");
+	DBGPRINTF("imevents: working in %s mode\n",
+		 (runModConf->EventMode == EVENTMODE_USB) ? "usb" : "charge");
+	inst = runModConf->root;
+
+	GetEvent(runModConf, inst);
+
+	DBGPRINTF("imevents: CODESTARTrunInput end\n");
+ENDrunInput
+
+
+BEGINwillRun
+CODESTARTwillRun
+ENDwillRun
+
+BEGINafterRun
+CODESTARTafterRun
+	if(pInputName != NULL)
+		prop.Destruct(&pInputName);
+ENDafterRun
+
+BEGINisCompatibleWithFeature
+CODESTARTisCompatibleWithFeature
+	if(eFeat == sFEATURENonCancelInputTermination)
+		iRet = RS_RET_OK;
+ENDisCompatibleWithFeature
+
+BEGINmodExit
+	DBGPRINTF("imevents::BEGINmodExit");
+CODESTARTmodExit
+	DBGPRINTF("imevents::CODESTARTmodExit");
+	if(pInputName != NULL) {
+		prop.Destruct(&pInputName);
+	}
+	/* release objects we used */
+	objRelease(strm, CORE_COMPONENT);
+	objRelease(glbl, CORE_COMPONENT);
+	objRelease(prop, CORE_COMPONENT);
+ENDmodExit
+
+BEGINqueryEtryPt
+CODESTARTqueryEtryPt
+CODEqueryEtryPt_STD_IMOD_QUERIES
+CODEqueryEtryPt_STD_CONF2_QUERIES
+CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
+CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
+CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
+ENDqueryEtryPt
+
+static rsRetVal
+resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
+{
+	DEFiRet;
+	free(cs.pszFileTag);
+	cs.pszFileTag = NULL;
+	/* set defaults... */
+	cs.iFacility = 128; /* local0 */
+	RETiRet;
+}
+
+BEGINmodInit()
+CODESTARTmodInit
+	*ipIFVersProvided = CURR_MOD_IF_VERSION;
+CODEmodInit_QueryRegCFSLineHdlr
+	DBGPRINTF("imevents::BEGINmodInit");
+	CHKiRet(objUse(glbl, CORE_COMPONENT));
+	CHKiRet(objUse(strm, CORE_COMPONENT));
+	CHKiRet(objUse(prop, CORE_COMPONENT));
+
+	DBGPRINTF("imevents: version %s initializing\n", VERSION);
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputeventtag", 0, eCmdHdlrGetWord,
+	  	NULL, &cs.pszFileTag, STD_LOADABLE_MODULE_ID));
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputeventfacility", 0, eCmdHdlrFacility,
+	  	NULL, &cs.iFacility, STD_LOADABLE_MODULE_ID));
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
+		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
+ENDmodInit
+
diff --git a/plugins/imevents/uevent.c b/plugins/imevents/uevent.c
new file mode 100755
index 0000000..f963195
--- /dev/null
+++ b/plugins/imevents/uevent.c
@@ -0,0 +1,96 @@
+/*
+ * SPDX-FileCopyrightText: 2022 Unisoc (Shanghai) Technologies Co., Ltd.
+ *
+ * SPDX-License-Identifier: LicenseRef-Unisoc-General-1.0
+ */
+#undef _GNU_SOURCE
+#define _GNU_SOURCE
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <linux/netlink.h>
+#include "uevent.h"
+
+int uevent_open_socket(int length, bool passcred) {
+  int enable = passcred;
+  int sock_fd = -1;
+
+  sock_fd = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC,
+                   NETLINK_KOBJECT_UEVENT);
+  if (sock_fd < 0) {
+    return -1;
+  }
+
+  struct sockaddr_nl m_addr;
+  memset(&m_addr, 0, sizeof(m_addr));
+  m_addr.nl_family = AF_NETLINK;
+  m_addr.nl_pid = getpid();
+  m_addr.nl_groups = 0xFFFFFFFF;
+
+  if (setsockopt(sock_fd, SOL_SOCKET, SO_RCVBUF, &length, sizeof(length)) < 0) {
+    close(sock_fd);
+    return -1;
+  }
+
+  setsockopt(sock_fd, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable));
+
+  if (bind(sock_fd, (struct sockaddr*) &m_addr, sizeof(m_addr)) < 0) {
+    close(sock_fd);
+    return -1;
+  }
+
+  return sock_fd;
+}
+
+ssize_t uevent_kernel_multicast_recv(int socket, void* buffer, size_t length) {
+  uid_t uid = -1;
+  return uevent_kernel_recv(socket, buffer, length, true, &uid);
+}
+
+ssize_t uevent_kernel_recv(int socket, void* buffer, size_t length, bool flag,
+                           uid_t* uid) {
+  struct iovec m_iov = { buffer, length };
+  struct sockaddr_nl m_addr;
+  char control[CMSG_SPACE(sizeof(struct ucred))];
+  struct msghdr hdr = { .msg_name = &m_addr, .msg_namelen = sizeof(m_addr),
+      .msg_iov = &m_iov, .msg_iovlen = 1, .msg_control = control,
+      .msg_controllen = sizeof(control), .msg_flags = 0, };
+  struct ucred* m_cred;
+
+  *uid = -1;
+  ssize_t recv_num = recvmsg(socket, &hdr, 0);
+  if (recv_num <= 0) {
+    return recv_num;
+  }
+
+  struct cmsghdr* cmsg = CMSG_FIRSTHDR(&hdr);
+  if (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {
+    bzero(buffer, length);
+    errno = EIO;
+    return -1;
+  }
+
+  m_cred = (struct ucred*) CMSG_DATA(cmsg);
+  *uid = m_cred->uid;
+
+  if (m_addr.nl_pid != 0) {
+    bzero(buffer, length);
+    errno = EIO;
+    return -1;
+  }
+
+  if (flag && m_addr.nl_groups == 0) {
+    bzero(buffer, length);
+    errno = EIO;
+    return -1;
+  }
+
+  return recv_num;
+}
+
diff --git a/plugins/imevents/uevent.h b/plugins/imevents/uevent.h
new file mode 100755
index 0000000..504d9d5
--- /dev/null
+++ b/plugins/imevents/uevent.h
@@ -0,0 +1,17 @@
+/*
+ * SPDX-FileCopyrightText: 2022 Unisoc (Shanghai) Technologies Co., Ltd.
+ *
+ * SPDX-License-Identifier: LicenseRef-Unisoc-General-1.0
+ */
+
+#ifndef INC_UEVENT_H_
+#define INC_UEVENT_H_
+
+#include <stdbool.h>
+
+int uevent_open_socket(int length, bool passcred);
+ssize_t uevent_kernel_multicast_recv(int socket, void *buffer, size_t length);
+ssize_t uevent_kernel_recv(int socket, void *buffer, size_t length, bool flag,
+                           uid_t *uid);
+
+#endif /* INC_UEVENT_H_ */
-- 
2.17.1

