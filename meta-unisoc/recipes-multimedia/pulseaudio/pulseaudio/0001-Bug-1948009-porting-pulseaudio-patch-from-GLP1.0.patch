From 7c5191471e95cec0d24921d8b202ff33e39c6681 Mon Sep 17 00:00:00 2001
From: "gaofeng.zhu" <gaofeng.zhu@unisoc.com>
Date: Tue, 19 Jul 2022 16:11:01 +0800
Subject: [PATCH] Bug #000000 porting pulseaudio patch from GLP1.0

[root cause  ]: pulseaudio version changed (11.1 -->13.0)
[changes     ]: patch porting
[side effects]: NO
[self test   ]: No
[download normally]:Yes
[power on/off normally]:Yes
[do common repository/branch inspection]:No
[is there dependence]:No
[confirm dependent commit]:No
[board]:9863a
[test case]:Yes
[reviewers]:peitao.tian

commit_template_version:v1
---
 src/Makefile.am                               |  263 ++-
 src/daemon/daemon.conf.in                     |    8 +-
 src/daemon/default.pa.in                      |   11 +-
 src/daemon/system.pa.in                       |   26 +-
 src/modules/alsa/alsa-mixer.c                 |   18 +-
 src/modules/alsa/alsa-util.c                  |   28 +-
 src/modules/bluetooth/a2dp-codec-api.h        |   48 +-
 src/modules/bluetooth/a2dp-codec-sbc.c        |  436 +++-
 src/modules/bluetooth/a2dp-codec-util.c       |  111 +-
 src/modules/bluetooth/a2dp-codec-util.h       |   21 +-
 src/modules/bluetooth/backend-native.c        |  743 ++++++-
 src/modules/bluetooth/backend-ofono.c         |  117 +-
 src/modules/bluetooth/bluez5-util.c           | 1792 +++++++++++++++--
 src/modules/bluetooth/bluez5-util.h           |  139 +-
 src/modules/bluetooth/bt-codec-api.h          |   67 +
 src/modules/bluetooth/bt-codec-cvsd.c         |  123 ++
 src/modules/bluetooth/bt-codec-msbc.c         |  317 +++
 src/modules/bluetooth/bt-codec-msbc.h         |   35 +
 .../bluetooth/module-bluetooth-policy.c       |   21 +-
 src/modules/bluetooth/module-bluez5-device.c  | 1463 ++++++++------
 .../bluetooth/module-bluez5-discover.c        |   68 +-
 src/modules/bluetooth/rtp.h                   |    4 +-
 src/modules/list.h                            |   72 +
 src/modules/module-device-manager.c           |  815 +++++++-
 src/modules/module-device-restore.c           |   50 +-
 src/modules/module-udev-detect.c              |   26 +-
 src/pulse/context.c                           |   24 +
 src/pulsecore/creds.h                         |    2 +-
 src/pulsecore/memblock.c                      |   42 +
 src/pulsecore/protocol-native.c               |    6 +-
 src/pulsecore/pstream.c                       |   24 +-
 src/pulsecore/shm.c                           |    3 +-
 src/pulsecore/sink.c                          |    2 +-
 src/pulsecore/socket-server.c                 |   10 +-
 src/pulsecore/source.c                        |    2 +-
 35 files changed, 5838 insertions(+), 1099 deletions(-)
 create mode 100755 src/modules/bluetooth/bt-codec-api.h
 create mode 100755 src/modules/bluetooth/bt-codec-cvsd.c
 create mode 100755 src/modules/bluetooth/bt-codec-msbc.c
 create mode 100755 src/modules/bluetooth/bt-codec-msbc.h
 create mode 100755 src/modules/list.h

diff --git a/src/Makefile.am b/src/Makefile.am
index 437311d..f9f6fee 100755
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -45,16 +45,71 @@ endif
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/modules \
+	-I$(top_srcdir)/src/modules/alsa \
+	-I$(top_srcdir)/src/audiohal/external/tinyalsa/include \
+	-I$(top_srcdir)/src/audiohal/external/tinyxml \
+	-I$(top_srcdir)/src/audiohal/hardware/libhardware/include \
+	-I$(top_srcdir)/src/audiohal/hardware/libhardware_legacy/include \
+	-I$(top_srcdir)/src/audiohal/system/media/audio/include \
+	-I$(top_srcdir)/src/audiohal/system/media/audio_utils/include \
+	-I$(top_srcdir)/src/audiohal/system/media/alsa_utils/include \
+	-I$(top_srcdir)/src/audiohal/system/core/libcutils/include \
+	-I$(top_srcdir)/src/audiohal/system/core/libutils/include \
+	-I$(top_srcdir)/src/audiohal/system/core/libsystem/include \
+	-I$(top_srcdir)/src/audiohal/system/core/liblog/include \
+	-I$(top_srcdir)/src/audiohal/system/core/libprocessgroup/include \
+	-I$(top_srcdir)/src/audiohal/external/tinycompress/include \
+	-I$(top_srcdir)/src/audiohal/dump/audio_dump \
+	-I$(top_srcdir)/src/audiohal/libatci \
+	-I$(top_srcdir)/src/audiohal/whale \
+	-I$(top_srcdir)/src/audiohal/whale/record_process \
+	-I$(top_srcdir)/src/audiohal/whale/debug \
+	-I$(top_srcdir)/src/audiohal/whale/record_nr \
+	-I$(top_srcdir)/src/audiohal/whale/audio_param \
+	-I$(top_srcdir)/src/audiohal/whale/tinycompress_util \
+	-I$(top_srcdir)/src/audiohal/whale/preprocessing \
+	-I$(top_srcdir)/src/audiohal/whale/audiotester \
+	-I$(top_srcdir)/src/audiohal/whale/smartamp \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal/include \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal/smart_amp/inc \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal/compress_simu \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal/vb_effect/v2  \
+	-I$(top_srcdir)/src/audiohal/pulsemodule  \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal/nv_exchange  \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal/vb_pga \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal/include \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal \
+	-I$(top_srcdir)/src/audiohal/whale/platform/normal/nxppa \
+	-I$(top_srcdir)/src/audioutils \
+	-I$(top_srcdir)/src/audiohal/external/expat \
 	-I$(top_builddir)/src/modules \
+	-I$(top_builddir)/src/modules/alsa \
 	-DPA_ALSA_PATHS_DIR=\"$(alsapathsdir)\" \
 	-DPA_ALSA_PROFILE_SETS_DIR=\"$(alsaprofilesetsdir)\" \
 	-DPA_SRCDIR=\"$(abs_srcdir)\" \
 	-DPA_BUILDDIR=\"$(abs_builddir)\" \
 	-DPULSE_LOCALEDIR=\"$(localedir)\"
+	-DFLAG_VENDOR_ETC \
+	-DAUDIOHAL_V4 \
+	-DAUDIO_VBC_DEEPBUFFER_MIXER \
+	-DSPRD_AUDIO_HIDL_CLIENT \
+	-DAUDIO_SERVER_64_BIT \
+	-DSPRD_AUDIO_SMARTAMP \
+	-DLOCAL_SOCKET_CLIENT \
+	-DHAVE_SYSLOG_H \
+	-DRECORD_USE_MMAP
 AM_CFLAGS = -std=gnu11 \
 	$(PTHREAD_CFLAGS)
 AM_CXXFLAGS = -std=c++11 \
-	$(PTHREAD_CFLAGS)
+	$(PTHREAD_CFLAGS) \
+	-DFLAG_VENDOR_ETC \
+	-DAUDIOHAL_V4 \
+	-DAUDIO_VBC_DEEPBUFFER_MIXER \
+	-DSPRD_AUDIO_HIDL_CLIENT \
+	-DAUDIO_SERVER_64_BIT \
+	-DSPRD_AUDIO_SMARTAMP \
+	-DLOCAL_SOCKET_CLIENT \
+	-DRECORD_USE_MMAP
 SERVER_CFLAGS = -D__INCLUDED_FROM_PULSE_AUDIO
 
 AM_LIBADD = $(PTHREAD_LIBS) $(INTLLIBS)
@@ -1326,10 +1381,20 @@ pulselibexec_PROGRAMS =
 
 if HAVE_ALSA
 modlibexec_LTLIBRARIES += \
+		libexpat.la \
+		libvbeffect.la \
+		libvbpga.la \
+		libnvexchange.la \
+		libaudioutils.la \
+		libtinyalsa.la  \
+		libtinyxml.la   \
+		libaudiohal.la  \
 		libalsa-util.la \
 		module-alsa-sink.la \
 		module-alsa-source.la \
-		module-alsa-card.la
+		module-alsa-card.la  \
+		module-unisoc-card.la
+		
 
 dist_alsaprofilesets_DATA = \
 		modules/alsa/mixer/profile-sets/default.conf \
@@ -1492,7 +1557,8 @@ if HAVE_BLUEZ_5
 modlibexec_LTLIBRARIES += \
 		libbluez5-util.la \
 		module-bluez5-discover.la \
-		module-bluez5-device.la
+		module-bluez5-device.la \
+		module-bluez-monitor.la
 endif
 
 # RAOP depends on RTP, and we don't support RTP on Windows, see comment at
@@ -1807,6 +1873,172 @@ module_coreaudio_device_la_LDFLAGS = $(MODULE_LDFLAGS) \
 module_coreaudio_device_la_LIBADD = $(MODULE_LIBADD)
 module_coreaudio_device_la_CFLAGS = $(AM_CFLAGS) -DPA_MODULE_NAME=module_coreaudio_device
 
+#tinyalsa
+libtinyalsa_la_SOURCES = \
+		audiohal/external/tinyalsa/pcm.c audiohal/external/tinyalsa/include/tinyalsa/asoundlib.h \
+		audiohal/external/tinyalsa/mixer.c
+
+libtinyalsa_la_LDFLAGS = -avoid-version
+libtinyalsa_la_LIBADD = libpulsecommon-@PA_MAJORMINOR@.la
+libtinyalsa_la_CFLAGS = $(AM_CFLAGS)  -DPA_MODULE_NAME=libtinyalsa
+
+#tinyxml
+libtinyxml_la_SOURCES = \
+		audiohal/external/tinyxml/tinyxml.cpp \
+		audiohal/external/tinyxml/tinyxmlparser.cpp \
+		audiohal/external/tinyxml/tinyxmlerror.cpp \
+		audiohal/external/tinyxml/tinystr.cpp
+
+libtinyxml_la_LDFLAGS = -avoid-version
+libtinyxml_la_LIBADD = $(MODULE_LIBADD) $(ASOUNDLIB_LIBS)
+libtinyxml_la_CFLAGS = $(AM_CFLAGS) $(SERVER_CFLAGS) $(ASOUNDLIB_CFLAGS)  -DPA_MODULE_NAME=libtinyxml
+
+#libexpat
+libexpat_la_SOURCES = \
+		audiohal/external/expat/xmlparse.c \
+		audiohal/external/expat/xmlrole.c \
+		audiohal/external/expat/xmltok.c
+
+
+libexpat_la_LDFLAGS = -avoid-version
+libexpat_la_LIBADD = $(MODULE_LIBADD) $(ASOUNDLIB_LIBS)
+libexpat_la_CFLAGS = $(AM_CFLAGS) $(SERVER_CFLAGS) $(ASOUNDLIB_CFLAGS)   -DPA_MODULE_NAME=libexpat -DHAVE_EXPAT_CONFIG_H \
+		-Wall \
+    		-Wmissing-prototypes -Wstrict-prototypes \
+    		-Wno-unused-parameter -Wno-missing-field-initializers \
+    		-fexceptions
+
+#audioutil
+libaudioutils_la_SOURCES = \
+		audioutils/audio_utils.c  audioutils/audio_utils.h
+
+libaudioutils_la_LDFLAGS = -avoid-version
+libaudioutils_la_LIBADD = $(MODULE_LIBADD) $(ASOUNDLIB_LIBS)
+libaudioutils_la_CFLAGS = $(AM_CFLAGS)  -DPA_MODULE_NAME=libaudioutils
+
+#libvbeffect
+libvbeffect_la_SOURCES = \
+		audiohal/whale/platform/normal/vb_effect/v2/vb_effect_if.c \
+		audiohal/whale/platform/normal/vb_effect/v2/vbc_codec_eq.c \
+		audiohal/whale/platform/normal/vb_effect/v2/filter_calc.c \
+		audiohal/whale/platform/normal/vb_effect/v2/vb_hal_if.c \
+		audiohal/whale/platform/normal/vb_effect/v2/vb_hal_adp.c \
+		audiohal/whale/platform/normal/vb_effect/v2/tinyalsa_util.c
+
+libvbeffect_la_LDFLAGS = -avoid-version
+libvbeffect_la_LIBADD = libtinyalsa.la libaudioutils.la libexpat.la
+libvbeffect_la_CFLAGS = $(AM_CFLAGS)  -DPA_MODULE_NAME=libvbeffect
+
+#nvexchange
+libnvexchange_la_SOURCES = \
+		audiohal/whale/platform/normal/nv_exchange/parse_mode.cpp \
+		audiohal/whale/platform/normal/nv_exchange/string_exchange_bin.h \
+		audiohal/whale/platform/normal/nv_exchange/string_exchange_bin.c
+
+libnvexchange_la_LDFLAGS = -avoid-version
+libnvexchange_la_LIBADD = libtinyxml.la libaudioutils.la libexpat.la
+libnvexchange_la_CFLAGS = $(AM_CFLAGS)  -DPA_MODULE_NAME=libnvexchange
+
+
+
+#libvbpga
+libvbpga_la_SOURCES = \
+		audiohal/whale/platform/normal/vb_pga/aud_common.h \
+		audiohal/whale/platform/normal/vb_pga/aud_enha.h \	
+		audiohal/whale/platform/normal/vb_pga/audio_pga.h \
+		audiohal/whale/platform/normal/vb_pga/audio_pga.c \
+		audiohal/whale/platform/normal/vb_pga/filter_calc.h \
+		audiohal/whale/platform/normal/vb_pga/vb_hal.h \
+		audiohal/whale/platform/normal/vb_pga/vb_hal_adp.h \	
+		audiohal/whale/platform/normal/vb_pga/vb_hal_reg.h \	
+		audiohal/whale/platform/normal/vb_pga/vb_pga.h \	
+		audiohal/whale/platform/normal/vb_pga/vb_pga.c \	
+		audiohal/whale/platform/normal/vb_pga/vbc_codec.h
+
+libvbpga_la_LDFLAGS = -avoid-version
+libvbpga_la_LIBADD = libtinyalsa.la libaudioutils.la libexpat.la
+libvbpga_la_CFLAGS = $(AM_CFLAGS)  -DPA_MODULE_NAME=libvbpga
+
+#libaudioparamteser
+libaudioparamteser_la_SOURCES = \
+		audiohal/whale/platform/normal/audiotester.c
+
+libaudioparamteser_la_LDFLAGS = -avoid-version
+libaudioparamteser_la_LIBADD = libvbeffect.la libnvexchange.la
+libaudioparamteser_la_CFLAGS = $(AM_CFLAGS)  -DPA_MODULE_NAME=libaudioparamteser
+
+
+#tinyxml
+libaudiohal_la_SOURCES = \
+		audiohal/whale/audio_hw.c \
+		audiohal/whale/audio_monitor.c \
+		audiohal/whale/audio_control.cpp \
+		audiohal/whale/tinyalsa_util.cpp \
+		audiohal/whale/audio_xml_utils.cpp \
+		audiohal/whale/fm.c \
+		audiohal/whale/aaudio.c \
+		audiohal/whale/audio_parse.cpp \
+		audiohal/whale/voice_call.c \
+		audiohal/whale/audio_register.c \
+		audiohal/whale/ring_buffer.c \
+		audiohal/whale/audio_path.c \
+		audiohal/whale/audio_config.cpp \
+		audiohal/whale/audio_microphone.cpp \
+		audiohal/whale/audio_param/audio_param.cpp \
+		audiohal/whale/audio_param/param_config.cpp \
+		audiohal/whale/record_process/aud_proc_config.c \
+		audiohal/whale/record_process/aud_filter_calc.c \
+		audiohal/whale/record_process/record_nr_api.c \
+		audiohal/whale/audiotester/audiotester_server.c \
+		audiohal/whale/audiotester/audio_param_handler.cpp \
+		audiohal/whale/audiotester/local_socket.c \
+		audiohal/whale/debug/endpoint_test.c \
+		audiohal/whale/debug/audio_debug.cpp \
+		audiohal/whale/debug/ext_control.c \
+		audiohal/whale/preprocessing/DspCommandCtl.c \
+		audiohal/whale/preprocessing/DspPreProcessing.c \
+		audiohal/whale/tinycompress_util/compress_util.c \
+		audiohal/whale/platform/normal/dsp_control.c \
+		audiohal/whale/platform/normal/audio_offload.c \
+		audiohal/whale/platform/normal/vb_control_parameters.c \
+		audiohal/whale/platform/normal/audio_platform.cpp \
+		audiohal/whale/platform/normal/at_commands_generic.c \
+		audiohal/whale/platform/normal/smart_amp/src/smart_amp.c \
+		audiohal/whale/platform/normal/compress_simu/compress_simu.c \
+		audiohal/whale/platform/normal/compress_simu/mp3_dec.c \
+		audiohal/whale/platform/normal/compress_simu/ringbuffer.c \
+		audiohal/whale/platform/normal/nxppa/Sprd_NxpTfa.c \
+		audiohal/whale/extra_func.c \
+		audiohal/dump/audio_dump/audio_dump.c \
+		audiohal/tool/libtinyalsa_utils/alsa_pcm_util.c \
+		audiohal/system/core/libcutils/str_parms.cpp \
+		audiohal/system/core/libcutils/hashmap.cpp \
+		audiohal/system/core/libcutils/strlcpy.c \
+		audiohal/whale/platform/normal/audio_pga_if.c  \
+		audiohal/whale/platform/normal/audiotester.c 
+
+libaudiohal_la_LDFLAGS = -avoid-version
+libaudiohal_la_LIBADD = $(MODULE_LIBADD) $(ASOUNDLIB_LIBS) libtinyxml.la libvbeffect.la libvbpga.la \
+		libnvexchange.la libaudioutils.la
+libaudiohal_la_CFLAGS = $(AM_CFLAGS) $(SERVER_CFLAGS) $(ASOUNDLIB_CFLAGS)   -DPA_MODULE_NAME=libaudiohal -DFLAG_VENDOR_ETC \
+		-DAUDIOHAL_V4 \
+		-DAUDIO_VBC_DEEPBUFFER_MIXER \
+		-DSPRD_AUDIO_HIDL_CLIENT \
+		-DSPRD_AUDIO_SMARTAMP \
+		-DLOCAL_SOCKET_CLIENT \
+		-DAUDIOHAL_RUN_IN_PULSEAUDIO
+
+libaudiohal_la_CFLAGS += $(SMART_PA_SUPPORT)
+
+libaudiohal_la_CPPFLAGS = $(AM_CPPFLAGS) -DFLAG_VENDOR_ETC \
+		-DAUDIOHAL_V4 \
+		-DAUDIO_VBC_DEEPBUFFER_MIXER \
+		-DSPRD_AUDIO_HIDL_CLIENT \
+		-DSPRD_AUDIO_SMARTAMP \
+		-DLOCAL_SOCKET_CLIENT \
+		-DAUDIOHAL_RUN_IN_PULSEAUDIO
+
+libaudiohal_la_CPPFLAGS += $(SMART_PA_SUPPORT)
 # ALSA
 
 libalsa_util_la_SOURCES = \
@@ -1815,10 +2047,14 @@ libalsa_util_la_SOURCES = \
 		modules/alsa/alsa-mixer.c modules/alsa/alsa-mixer.h \
 		modules/alsa/alsa-sink.c modules/alsa/alsa-sink.h \
 		modules/alsa/alsa-source.c modules/alsa/alsa-source.h \
-		modules/reserve-wrap.c modules/reserve-wrap.h
+		modules/reserve-wrap.c modules/reserve-wrap.h \
+		audiohal/pulsemodule/unisoc-sink.c audiohal/pulsemodule/unisoc-sink.h \
+		audiohal/pulsemodule/unisoc-source.c audiohal/pulsemodule/unisoc-source.h \
+		audiohal/pulsemodule/audio-wake-lock.c audiohal/pulsemodule/audio-wake-lock.h
+
 libalsa_util_la_LDFLAGS = -avoid-version
-libalsa_util_la_LIBADD = $(MODULE_LIBADD) $(ASOUNDLIB_LIBS)
-libalsa_util_la_CFLAGS = $(AM_CFLAGS) $(SERVER_CFLAGS) $(ASOUNDLIB_CFLAGS)
+libalsa_util_la_LIBADD = $(MODULE_LIBADD) $(ASOUNDLIB_LIBS) libtinyalsa.la libaudiohal.la
+libalsa_util_la_CFLAGS = $(AM_CFLAGS) $(SERVER_CFLAGS) $(ASOUNDLIB_CFLAGS)  -DPA_MODULE_NAME=libalsa_util
 
 if HAVE_UDEV
 libalsa_util_la_SOURCES += modules/udev-util.h modules/udev-util.c
@@ -1847,6 +2083,12 @@ module_alsa_card_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_alsa_card_la_LIBADD = $(MODULE_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la
 module_alsa_card_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS) -DPA_MODULE_NAME=module_alsa_card
 
+
+module_unisoc_card_la_SOURCES = audiohal/pulsemodule/module-unisoc-card.c
+module_unisoc_card_la_LDFLAGS = $(MODULE_LDFLAGS)
+module_unisoc_card_la_LIBADD = $(MODULE_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la
+module_unisoc_card_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS) # -DPA_MODULE_NAME=module_unisoc_card
+
 # Solaris
 
 module_solaris_la_SOURCES = modules/module-solaris.c
@@ -2145,6 +2387,10 @@ libbluez5_util_la_SOURCES = \
 		modules/bluetooth/a2dp-codec-util.c \
 		modules/bluetooth/a2dp-codec-util.h \
 		modules/bluetooth/a2dp-codecs.h \
+ 		modules/bluetooth/bt-codec-api.h \
+		modules/bluetooth/bt-codec-cvsd.c \
+		modules/bluetooth/bt-codec-msbc.c \
+		modules/bluetooth/bt-codec-msbc.h \
 		modules/bluetooth/rtp.h
 if HAVE_BLUEZ_5_OFONO_HEADSET
 libbluez5_util_la_SOURCES += \
@@ -2174,6 +2420,11 @@ module_bluez5_device_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_bluez5_device_la_LIBADD = $(MODULE_LIBADD) libbluez5-util.la
 module_bluez5_device_la_CFLAGS = $(AM_CFLAGS) -DPA_MODULE_NAME=module_bluez5_device
 
+module_bluez_monitor_la_SOURCES = audiohal/pulsemodule/module-bluez-monitor.c
+module_bluez_monitor_la_LDFLAGS = $(MODULE_LDFLAGS)
+module_bluez_monitor_la_LIBADD = $(MODULE_LIBADD) $(DBUS_LIBS) libbluez5-util.la
+module_bluez_monitor_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS)
+
 # Apple Airtunes/RAOP
 module_raop_sink_la_SOURCES = modules/raop/module-raop-sink.c
 module_raop_sink_la_LDFLAGS = $(MODULE_LDFLAGS)
diff --git a/src/daemon/daemon.conf.in b/src/daemon/daemon.conf.in
index a955523..da437b7 100755
--- a/src/daemon/daemon.conf.in
+++ b/src/daemon/daemon.conf.in
@@ -47,8 +47,8 @@ ifelse(@HAVE_DBUS@, 1, [dnl
 ; load-default-script-file = yes
 ; default-script-file = @PA_DEFAULT_CONFIG_DIR@/default.pa
 
-; log-target = auto
-; log-level = notice
+log-target = syslog
+log-level = 3
 ; log-meta = no
 ; log-time = no
 ; log-backtrace = 0
@@ -60,7 +60,7 @@ ifelse(@HAVE_DBUS@, 1, [dnl
 ; enable-lfe-remixing = no
 ; lfe-crossover-freq = 0
 
-; flat-volumes = yes
+flat-volumes = no
 
 ifelse(@HAVE_SYS_RESOURCE_H@, 1, [dnl
 ; rlimit-fsize = -1
@@ -82,7 +82,7 @@ ifelse(@HAVE_SYS_RESOURCE_H@, 1, [dnl
 
 ; default-sample-format = s16le
 ; default-sample-rate = 44100
-; alternate-sample-rate = 48000
+alternate-sample-rate = 44100
 ; default-sample-channels = 2
 ; default-channel-map = front-left,front-right
 
diff --git a/src/daemon/default.pa.in b/src/daemon/default.pa.in
index 14b6a6f..828fdd7 100755
--- a/src/daemon/default.pa.in
+++ b/src/daemon/default.pa.in
@@ -25,6 +25,7 @@ changequote(`[', `]')dnl Set up m4 quoting
 load-module module-device-restore
 load-module module-stream-restore
 load-module module-card-restore
+load-module module-alsa-card device_id=0 profile_set=sprd_default.conf
 
 ### Automatically augment property information from .desktop files
 ### stored in /usr/share/application
@@ -55,7 +56,7 @@ ifelse(@HAVE_MKFIFO@, 1, [dnl
 ### Automatically load driver modules depending on the hardware available
 ifelse(@HAVE_UDEV@, 1, [dnl
 .ifexists module-udev-detect@PA_SOEXT@
-load-module module-udev-detect
+#load-module module-udev-detect
 .else
 ], @HAVE_COREAUDIO@, 1, [dnl
 .ifexists module-coreaudio-detect@PA_SOEXT@
@@ -65,7 +66,7 @@ load-module module-coreaudio-detect
 .ifexists module-detect@PA_SOEXT@
 ])dnl
 ### Use the static hardware detection module (for systems that lack udev support)
-load-module module-detect
+#load-module module-detect
 .endif
 
 ### Automatically connect sink and source if JACK server is present
@@ -91,7 +92,7 @@ ifelse(@HAVE_AF_UNIX@, 1, [dnl
 .ifexists module-esound-protocol-unix@PA_SOEXT@
 load-module module-esound-protocol-unix
 .endif
-load-module module-native-protocol-unix
+load-module module-native-protocol-unix auth-cookie=/mnt/data/.config/pulse/cookie
 ])dnl
 
 ### Network access (may be configured with paprefs, so leave this commented
@@ -175,5 +176,5 @@ load-module module-filter-apply
 ])dnl
 
 ### Make some devices default
-#set-default-sink output
-#set-default-source input
+set-default-sink alsa_output.0.music-playback-output
+set-default-source alsa_input.0.record-stereo-input
diff --git a/src/daemon/system.pa.in b/src/daemon/system.pa.in
index b1a4a5c..327f49e 100755
--- a/src/daemon/system.pa.in
+++ b/src/daemon/system.pa.in
@@ -31,20 +31,26 @@ load-module module-udev-detect
 .else
 ], @HAVE_COREAUDIO@, 1, [dnl
 .ifexists module-coreaudio-detect@PA_SOEXT@
-load-module module-coreaudio-detect
+#load-module module-coreaudio-detect
 .else
 ], [dnl
 .ifexists module-detect@PA_SOEXT@
 ])dnl
 ### Use the static hardware detection module (for systems that lack udev/hal support)
-load-module module-detect
+#load-module module-detect
 .endif
 
+load-module module-unisoc-card device_id=0 profile_set=sprd_default.conf
+
 ### Load several protocols
 .ifexists module-esound-protocol-unix@PA_SOEXT@
 load-module module-esound-protocol-unix
 .endif
 load-module module-native-protocol-unix
+### Automatically do device selection
+.ifexists module-device-manager.so
+load-module module-device-manager do_routing=1 on_hotplug=1 on_rescue=1
+.endif
 
 ### Automatically restore the default sink/source when changed by the user
 ### during runtime
@@ -64,3 +70,19 @@ load-module module-suspend-on-idle
 
 ### Enable positioned event sounds
 load-module module-position-event-sounds
+
+.ifexists module-bluez5-discover.so
+#load-module module-bluez5-discover headset=native autodetect_mtu=yes enable_msbc=false enable_native_hsp_hs=false enable_native_hfp_hf=true avrcp_absolute_volume=true
+load-module module-bluez5-discover headset=ofono enable_msbc=false
+.endif
+
+.ifexists module-bluetooth-policy.so
+load-module module-bluetooth-policy
+.endif
+
+.ifexists module-bluez-monitor.so
+load-module module-bluez-monitor
+.endif
+
+#set-default-sink alsa_output.0.music-playback-output
+#set-default-source alsa_input.0.record-stereo-input
diff --git a/src/modules/alsa/alsa-mixer.c b/src/modules/alsa/alsa-mixer.c
index cd99a75..660b4a5 100755
--- a/src/modules/alsa/alsa-mixer.c
+++ b/src/modules/alsa/alsa-mixer.c
@@ -1759,8 +1759,9 @@ static int element_probe(pa_alsa_element *e, snd_mixer_t *m) {
             }
 
         } else {
-
-            if (!snd_mixer_selem_has_capture_switch(me)) {
+        pa_log_debug("element_probe  me is 4 e->switch_use:%d:capture switch:%d",e->switch_use,snd_mixer_selem_has_capture_switch(me));
+            if (0){//!snd_mixer_selem_has_capture_switch(me)) {
+                pa_log_debug("element_probe  me is 5 e->switch_use:%d",e->switch_use);
                 if (e->direction_try_other && snd_mixer_selem_has_playback_switch(me))
                     e->direction = PA_ALSA_DIRECTION_OUTPUT;
                 else
@@ -4027,9 +4028,12 @@ static void mapping_paths_probe(pa_alsa_mapping *m, pa_alsa_profile *profile,
     if (!ps)
         return; /* No paths */
 
-    pa_assert(pcm_handle);
-
-    mixer_handle = pa_alsa_open_mixer_for_pcm(pcm_handle, NULL);
+   // pa_assert(pcm_handle);
+    if(pcm_handle) {
+        mixer_handle = pa_alsa_open_mixer_for_pcm(pcm_handle, NULL);
+    } else {
+        mixer_handle = pa_alsa_open_mixer_for_card_num(0, NULL);
+    }
     if (!mixer_handle) {
         /* Cannot open mixer, remove all entries */
         pa_hashmap_remove_all(ps->paths);
@@ -4755,14 +4759,14 @@ void pa_alsa_profile_set_probe(
 
         if (p->output_mappings)
             PA_IDXSET_FOREACH(m, p->output_mappings, idx)
-                if (m->output_pcm) {
+                if (1) {//m->output_pcm) {
                     found_output |= !p->fallback_output;
                     mapping_paths_probe(m, p, PA_ALSA_DIRECTION_OUTPUT, used_paths);
                 }
 
         if (p->input_mappings)
             PA_IDXSET_FOREACH(m, p->input_mappings, idx)
-                if (m->input_pcm) {
+                if (1) {//(m->input_pcm) {
                     found_input |= !p->fallback_input;
                     mapping_paths_probe(m, p, PA_ALSA_DIRECTION_INPUT, used_paths);
                 }
diff --git a/src/modules/alsa/alsa-util.c b/src/modules/alsa/alsa-util.c
index bd0a47e..72d9dd5 100755
--- a/src/modules/alsa/alsa-util.c
+++ b/src/modules/alsa/alsa-util.c
@@ -328,7 +328,7 @@ int pa_alsa_set_hw_params(
 
     if (_use_tsched && tsched_size > 0) {
         _buffer_size = (snd_pcm_uframes_t) (((uint64_t) tsched_size * _ss.rate) / ss->rate);
-        _period_size = _buffer_size;
+        //_period_size = _buffer_size;
     } else {
         _period_size = (snd_pcm_uframes_t) (((uint64_t) _period_size * _ss.rate) / ss->rate);
         _buffer_size = (snd_pcm_uframes_t) (((uint64_t) _buffer_size * _ss.rate) / ss->rate);
@@ -1781,6 +1781,32 @@ snd_mixer_t *pa_alsa_open_mixer_for_pcm(snd_pcm_t *pcm, char **ctl_device) {
     return NULL;
 }
 
+snd_mixer_t *pa_alsa_open_mixer_for_card_num(int card_num,char **ctl_device) {
+    int err;
+    snd_mixer_t *m;
+    char *md;
+    pa_log_debug("peter:pa_alsa_open_mixer_for_card_num in" );
+    if ((err = snd_mixer_open(&m, 0)) < 0) {
+        pa_log("Error opening mixer: %s", pa_alsa_strerror(err));
+        return NULL;
+    }
+    pa_log_debug("peter:pa_alsa_open_mixer_for_card_num in 2" );
+    md = pa_sprintf_malloc("hw:%i", card_num);
+    if (prepare_mixer(m, md) >= 0) {
+
+        if (ctl_device)
+            *ctl_device = md;
+        else
+            pa_xfree(md);
+        pa_log_debug("peter:pa_alsa_open_mixer_for_card_num in 3" );
+        return m;
+    }
+    pa_xfree(md);
+    pa_log_debug("peter:pa_alsa_open_mixer_for_card_num in 4" );
+    snd_mixer_close(m);
+    return NULL;
+}
+
 int pa_alsa_get_hdmi_eld(snd_hctl_elem_t *elem, pa_hdmi_eld *eld) {
 
     /* The ELD format is specific to HDA Intel sound cards and defined in the
diff --git a/src/modules/bluetooth/a2dp-codec-api.h b/src/modules/bluetooth/a2dp-codec-api.h
index a3123f4..bdfd3f3 100755
--- a/src/modules/bluetooth/a2dp-codec-api.h
+++ b/src/modules/bluetooth/a2dp-codec-api.h
@@ -22,7 +22,10 @@
 
 #include <pulsecore/core.h>
 
+#include "bt-codec-api.h"
+
 #define MAX_A2DP_CAPS_SIZE 254
+#define DEFAULT_OUTPUT_RATE_REFRESH_INTERVAL_MS 500
 
 typedef struct pa_a2dp_codec_capabilities {
     uint8_t size;
@@ -35,19 +38,16 @@ typedef struct pa_a2dp_codec_id {
     uint16_t vendor_codec_id;
 } pa_a2dp_codec_id;
 
-typedef struct pa_a2dp_codec {
-    /* Unique name of the codec, lowercase and without whitespaces, used for
-     * constructing identifier, D-Bus paths, ... */
-    const char *name;
-    /* Human readable codec description */
-    const char *description;
-
+typedef struct pa_a2dp_endpoint_conf {
     /* A2DP codec id */
     pa_a2dp_codec_id id;
 
     /* True if codec is bi-directional and supports backchannel */
     bool support_backchannel;
 
+    /* Returns true if the codec can be supported on the system */
+    bool (*can_be_supported)(bool for_encoding);
+
     /* Returns true if codec accepts capabilities, for_encoding is true when
      * capabilities are used for encoding */
     bool (*can_accept_capabilities)(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding);
@@ -63,36 +63,8 @@ typedef struct pa_a2dp_codec {
     /* Fill preferred codec configuration, returns size of filled buffer or 0 on failure */
     uint8_t (*fill_preferred_configuration)(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]);
 
-    /* Initialize codec, returns codec info data and set sample_spec,
-     * for_encoding is true when codec_info is used for encoding,
-     * for_backchannel is true when codec_info is used for backchannel */
-    void *(*init)(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec);
-    /* Deinitialize and release codec info data in codec_info */
-    void (*deinit)(void *codec_info);
-    /* Reset internal state of codec info data in codec_info, returns
-     * a negative value on failure */
-    int (*reset)(void *codec_info);
-
-    /* Get read block size for codec, it is minimal size of buffer
-     * needed to decode read_link_mtu bytes of encoded data */
-    size_t (*get_read_block_size)(void *codec_info, size_t read_link_mtu);
-    /* Get write block size for codec, it is maximal size of buffer
-     * which can produce at most write_link_mtu bytes of encoded data */
-    size_t (*get_write_block_size)(void *codec_info, size_t write_link_mtu);
-
-    /* Reduce encoder bitrate for codec, returns new write block size or zero
-     * if not changed, called when socket is not accepting encoded data fast
-     * enough */
-    size_t (*reduce_encoder_bitrate)(void *codec_info, size_t write_link_mtu);
-
-    /* Encode input_buffer of input_size to output_buffer of output_size,
-     * returns size of filled ouput_buffer and set processed to size of
-     * processed input_buffer */
-    size_t (*encode_buffer)(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed);
-    /* Decode input_buffer of input_size to output_buffer of output_size,
-     * returns size of filled ouput_buffer and set processed to size of
-     * processed input_buffer */
-    size_t (*decode_buffer)(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed);
-} pa_a2dp_codec;
+    /* Bluetooth codec */
+    pa_bt_codec bt_codec;
+} pa_a2dp_endpoint_conf;
 
 #endif
diff --git a/src/modules/bluetooth/a2dp-codec-sbc.c b/src/modules/bluetooth/a2dp-codec-sbc.c
index 89c647f..d768075 100755
--- a/src/modules/bluetooth/a2dp-codec-sbc.c
+++ b/src/modules/bluetooth/a2dp-codec-sbc.c
@@ -36,8 +36,8 @@
 #include "a2dp-codec-api.h"
 #include "rtp.h"
 
-#define SBC_BITPOOL_DEC_LIMIT 32
 #define SBC_BITPOOL_DEC_STEP 5
+#define SBC_BITPOOL_INC_STEP 1
 
 struct sbc_info {
     sbc_t sbc;                           /* Codec data */
@@ -51,8 +51,15 @@ struct sbc_info {
     uint8_t initial_bitpool;
     uint8_t min_bitpool;
     uint8_t max_bitpool;
+
+    uint8_t nr_blocks;
+    uint8_t nr_subbands;
 };
 
+static bool can_be_supported(bool for_encoding) {
+    return true;
+}
+
 static bool can_accept_capabilities(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
     const a2dp_sbc_t *capabilities = (const a2dp_sbc_t *) capabilities_buffer;
 
@@ -77,6 +84,30 @@ static bool can_accept_capabilities(const uint8_t *capabilities_buffer, uint8_t
     return true;
 }
 
+static bool can_accept_capabilities_xq(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    const a2dp_sbc_t *capabilities = (const a2dp_sbc_t *) capabilities_buffer;
+
+    if (capabilities_size != sizeof(*capabilities))
+        return false;
+
+    if (!(capabilities->frequency & (SBC_SAMPLING_FREQ_44100 | SBC_SAMPLING_FREQ_48000)))
+        return false;
+
+    if (!(capabilities->channel_mode & (SBC_CHANNEL_MODE_DUAL_CHANNEL)))
+        return false;
+
+    if (!(capabilities->allocation_method & (SBC_ALLOCATION_LOUDNESS)))
+        return false;
+
+    if (!(capabilities->subbands & (SBC_SUBBANDS_8)))
+        return false;
+
+    if (!(capabilities->block_length & (SBC_BLOCK_LENGTH_16)))
+        return false;
+
+    return true;
+}
+
 static const char *choose_remote_endpoint(const pa_hashmap *capabilities_hashmap, const pa_sample_spec *default_sample_spec, bool for_encoding) {
     const pa_a2dp_codec_capabilities *a2dp_capabilities;
     const char *key;
@@ -91,6 +122,20 @@ static const char *choose_remote_endpoint(const pa_hashmap *capabilities_hashmap
     return NULL;
 }
 
+static const char *choose_remote_endpoint_xq(const pa_hashmap *capabilities_hashmap, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    const pa_a2dp_codec_capabilities *a2dp_capabilities;
+    const char *key;
+    void *state;
+
+    /* There is no preference, just choose random valid entry */
+    PA_HASHMAP_FOREACH_KV(key, a2dp_capabilities, capabilities_hashmap, state) {
+        if (can_accept_capabilities_xq(a2dp_capabilities->buffer, a2dp_capabilities->size, for_encoding))
+            return key;
+    }
+
+    return NULL;
+}
+
 static uint8_t fill_capabilities(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
     a2dp_sbc_t *capabilities = (a2dp_sbc_t *) capabilities_buffer;
 
@@ -109,6 +154,29 @@ static uint8_t fill_capabilities(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]
     return sizeof(*capabilities);
 }
 
+/* SBC XQ
+ *
+ * References:
+ *   https://habr.com/en/post/456476/
+ *   http://soundexpert.org/articles/-/blogs/audio-quality-of-sbc-xq-bluetooth-audio-codec
+ *
+ */
+static uint8_t fill_capabilities_xq(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_sbc_t *capabilities = (a2dp_sbc_t *) capabilities_buffer;
+
+    pa_zero(*capabilities);
+
+    capabilities->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
+    capabilities->frequency = SBC_SAMPLING_FREQ_44100 | SBC_SAMPLING_FREQ_48000;
+    capabilities->allocation_method = SBC_ALLOCATION_LOUDNESS;
+    capabilities->subbands = SBC_SUBBANDS_8;
+    capabilities->block_length = SBC_BLOCK_LENGTH_16;
+    capabilities->min_bitpool = SBC_MIN_BITPOOL;
+    capabilities->max_bitpool = SBC_MAX_BITPOOL;
+
+    return sizeof(*capabilities);
+}
+
 static bool is_configuration_valid(const uint8_t *config_buffer, uint8_t config_size) {
     const a2dp_sbc_t *config = (const a2dp_sbc_t *) config_buffer;
 
@@ -310,38 +378,7 @@ static uint8_t fill_preferred_configuration(const pa_sample_spec *default_sample
     return sizeof(*config);
 }
 
-static void set_params(struct sbc_info *sbc_info) {
-    sbc_info->sbc.frequency = sbc_info->frequency;
-    sbc_info->sbc.blocks = sbc_info->blocks;
-    sbc_info->sbc.subbands = sbc_info->subbands;
-    sbc_info->sbc.mode = sbc_info->mode;
-    sbc_info->sbc.allocation = sbc_info->allocation;
-    sbc_info->sbc.bitpool = sbc_info->initial_bitpool;
-    sbc_info->sbc.endian = SBC_LE;
-
-    sbc_info->codesize = sbc_get_codesize(&sbc_info->sbc);
-    sbc_info->frame_length = sbc_get_frame_length(&sbc_info->sbc);
-}
-
-static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec) {
-    struct sbc_info *sbc_info;
-    const a2dp_sbc_t *config = (const a2dp_sbc_t *) config_buffer;
-    int ret;
-
-    pa_assert(config_size == sizeof(*config));
-    pa_assert(!for_backchannel);
-
-    sbc_info = pa_xnew0(struct sbc_info, 1);
-
-    ret = sbc_init(&sbc_info->sbc, 0);
-    if (ret != 0) {
-        pa_xfree(sbc_info);
-        pa_log_error("SBC initialization failed: %d", ret);
-        return NULL;
-    }
-
-    sample_spec->format = PA_SAMPLE_S16LE;
-
+static void set_info_and_sample_spec_from_sbc_config(struct sbc_info *sbc_info, pa_sample_spec *sample_spec, const a2dp_sbc_t *config) {
     switch (config->frequency) {
         case SBC_SAMPLING_FREQ_16000:
             sbc_info->frequency = SBC_FREQ_16000;
@@ -398,9 +435,11 @@ static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config
     switch (config->subbands) {
         case SBC_SUBBANDS_4:
             sbc_info->subbands = SBC_SB_4;
+            sbc_info->nr_subbands = 4;
             break;
         case SBC_SUBBANDS_8:
             sbc_info->subbands = SBC_SB_8;
+            sbc_info->nr_subbands = 8;
             break;
         default:
             pa_assert_not_reached();
@@ -409,15 +448,19 @@ static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config
     switch (config->block_length) {
         case SBC_BLOCK_LENGTH_4:
             sbc_info->blocks = SBC_BLK_4;
+            sbc_info->nr_blocks = 4;
             break;
         case SBC_BLOCK_LENGTH_8:
             sbc_info->blocks = SBC_BLK_8;
+            sbc_info->nr_blocks = 8;
             break;
         case SBC_BLOCK_LENGTH_12:
             sbc_info->blocks = SBC_BLK_12;
+            sbc_info->nr_blocks = 12;
             break;
         case SBC_BLOCK_LENGTH_16:
             sbc_info->blocks = SBC_BLK_16;
+            sbc_info->nr_blocks = 16;
             break;
         default:
             pa_assert_not_reached();
@@ -425,6 +468,182 @@ static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config
 
     sbc_info->min_bitpool = config->min_bitpool;
     sbc_info->max_bitpool = config->max_bitpool;
+}
+
+static void set_params(struct sbc_info *sbc_info) {
+    sbc_info->sbc.frequency = sbc_info->frequency;
+    sbc_info->sbc.blocks = sbc_info->blocks;
+    sbc_info->sbc.subbands = sbc_info->subbands;
+    sbc_info->sbc.mode = sbc_info->mode;
+    sbc_info->sbc.allocation = sbc_info->allocation;
+    sbc_info->sbc.bitpool = sbc_info->initial_bitpool;
+    sbc_info->sbc.endian = SBC_LE;
+
+    sbc_info->codesize = sbc_get_codesize(&sbc_info->sbc);
+    sbc_info->frame_length = sbc_get_frame_length(&sbc_info->sbc);
+}
+
+uint8_t sbc_get_max_bitpool_below_rate(a2dp_sbc_t *config, uint8_t lower_bound, uint8_t upper_bound, uint32_t bitrate_cap) {
+    pa_sample_spec sample_spec;
+    struct sbc_info sbc_info;
+    int ret;
+
+    pa_assert(config);
+
+    ret = sbc_init(&sbc_info.sbc, 0);
+    if (ret != 0) {
+        pa_log_error("SBC initialization failed: %d", ret);
+        return lower_bound;
+    }
+
+    set_info_and_sample_spec_from_sbc_config(&sbc_info, &sample_spec, config);
+
+    while (upper_bound - lower_bound > 1) {
+        size_t midpoint = (upper_bound + lower_bound) / 2;
+
+        sbc_info.initial_bitpool = midpoint;
+        set_params(&sbc_info);
+
+        size_t bitrate = sbc_info.frame_length * 8 * sample_spec.rate / (sbc_info.nr_subbands * sbc_info.nr_blocks);
+
+        if (bitrate > bitrate_cap)
+            upper_bound = midpoint;
+        else
+            lower_bound = midpoint;
+    }
+
+    sbc_finish(&sbc_info.sbc);
+
+    pa_log_debug("SBC target bitrate %u bitpool %u sample rate %u", bitrate_cap, lower_bound, sample_spec.rate);
+
+    return lower_bound;
+}
+
+static uint8_t fill_preferred_configuration_xq(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE], uint32_t bitrate_cap) {
+    a2dp_sbc_t *config = (a2dp_sbc_t *) config_buffer;
+    const a2dp_sbc_t *capabilities = (const a2dp_sbc_t *) capabilities_buffer;
+    int i;
+
+    static const struct {
+        uint32_t rate;
+        uint8_t cap;
+    } freq_table[] = {
+        { 16000U, SBC_SAMPLING_FREQ_16000 },
+        { 32000U, SBC_SAMPLING_FREQ_32000 },
+        { 44100U, SBC_SAMPLING_FREQ_44100 },
+        { 48000U, SBC_SAMPLING_FREQ_48000 }
+    };
+
+    if (capabilities_size != sizeof(*capabilities)) {
+        pa_log_error("Invalid size of capabilities buffer");
+        return 0;
+    }
+
+    pa_zero(*config);
+
+    /* Find the lowest freq that is at least as high as the requested sampling rate */
+    for (i = 0; (unsigned) i < PA_ELEMENTSOF(freq_table); i++)
+        if (freq_table[i].rate >= default_sample_spec->rate && (capabilities->frequency & freq_table[i].cap)) {
+            config->frequency = freq_table[i].cap;
+            break;
+        }
+
+    if ((unsigned) i == PA_ELEMENTSOF(freq_table)) {
+        for (--i; i >= 0; i--) {
+            if (capabilities->frequency & freq_table[i].cap) {
+                config->frequency = freq_table[i].cap;
+                break;
+            }
+        }
+
+        if (i < 0) {
+            pa_log_error("Not suitable sample rate");
+            return 0;
+        }
+    }
+
+    pa_assert((unsigned) i < PA_ELEMENTSOF(freq_table));
+
+    if (default_sample_spec->channels <= 1) {
+        if (capabilities->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
+            config->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
+        else {
+            pa_log_error("No supported channel modes");
+            return 0;
+        }
+    } else {
+        if (capabilities->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
+            config->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
+        else {
+            pa_log_error("No supported channel modes");
+            return 0;
+        }
+    }
+
+    if (capabilities->block_length & SBC_BLOCK_LENGTH_16)
+        config->block_length = SBC_BLOCK_LENGTH_16;
+    else {
+        pa_log_error("No supported block lengths");
+        return 0;
+    }
+
+    if (capabilities->subbands & SBC_SUBBANDS_8)
+        config->subbands = SBC_SUBBANDS_8;
+    else {
+        pa_log_error("No supported subbands");
+        return 0;
+    }
+
+    if (capabilities->allocation_method & SBC_ALLOCATION_LOUDNESS)
+        config->allocation_method = SBC_ALLOCATION_LOUDNESS;
+    else {
+        pa_log_error("No supported allocation method");
+        return 0;
+    }
+
+    config->min_bitpool = (uint8_t) PA_MAX(SBC_MIN_BITPOOL, capabilities->min_bitpool);
+    config->max_bitpool = sbc_get_max_bitpool_below_rate(config, config->min_bitpool, capabilities->max_bitpool, bitrate_cap);
+
+    if (config->min_bitpool > config->max_bitpool) {
+        pa_log_error("No supported bitpool");
+        return 0;
+    }
+
+    return sizeof(*config);
+}
+
+static uint8_t fill_preferred_configuration_xq_453kbps(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_preferred_configuration_xq(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, 453000);
+}
+
+static uint8_t fill_preferred_configuration_xq_512kbps(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_preferred_configuration_xq(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, 512000);
+}
+
+static uint8_t fill_preferred_configuration_xq_552kbps(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_preferred_configuration_xq(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, 552000);
+}
+
+static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec, pa_core *core) {
+    struct sbc_info *sbc_info;
+    const a2dp_sbc_t *config = (const a2dp_sbc_t *) config_buffer;
+    int ret;
+
+    pa_assert(config_size == sizeof(*config));
+    pa_assert(!for_backchannel);
+
+    sbc_info = pa_xnew0(struct sbc_info, 1);
+
+    ret = sbc_init(&sbc_info->sbc, 0);
+    if (ret != 0) {
+        pa_xfree(sbc_info);
+        pa_log_error("SBC initialization failed: %d", ret);
+        return NULL;
+    }
+
+    sample_spec->format = PA_SAMPLE_S16LE;
+
+    set_info_and_sample_spec_from_sbc_config(sbc_info, sample_spec, config);
 
     /* Set minimum bitpool for source to get the maximum possible block_size
      * in get_block_size() function. This block_size is length of buffer used
@@ -485,7 +704,7 @@ static int reset(void *codec_info) {
 
 static size_t get_block_size(void *codec_info, size_t link_mtu) {
     struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
-    size_t rtp_size = sizeof(struct rtp_header) + sizeof(struct rtp_sbc_payload);
+    size_t rtp_size = sizeof(struct rtp_header) + sizeof(struct rtp_payload);
     size_t frame_count = (link_mtu - rtp_size) / sbc_info->frame_length;
 
     /* frame_count is only 4 bit number */
@@ -495,18 +714,34 @@ static size_t get_block_size(void *codec_info, size_t link_mtu) {
     return frame_count * sbc_info->codesize;
 }
 
+static size_t get_encoded_block_size(void *codec_info, size_t input_size) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    size_t rtp_size = sizeof(struct rtp_header) + sizeof(struct rtp_payload);
+
+    /* input size should be aligned to codec input block size */
+    pa_assert_fp(input_size % sbc_info->codesize == 0);
+
+    return (input_size / sbc_info->codesize) * sbc_info->frame_length + rtp_size;
+}
+
 static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
     struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
     uint8_t bitpool;
 
-    /* Check if bitpool is already at its limit */
-    if (sbc_info->sbc.bitpool <= SBC_BITPOOL_DEC_LIMIT)
+    bitpool = PA_MAX(sbc_info->sbc.bitpool - SBC_BITPOOL_DEC_STEP, sbc_info->min_bitpool);
+
+    if (sbc_info->sbc.bitpool == bitpool)
         return 0;
 
-    bitpool = sbc_info->sbc.bitpool - SBC_BITPOOL_DEC_STEP;
+    set_bitpool(sbc_info, bitpool);
+    return get_block_size(codec_info, write_link_mtu);
+}
+
+static size_t increase_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    uint8_t bitpool;
 
-    if (bitpool < SBC_BITPOOL_DEC_LIMIT)
-        bitpool = SBC_BITPOOL_DEC_LIMIT;
+    bitpool = PA_MIN(sbc_info->sbc.bitpool + SBC_BITPOOL_INC_STEP, sbc_info->max_bitpool);
 
     if (sbc_info->sbc.bitpool == bitpool)
         return 0;
@@ -518,14 +753,14 @@ static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
 static size_t encode_buffer(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
     struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
     struct rtp_header *header;
-    struct rtp_sbc_payload *payload;
+    struct rtp_payload *payload;
     uint8_t *d;
     const uint8_t *p;
     size_t to_write, to_encode;
     uint8_t frame_count;
 
     header = (struct rtp_header*) output_buffer;
-    payload = (struct rtp_sbc_payload*) (output_buffer + sizeof(*header));
+    payload = (struct rtp_payload*) (output_buffer + sizeof(*header));
 
     frame_count = 0;
 
@@ -601,14 +836,14 @@ static size_t decode_buffer(void *codec_info, const uint8_t *input_buffer, size_
     struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
 
     struct rtp_header *header;
-    struct rtp_sbc_payload *payload;
+    struct rtp_payload *payload;
     const uint8_t *p;
     uint8_t *d;
     size_t to_write, to_decode;
     uint8_t frame_count;
 
     header = (struct rtp_header *) input_buffer;
-    payload = (struct rtp_sbc_payload*) (input_buffer + sizeof(*header));
+    payload = (struct rtp_payload*) (input_buffer + sizeof(*header));
 
     frame_count = payload->frame_count;
 
@@ -661,22 +896,115 @@ static size_t decode_buffer(void *codec_info, const uint8_t *input_buffer, size_
     return d - output_buffer;
 }
 
-const pa_a2dp_codec pa_a2dp_codec_sbc = {
-    .name = "sbc",
-    .description = "SBC",
+const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_sbc = {
     .id = { A2DP_CODEC_SBC, 0, 0 },
     .support_backchannel = false,
+    .can_be_supported = can_be_supported,
     .can_accept_capabilities = can_accept_capabilities,
     .choose_remote_endpoint = choose_remote_endpoint,
     .fill_capabilities = fill_capabilities,
     .is_configuration_valid = is_configuration_valid,
     .fill_preferred_configuration = fill_preferred_configuration,
-    .init = init,
-    .deinit = deinit,
-    .reset = reset,
-    .get_read_block_size = get_block_size,
-    .get_write_block_size = get_block_size,
-    .reduce_encoder_bitrate = reduce_encoder_bitrate,
-    .encode_buffer = encode_buffer,
-    .decode_buffer = decode_buffer,
+    .bt_codec = {
+        .name = "sbc",
+        .description = "SBC",
+        .init = init,
+        .deinit = deinit,
+        .reset = reset,
+        .get_read_block_size = get_block_size,
+        .get_write_block_size = get_block_size,
+        .get_encoded_block_size = get_encoded_block_size,
+        .reduce_encoder_bitrate = reduce_encoder_bitrate,
+        .increase_encoder_bitrate = increase_encoder_bitrate,
+        .encode_buffer = encode_buffer,
+        .decode_buffer = decode_buffer,
+    },
+};
+
+/* There are multiple definitions of SBC XQ, but in all cases this is
+ * SBC codec in Dual Channel mode, 8 bands, block length 16, allocation method Loudness,
+ * with bitpool adjusted to match target bitrates.
+ *
+ * Most commonly choosen bitrates and reasons are:
+ * 453000 - this yields most efficient packing of frames on Android for bluetooth EDR 2mbps
+ * 512000 - this looks to be old limit stated in bluetooth documents
+ * 552000 - this yields most efficient packing of frames on Android for bluetooth EDR 3mbps
+ *
+ * Efficient packing considerations do not apply on Linux (yet?) but still
+ * we can gain from increased bitrate.
+ */
+
+const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_sbc_xq_453 = {
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_be_supported = can_be_supported,
+    .can_accept_capabilities = can_accept_capabilities_xq,
+    .choose_remote_endpoint = choose_remote_endpoint_xq,
+    .fill_capabilities = fill_capabilities_xq,
+    .is_configuration_valid = is_configuration_valid,
+    .fill_preferred_configuration = fill_preferred_configuration_xq_453kbps,
+    .bt_codec = {
+        .name = "sbc_xq_453",
+        .description = "SBC XQ 453kbps",
+        .init = init,
+        .deinit = deinit,
+        .reset = reset,
+        .get_read_block_size = get_block_size,
+        .get_write_block_size = get_block_size,
+        .get_encoded_block_size = get_encoded_block_size,
+        .reduce_encoder_bitrate = reduce_encoder_bitrate,
+        .increase_encoder_bitrate = increase_encoder_bitrate,
+        .encode_buffer = encode_buffer,
+        .decode_buffer = decode_buffer,
+    },
+};
+
+const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_sbc_xq_512 = {
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_be_supported = can_be_supported,
+    .can_accept_capabilities = can_accept_capabilities_xq,
+    .choose_remote_endpoint = choose_remote_endpoint_xq,
+    .fill_capabilities = fill_capabilities_xq,
+    .is_configuration_valid = is_configuration_valid,
+    .fill_preferred_configuration = fill_preferred_configuration_xq_512kbps,
+    .bt_codec = {
+        .name = "sbc_xq_512",
+        .description = "SBC XQ 512kbps",
+        .init = init,
+        .deinit = deinit,
+        .reset = reset,
+        .get_read_block_size = get_block_size,
+        .get_write_block_size = get_block_size,
+        .get_encoded_block_size = get_encoded_block_size,
+        .reduce_encoder_bitrate = reduce_encoder_bitrate,
+        .increase_encoder_bitrate = increase_encoder_bitrate,
+        .encode_buffer = encode_buffer,
+        .decode_buffer = decode_buffer,
+    },
+};
+
+const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_sbc_xq_552 = {
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_be_supported = can_be_supported,
+    .can_accept_capabilities = can_accept_capabilities_xq,
+    .choose_remote_endpoint = choose_remote_endpoint_xq,
+    .fill_capabilities = fill_capabilities_xq,
+    .is_configuration_valid = is_configuration_valid,
+    .fill_preferred_configuration = fill_preferred_configuration_xq_552kbps,
+    .bt_codec = {
+        .name = "sbc_xq_552",
+        .description = "SBC XQ 552kbps",
+        .init = init,
+        .deinit = deinit,
+        .reset = reset,
+        .get_read_block_size = get_block_size,
+        .get_write_block_size = get_block_size,
+        .get_encoded_block_size = get_encoded_block_size,
+        .reduce_encoder_bitrate = reduce_encoder_bitrate,
+        .increase_encoder_bitrate = increase_encoder_bitrate,
+        .encode_buffer = encode_buffer,
+        .decode_buffer = decode_buffer,
+    },
 };
diff --git a/src/modules/bluetooth/a2dp-codec-util.c b/src/modules/bluetooth/a2dp-codec-util.c
index 94d01e7..7db0251 100755
--- a/src/modules/bluetooth/a2dp-codec-util.c
+++ b/src/modules/bluetooth/a2dp-codec-util.c
@@ -23,34 +23,119 @@
 
 #include <pulsecore/core.h>
 #include <pulsecore/core-util.h>
+#if defined(HAVE_GSTAPTX) || defined(HAVE_GSTLDAC)
+#include <gst/gst.h>
+#endif
 
 #include "a2dp-codec-util.h"
 
-extern const pa_a2dp_codec pa_a2dp_codec_sbc;
+extern const pa_bt_codec pa_bt_codec_msbc;
+extern const pa_bt_codec pa_bt_codec_cvsd;
+
+/* List of HSP/HFP codecs.
+ */
+static const pa_bt_codec *pa_hf_codecs[] = {
+    &pa_bt_codec_cvsd,
+    &pa_bt_codec_msbc,
+};
+
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_sbc;
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_sbc_xq_453;
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_sbc_xq_512;
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_sbc_xq_552;
+#ifdef HAVE_GSTAPTX
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_aptx;
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_aptx_hd;
+#endif
+#ifdef HAVE_GSTLDAC
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_ldac_eqmid_hq;
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_ldac_eqmid_sq;
+extern const pa_a2dp_endpoint_conf pa_a2dp_endpoint_conf_ldac_eqmid_mq;
+#endif
 
 /* This is list of supported codecs. Their order is important.
- * Codec with higher index has higher priority. */
-const pa_a2dp_codec *pa_a2dp_codecs[] = {
-    &pa_a2dp_codec_sbc,
+ * Codec with lower index has higher priority. */
+static const pa_a2dp_endpoint_conf *pa_a2dp_endpoint_configurations[] = {
+#ifdef HAVE_GSTLDAC
+    &pa_a2dp_endpoint_conf_ldac_eqmid_hq,
+    &pa_a2dp_endpoint_conf_ldac_eqmid_sq,
+    &pa_a2dp_endpoint_conf_ldac_eqmid_mq,
+#endif
+#ifdef HAVE_GSTAPTX
+    &pa_a2dp_endpoint_conf_aptx_hd,
+    &pa_a2dp_endpoint_conf_aptx,
+#endif
+    &pa_a2dp_endpoint_conf_sbc,
+    &pa_a2dp_endpoint_conf_sbc_xq_453,
+    &pa_a2dp_endpoint_conf_sbc_xq_512,
+    &pa_a2dp_endpoint_conf_sbc_xq_552,
 };
 
-unsigned int pa_bluetooth_a2dp_codec_count(void) {
-    return PA_ELEMENTSOF(pa_a2dp_codecs);
+unsigned int pa_bluetooth_a2dp_endpoint_conf_count(void) {
+    return PA_ELEMENTSOF(pa_a2dp_endpoint_configurations);
 }
 
-const pa_a2dp_codec *pa_bluetooth_a2dp_codec_iter(unsigned int i) {
-    pa_assert(i < pa_bluetooth_a2dp_codec_count());
-    return pa_a2dp_codecs[i];
+const pa_a2dp_endpoint_conf *pa_bluetooth_a2dp_endpoint_conf_iter(unsigned int i) {
+    pa_assert(i < pa_bluetooth_a2dp_endpoint_conf_count());
+    return pa_a2dp_endpoint_configurations[i];
 }
 
-const pa_a2dp_codec *pa_bluetooth_get_a2dp_codec(const char *name) {
+unsigned int pa_bluetooth_hf_codec_count(void) {
+    return PA_ELEMENTSOF(pa_hf_codecs);
+}
+
+const pa_bt_codec *pa_bluetooth_hf_codec_iter(unsigned int i) {
+    pa_assert(i < pa_bluetooth_hf_codec_count());
+    return pa_hf_codecs[i];
+}
+
+const pa_bt_codec *pa_bluetooth_get_hf_codec(const char *name) {
     unsigned int i;
-    unsigned int count = pa_bluetooth_a2dp_codec_count();
+
+    for (i = 0; i < PA_ELEMENTSOF(pa_hf_codecs); ++i) {
+        if (pa_streq(pa_hf_codecs[i]->name, name))
+            return pa_hf_codecs[i];
+    }
+
+    return NULL;
+}
+
+const pa_a2dp_endpoint_conf *pa_bluetooth_get_a2dp_endpoint_conf(const char *name) {
+    unsigned int i;
+    unsigned int count = pa_bluetooth_a2dp_endpoint_conf_count();
 
     for (i = 0; i < count; i++) {
-        if (pa_streq(pa_a2dp_codecs[i]->name, name))
-            return pa_a2dp_codecs[i];
+        if (pa_streq(pa_a2dp_endpoint_configurations[i]->bt_codec.name, name))
+            return pa_a2dp_endpoint_configurations[i];
     }
 
     return NULL;
 }
+
+void pa_bluetooth_a2dp_codec_gst_init(void) {
+#if defined(HAVE_GSTAPTX) || defined(HAVE_GSTLDAC)
+    GError *error = NULL;
+
+    if (!gst_init_check(NULL, NULL, &error)) {
+        pa_log_error("Could not initialise GStreamer: %s", error->message);
+        g_error_free(error);
+        return;
+    }
+    pa_log_info("GStreamer initialisation done");
+#endif
+}
+
+bool pa_bluetooth_a2dp_codec_is_available(const pa_a2dp_codec_id *id, bool is_a2dp_sink) {
+    unsigned int i;
+    unsigned int count = pa_bluetooth_a2dp_endpoint_conf_count();
+    const pa_a2dp_endpoint_conf *conf;
+
+    for (i = 0; i < count; i++) {
+        conf = pa_bluetooth_a2dp_endpoint_conf_iter(i);
+        if (memcmp(id, &conf->id, sizeof(pa_a2dp_codec_id)) == 0
+                && conf->can_be_supported(is_a2dp_sink))
+            return true;
+    }
+
+    return false;
+}
diff --git a/src/modules/bluetooth/a2dp-codec-util.h b/src/modules/bluetooth/a2dp-codec-util.h
index 86f233a..7288cff 100755
--- a/src/modules/bluetooth/a2dp-codec-util.h
+++ b/src/modules/bluetooth/a2dp-codec-util.h
@@ -23,12 +23,27 @@
 #include "a2dp-codec-api.h"
 
 /* Get number of supported A2DP codecs */
-unsigned int pa_bluetooth_a2dp_codec_count(void);
+unsigned int pa_bluetooth_a2dp_endpoint_conf_count(void);
 
 /* Get i-th codec. Codec with higher number has higher priority */
-const pa_a2dp_codec *pa_bluetooth_a2dp_codec_iter(unsigned int i);
+const pa_a2dp_endpoint_conf *pa_bluetooth_a2dp_endpoint_conf_iter(unsigned int i);
 
 /* Get codec by name */
-const pa_a2dp_codec *pa_bluetooth_get_a2dp_codec(const char *name);
+const pa_a2dp_endpoint_conf *pa_bluetooth_get_a2dp_endpoint_conf(const char *name);
+
+/* Check if the given codec can be supported in A2DP_SINK or A2DP_SOURCE */
+bool pa_bluetooth_a2dp_codec_is_available(const pa_a2dp_codec_id *id, bool is_a2dp_sink);
+
+/* Initialise GStreamer */
+void pa_bluetooth_a2dp_codec_gst_init(void);
+
+/* Get number of supported HSP/HFP codecs */
+unsigned int pa_bluetooth_hf_codec_count(void);
+
+/* Get i-th codec. Codec with higher number has higher priority */
+const pa_bt_codec *pa_bluetooth_hf_codec_iter(unsigned int i);
+
+/* Get HSP/HFP codec by name */
+const pa_bt_codec *pa_bluetooth_get_hf_codec(const char *name);
 
 #endif
diff --git a/src/modules/bluetooth/backend-native.c b/src/modules/bluetooth/backend-native.c
index 5ba7439..f6b85e9 100755
--- a/src/modules/bluetooth/backend-native.c
+++ b/src/modules/bluetooth/backend-native.c
@@ -21,6 +21,8 @@
 #include <config.h>
 #endif
 
+#include <pulse/util.h>
+
 #include <pulsecore/shared.h>
 #include <pulsecore/core-error.h>
 #include <pulsecore/core-util.h>
@@ -35,12 +37,16 @@
 #include <bluetooth/sco.h>
 
 #include "bluez5-util.h"
+#include "bt-codec-msbc.h"
 
 struct pa_bluetooth_backend {
   pa_core *core;
   pa_dbus_connection *connection;
   pa_bluetooth_discovery *discovery;
-  bool enable_hs_role;
+  pa_hook_slot *adapter_uuids_changed_slot;
+  bool enable_shared_profiles;
+  bool enable_hsp_hs;
+  bool enable_hfp_hf;
 
   PA_LLIST_HEAD(pa_dbus_pending, pending);
 };
@@ -53,21 +59,60 @@ struct transport_data {
     pa_mainloop_api *mainloop;
 };
 
-#define BLUEZ_SERVICE "org.bluez"
-#define BLUEZ_MEDIA_TRANSPORT_INTERFACE BLUEZ_SERVICE ".MediaTransport1"
+struct hfp_config {
+    uint32_t capabilities;
+    int state;
+    bool support_codec_negotiation;
+    bool support_msbc;
+    bool supports_indicators;
+    int selected_codec;
+};
 
-#define BLUEZ_ERROR_NOT_SUPPORTED "org.bluez.Error.NotSupported"
+/*
+ * the separate hansfree headset (HF) and Audio Gateway (AG) features
+ */
+enum hfp_hf_features {
+    HFP_HF_EC_NR = 0,
+    HFP_HF_CALL_WAITING = 1,
+    HFP_HF_CLI = 2,
+    HFP_HF_VR = 3,
+    HFP_HF_RVOL = 4,
+    HFP_HF_ESTATUS = 5,
+    HFP_HF_ECALL = 6,
+    HFP_HF_CODECS = 7,
+    HFP_HF_INDICATORS = 8,
+};
+
+enum hfp_ag_features {
+    HFP_AG_THREE_WAY = 0,
+    HFP_AG_EC_NR = 1,
+    HFP_AG_VR = 2,
+    HFP_AG_RING = 3,
+    HFP_AG_NUM_TAG = 4,
+    HFP_AG_REJECT = 5,
+    HFP_AG_ESTATUS = 6,
+    HFP_AG_ECALL = 7,
+    HFP_AG_EERR = 8,
+    HFP_AG_CODECS = 9,
+    HFP_AG_INDICATORS = 10,
+};
 
-#define BLUEZ_PROFILE_MANAGER_INTERFACE BLUEZ_SERVICE ".ProfileManager1"
-#define BLUEZ_PROFILE_INTERFACE BLUEZ_SERVICE ".Profile1"
+/* gateway features we support, which is as little as we can get away with */
+static uint32_t hfp_features =
+    /* HFP 1.6 requires this */
+    (1 << HFP_AG_ESTATUS ) | (1 << HFP_AG_CODECS) | (1 << HFP_AG_INDICATORS);
 
 #define HSP_AG_PROFILE "/Profile/HSPAGProfile"
+#define HFP_AG_PROFILE "/Profile/HFPAGProfile"
 #define HSP_HS_PROFILE "/Profile/HSPHSProfile"
 
 /* RFCOMM channel for HSP headset role
  * The choice seems to be a bit arbitrary -- it looks like at least channels 2, 4 and 5 also work*/
 #define HSP_HS_DEFAULT_CHANNEL  3
 
+/* Total number of trying to reconnect */
+#define SCO_RECONNECTION_COUNT 3
+
 #define PROFILE_INTROSPECT_XML                                          \
     DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                           \
     "<node>"                                                            \
@@ -83,13 +128,52 @@ struct transport_data {
     "   <arg name=\"opts\" direction=\"in\" type=\"a{sv}\"/>"           \
     "  </method>"                                                       \
     " </interface>"                                                     \
-    " <interface name=\"org.freedesktop.DBus.Introspectable\">"         \
+    " <interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">"           \
     "  <method name=\"Introspect\">"                                    \
     "   <arg name=\"data\" type=\"s\" direction=\"out\"/>"              \
     "  </method>"                                                       \
     " </interface>"                                                     \
     "</node>"
 
+static pa_volume_t hsp_gain_to_volume(uint16_t gain) {
+    pa_volume_t volume = (pa_volume_t) ((
+        gain * PA_VOLUME_NORM
+        /* Round to closest by adding half the denominator */
+        + HSP_MAX_GAIN / 2
+    ) / HSP_MAX_GAIN);
+
+    if (volume > PA_VOLUME_NORM)
+        volume = PA_VOLUME_NORM;
+
+    return volume;
+}
+
+static uint16_t volume_to_hsp_gain(pa_volume_t volume) {
+    uint16_t gain = volume * HSP_MAX_GAIN / PA_VOLUME_NORM;
+
+    if (gain > HSP_MAX_GAIN)
+        gain = HSP_MAX_GAIN;
+
+    return gain;
+}
+
+static bool is_peer_audio_gateway(pa_bluetooth_profile_t peer_profile) {
+    switch(peer_profile) {
+        case PA_BLUETOOTH_PROFILE_HFP_HF:
+        case PA_BLUETOOTH_PROFILE_HSP_HS:
+            return false;
+        case PA_BLUETOOTH_PROFILE_HFP_AG:
+        case PA_BLUETOOTH_PROFILE_HSP_AG:
+            return true;
+        default:
+            pa_assert_not_reached();
+    }
+}
+
+static bool is_pulseaudio_audio_gateway(pa_bluetooth_profile_t peer_profile) {
+    return !is_peer_audio_gateway(peer_profile);
+}
+
 static pa_dbus_pending* send_and_add_to_pending(pa_bluetooth_backend *backend, DBusMessage *m,
         DBusPendingCallNotifyFunction func, void *call_data) {
 
@@ -108,6 +192,59 @@ static pa_dbus_pending* send_and_add_to_pending(pa_bluetooth_backend *backend, D
     return p;
 }
 
+static void rfcomm_fmt_write(int fd, const char* fmt_line, const char *fmt_command, va_list ap)
+{
+    size_t len;
+    char buf[512];
+    char command[512];
+
+    pa_vsnprintf(command, sizeof(command), fmt_command, ap);
+
+    pa_log_debug("RFCOMM >> %s", command);
+
+    len = pa_snprintf(buf, sizeof(buf), fmt_line, command);
+
+    /* we ignore any errors, it's not critical and real errors should
+     * be caught with the HANGUP and ERROR events handled above */
+
+    if ((size_t)write(fd, buf, len) != len)
+        pa_log_error("RFCOMM write error: %s", pa_cstrerror(errno));
+}
+
+/* The format of COMMAND line sent from HS to AG is COMMAND<cr> */
+static void rfcomm_write_command(int fd, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    rfcomm_fmt_write(fd, "%s\r", fmt, ap);
+    va_end(ap);
+}
+
+/* The format of RESPONSE line sent from AG to HS is <cr><lf>RESPONSE<cr><lf> */
+static void rfcomm_write_response(int fd, const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    rfcomm_fmt_write(fd, "\r\n%s\r\n", fmt, ap);
+    va_end(ap);
+}
+
+static int sco_setsockopt_enable_bt_voice(pa_bluetooth_transport *t, int fd) {
+    /* the mSBC codec requires a special transparent eSCO connection */
+    struct bt_voice voice;
+
+    memset(&voice, 0, sizeof(voice));
+    voice.setting = BT_VOICE_TRANSPARENT;
+    if (setsockopt(fd, SOL_BLUETOOTH, BT_VOICE, &voice, sizeof(voice)) < 0) {
+        pa_log_error("sockopt(): %s", pa_cstrerror(errno));
+        return -1;
+    }
+    pa_log_info("Enabled BT_VOICE_TRANSPARENT connection for mSBC");
+    return 0;
+}
+
 static int sco_do_connect(pa_bluetooth_transport *t) {
     pa_bluetooth_device *d = t->device;
     struct sockaddr_sco addr;
@@ -143,6 +280,9 @@ static int sco_do_connect(pa_bluetooth_transport *t) {
         goto fail_close;
     }
 
+    if (t->setsockopt && t->setsockopt(t, sock) < 0)
+        goto fail_close;
+
     memset(&addr, 0, len);
     addr.sco_family = AF_BLUETOOTH;
     bacpy(&addr.sco_bdaddr, &dst);
@@ -185,17 +325,38 @@ fail:
 static int sco_acquire_cb(pa_bluetooth_transport *t, bool optional, size_t *imtu, size_t *omtu) {
     int sock;
     socklen_t len;
+    int i;
 
     if (optional)
         sock = sco_do_accept(t);
-    else
-        sock = sco_do_connect(t);
+    else {
+        for (i = 0; i < SCO_RECONNECTION_COUNT; i++) {
+            sock = sco_do_connect(t);
+
+            if (sock < 0) {
+                pa_log_debug("err is %s and reconnection count is %d", pa_cstrerror(errno), i);
+                pa_msleep(300);
+                continue;
+            } else
+                break;
+        }
+    }
 
     if (sock < 0)
         goto fail;
 
-    if (imtu) *imtu = 48;
-    if (omtu) *omtu = 48;
+    /* The correct block size should take into account the SCO MTU from
+     * the Bluetooth adapter and (for adapters in the USB bus) the MxPS
+     * value from the Isoc USB endpoint in use by btusb and should be
+     * made available to userspace by the Bluetooth kernel subsystem.
+     *
+     * Set initial MTU to max known payload length of HCI packet
+     * in USB Alternate Setting 5 (144 bytes)
+     * See also pa_bluetooth_transport::last_read_size handling
+     * and comment about MTU size in bt_prepare_encoder_buffer()
+     */
+    if (imtu) *imtu = 144;
+    if (omtu) *omtu = 144;
 
     if (t->device->autodetect_mtu) {
         struct sco_options sco_opt;
@@ -223,6 +384,61 @@ static void sco_release_cb(pa_bluetooth_transport *t) {
     /* device will close the SCO socket for us */
 }
 
+static ssize_t sco_transport_write(pa_bluetooth_transport *t, int fd, const void* buffer, size_t size, size_t write_mtu) {
+    ssize_t l = 0;
+    size_t written = 0;
+    size_t write_size;
+
+    pa_assert(t);
+
+    /* since SCO setup is symmetric, fix write MTU to be size of last read packet */
+    if (t->last_read_size)
+        write_mtu = PA_MIN(t->last_read_size, write_mtu);
+
+    /* if encoder buffer has less data than required to make complete packet */
+    if (size < write_mtu)
+        return 0;
+
+    /* write out MTU sized chunks only */
+    while (written < size) {
+        write_size = PA_MIN(size - written, write_mtu);
+        if (write_size < write_mtu)
+            break;
+        l = pa_write(fd, buffer + written, write_size, &t->stream_write_type);
+        if (l < 0)
+            break;
+        written += l;
+    }
+
+    if (l < 0) {
+        if (errno == EAGAIN) {
+            /* Hmm, apparently the socket was not writable, give up for now */
+            pa_log_debug("Got EAGAIN on write() after POLLOUT, probably there is a temporary connection loss.");
+            /* Drain write buffer */
+            written = size;
+        } else if (errno == EINVAL && t->last_read_size == 0) {
+            /* Likely write_link_mtu is still wrong, retry after next successful read */
+            pa_log_debug("got write EINVAL, next successful read should fix MTU");
+            /* Drain write buffer */
+            written = size;
+        } else {
+            pa_log_error("Failed to write data to socket: %s", pa_cstrerror(errno));
+            /* Report error from write call */
+            return -1;
+        }
+    }
+
+    /* if too much data left discard it all */
+    if (size - written >= write_mtu) {
+        pa_log_warn("Wrote memory block to socket only partially! %lu written, discarding pending write size %lu larger than write_mtu %lu",
+                    written, size, write_mtu);
+        /* Drain write buffer */
+        written = size;
+    }
+
+    return written;
+}
+
 static void sco_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_io_event_flags_t events, void *userdata) {
     pa_bluetooth_transport *t = userdata;
 
@@ -293,49 +509,57 @@ static void register_profile_reply(DBusPendingCall *pending, void *userdata) {
     DBusMessage *r;
     pa_dbus_pending *p;
     pa_bluetooth_backend *b;
-    char *profile;
+    pa_bluetooth_profile_t profile;
 
     pa_assert(pending);
     pa_assert_se(p = userdata);
     pa_assert_se(b = p->context_data);
-    pa_assert_se(profile = p->call_data);
+    pa_assert_se(profile = (pa_bluetooth_profile_t)p->call_data);
     pa_assert_se(r = dbus_pending_call_steal_reply(pending));
 
     if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_SUPPORTED)) {
-        pa_log_info("Couldn't register profile %s because it is disabled in BlueZ", profile);
+        pa_log_info("Couldn't register profile %s because it is disabled in BlueZ", pa_bluetooth_profile_to_string(profile));
+        profile_status_set(b->discovery, profile, PA_BLUETOOTH_PROFILE_STATUS_ACTIVE);
         goto finish;
     }
 
     if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
         pa_log_error(BLUEZ_PROFILE_MANAGER_INTERFACE ".RegisterProfile() failed: %s: %s", dbus_message_get_error_name(r),
                      pa_dbus_get_error_message(r));
+        profile_status_set(b->discovery, profile, PA_BLUETOOTH_PROFILE_STATUS_ACTIVE);
         goto finish;
     }
 
+    profile_status_set(b->discovery, profile, PA_BLUETOOTH_PROFILE_STATUS_REGISTERED);
+
 finish:
     dbus_message_unref(r);
 
     PA_LLIST_REMOVE(pa_dbus_pending, b->pending, p);
     pa_dbus_pending_free(p);
-
-    pa_xfree(profile);
 }
 
-static void register_profile(pa_bluetooth_backend *b, const char *profile, const char *uuid) {
+static void register_profile(pa_bluetooth_backend *b, const char *object, const char *uuid, pa_bluetooth_profile_t profile) {
     DBusMessage *m;
     DBusMessageIter i, d;
     dbus_bool_t autoconnect;
     dbus_uint16_t version, chan;
 
-    pa_log_debug("Registering Profile %s %s", profile, uuid);
+    pa_assert(profile_status_get(b->discovery, profile) == PA_BLUETOOTH_PROFILE_STATUS_ACTIVE);
+
+    pa_log_debug("Registering Profile %s %s", pa_bluetooth_profile_to_string(profile), uuid);
 
     pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, "/org/bluez", BLUEZ_PROFILE_MANAGER_INTERFACE, "RegisterProfile"));
 
     dbus_message_iter_init_append(m, &i);
-    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &profile));
+    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &object));
     pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_STRING, &uuid));
-    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
-            DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
+    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY,
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_VARIANT_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                     &d);
     if (pa_bluetooth_uuid_is_hsp_hs(uuid)) {
         /* In the headset role, the connection will only be initiated from the remote side */
         autoconnect = 0;
@@ -348,7 +572,170 @@ static void register_profile(pa_bluetooth_backend *b, const char *profile, const
     }
     dbus_message_iter_close_container(&i, &d);
 
-    send_and_add_to_pending(b, m, register_profile_reply, pa_xstrdup(profile));
+    profile_status_set(b->discovery, profile, PA_BLUETOOTH_PROFILE_STATUS_REGISTERING);
+    send_and_add_to_pending(b, m, register_profile_reply, (void *)profile);
+}
+
+static void transport_put(pa_bluetooth_transport *t)
+{
+    pa_bluetooth_transport_put(t);
+
+    pa_log_debug("Transport %s available for profile %s", t->path, pa_bluetooth_profile_to_string(t->profile));
+}
+
+static pa_volume_t set_sink_volume(pa_bluetooth_transport *t, pa_volume_t volume);
+static pa_volume_t set_source_volume(pa_bluetooth_transport *t, pa_volume_t volume);
+
+static bool hfp_rfcomm_handle(int fd, pa_bluetooth_transport *t, const char *buf)
+{
+    struct hfp_config *c = t->config;
+    int indicator, val;
+    char str[5];
+    const char *r;
+    size_t len;
+    const char *state;
+
+    /* first-time initialize selected codec to CVSD */
+    if (c->selected_codec == 0)
+        c->selected_codec = 1;
+
+    /* stateful negotiation */
+    if (c->state == 0 && sscanf(buf, "AT+BRSF=%d", &val) == 1) {
+        c->capabilities = val;
+        pa_log_info("HFP capabilities returns 0x%x", val);
+        rfcomm_write_response(fd, "+BRSF: %d", hfp_features);
+        c->supports_indicators = !!(1 << HFP_HF_INDICATORS);
+        c->state = 1;
+
+        return true;
+    } else if (sscanf(buf, "AT+BAC=%3s", str) == 1) {
+        c->support_msbc = false;
+
+        state = NULL;
+
+        /* check if codec id 2 (mSBC) is in the list of supported codecs */
+        while ((r = pa_split_in_place(str, ",", &len, &state))) {
+            if (len == 1 && r[0] == '2') {
+                c->support_msbc = true;
+                break;
+            }
+        }
+
+        c->support_codec_negotiation = true;
+
+        if (c->state == 1) {
+            /* initial list of codecs supported by HF */
+        } else {
+            /* HF sent updated list of codecs */
+        }
+
+        /* no state change */
+
+        return true;
+    } else if (c->state == 1 && pa_startswith(buf, "AT+CIND=?")) {
+        /* we declare minimal no indicators */
+        rfcomm_write_response(fd, "+CIND: "
+                     /* many indicators can be supported, only call and
+                      * callheld are mandatory, so that's all we reply */
+                     "(\"service\",(0-1)),"
+                     "(\"call\",(0-1)),"
+                     "(\"callsetup\",(0-3)),"
+                     "(\"callheld\",(0-2))");
+        c->state = 2;
+
+        return true;
+    } else if (c->state == 2 && pa_startswith(buf, "AT+CIND?")) {
+        rfcomm_write_response(fd, "+CIND: 0,0,0,0");
+        c->state = 3;
+
+        return true;
+    } else if ((c->state == 2 || c->state == 3) && pa_startswith(buf, "AT+CMER=")) {
+        rfcomm_write_response(fd, "OK");
+
+        if (c->support_codec_negotiation) {
+            if (c->support_msbc && pa_bluetooth_discovery_get_enable_msbc(t->device->discovery)) {
+                rfcomm_write_response(fd, "+BCS:2");
+                c->state = 4;
+            } else {
+                rfcomm_write_response(fd, "+BCS:1");
+                c->state = 4;
+            }
+        } else {
+            c->state = 5;
+            pa_bluetooth_transport_reconfigure(t, pa_bluetooth_get_hf_codec("CVSD"), sco_transport_write, NULL);
+            transport_put(t);
+        }
+
+        return false;
+    } else if (sscanf(buf, "AT+BCS=%d", &val)) {
+        if (val == 1) {
+            pa_bluetooth_transport_reconfigure(t, pa_bluetooth_get_hf_codec("CVSD"), sco_transport_write, NULL);
+        } else if (val == 2 && pa_bluetooth_discovery_get_enable_msbc(t->device->discovery)) {
+            pa_bluetooth_transport_reconfigure(t, pa_bluetooth_get_hf_codec("mSBC"), sco_transport_write, sco_setsockopt_enable_bt_voice);
+        } else {
+            pa_assert_fp(val != 1 && val != 2);
+            rfcomm_write_response(fd, "ERROR");
+            return false;
+        }
+
+        c->selected_codec = val;
+
+        if (c->state == 4) {
+            c->state = 5;
+            pa_log_info("HFP negotiated codec %s", t->bt_codec->name);
+            transport_put(t);
+        }
+
+        return true;
+    } else if (c->supports_indicators && pa_startswith(buf, "AT+BIND=?")) {
+        // Support battery indication
+        rfcomm_write_response(fd, "+BIND: (2)");
+        return true;
+    } else if (c->supports_indicators && pa_startswith(buf, "AT+BIND?")) {
+        // Battery indication is enabled
+        rfcomm_write_response(fd, "+BIND: 2,1");
+        return true;
+    } else if (c->supports_indicators && pa_startswith(buf, "AT+BIND=")) {
+        // If this comma-separated list contains `2`, the HF is
+        // able to report values for the battery indicator.
+        return true;
+    } else if (c->supports_indicators && sscanf(buf, "AT+BIEV=%u,%u", &indicator, &val)) {
+        switch (indicator) {
+            case 2:
+                pa_log_notice("Battery Level: %d%%", val);
+                if (val < 0 || val > 100) {
+                    pa_log_error("Battery HF indicator %d out of [0, 100] range", val);
+                    rfcomm_write_response(fd, "ERROR");
+                    return false;
+                }
+                pa_bluetooth_device_report_battery_level(t->device, val, "HFP 1.7 HF indicator");
+                break;
+            default:
+                pa_log_error("Unknown HF indicator %u", indicator);
+                rfcomm_write_response(fd, "ERROR");
+                return false;
+        }
+        return true;
+    } if (c->state == 4) {
+        /* the ack for the codec setting may take a while. we need
+         * to reply OK to everything else until then */
+        return true;
+    }
+
+    /* if we get here, negotiation should be complete */
+    if (c->state != 5) {
+        pa_log_error("HFP negotiation failed in state %d with inbound %s\n",
+                     c->state, buf);
+        rfcomm_write_response(fd, "ERROR");
+        return false;
+    }
+
+    /*
+     * once we're fully connected, just reply OK to everything
+     * it will just be the headset sending the occasional status
+     * update, but we process only the ones we care about
+     */
+    return true;
 }
 
 static void rfcomm_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_io_event_flags_t events, void *userdata) {
@@ -359,6 +746,11 @@ static void rfcomm_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_i
 
     if (events & (PA_IO_EVENT_HANGUP|PA_IO_EVENT_ERROR)) {
         pa_log_info("Lost RFCOMM connection.");
+        // TODO: Keep track of which profile is the current battery provider,
+        // only deregister if it is us currently providing these levels.
+        // (Also helpful to fill the 'Source' property)
+        // We might also move this to Profile1::RequestDisconnection
+        pa_bluetooth_device_deregister_battery(t->device);
         goto fail;
     }
 
@@ -366,7 +758,9 @@ static void rfcomm_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_i
         char buf[512];
         ssize_t len;
         int gain, dummy;
-        bool  do_reply = false;
+        bool do_reply = false;
+        int vendor, product, version, features;
+        int num;
 
         len = pa_read(fd, buf, 511, NULL);
         if (len < 0) {
@@ -386,31 +780,81 @@ static void rfcomm_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_i
          * AT+CKPD=200: Sent by HS when headset button is pressed.
          * RING: Sent by AG to HS to notify of an incoming call. It can safely be ignored because
          * it does not expect a reply. */
-        if (sscanf(buf, "AT+VGS=%d", &gain) == 1 || sscanf(buf, "\r\n+VGM=%d\r\n", &gain) == 1) {
-            t->speaker_gain = gain;
-            pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED), t);
+        if (sscanf(buf, "AT+VGS=%d", &gain) == 1 || sscanf(buf, "\r\n+VGM%*[=:]%d\r\n", &gain) == 1) {
+            if (!t->set_sink_volume) {
+                pa_log_debug("HS/HF peer supports speaker gain control");
+                t->set_sink_volume = set_sink_volume;
+            }
+
+            t->sink_volume = hsp_gain_to_volume(gain);
+            pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_SINK_VOLUME_CHANGED), t);
             do_reply = true;
 
-        } else if (sscanf(buf, "AT+VGM=%d", &gain) == 1 || sscanf(buf, "\r\n+VGS=%d\r\n", &gain) == 1) {
-            t->microphone_gain = gain;
-            pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED), t);
+        } else if (sscanf(buf, "AT+VGM=%d", &gain) == 1 || sscanf(buf, "\r\n+VGS%*[=:]%d\r\n", &gain) == 1) {
+            if (!t->set_source_volume) {
+                pa_log_debug("HS/HF peer supports microphone gain control");
+                t->set_source_volume = set_source_volume;
+            }
+
+            t->source_volume = hsp_gain_to_volume(gain);
+            pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_SOURCE_VOLUME_CHANGED), t);
             do_reply = true;
         } else if (sscanf(buf, "AT+CKPD=%d", &dummy) == 1) {
             do_reply = true;
+        } else if (sscanf(buf, "AT+XAPL=%04x-%04x-%04x,%d", &vendor, &product, &version, &features) == 4) {
+            if (features & 0x2)
+                /* claim, that we support battery status reports */
+                rfcomm_write_response(fd, "+XAPL=iPhone,6");
+            do_reply = true;
+        } else if (sscanf(buf, "AT+IPHONEACCEV=%d", &num) == 1) {
+            char *substr = buf, *keystr;
+            int key, val, i;
+
+            do_reply = true;
+
+            for (i = 0; i < num; ++i) {
+                keystr = strchr(substr, ',');
+                if (!keystr) {
+                    pa_log_warn("%s misses key for argument #%d", buf, i);
+                    do_reply = false;
+                    break;
+                }
+                keystr++;
+                substr = strchr(keystr, ',');
+                if (!substr) {
+                    pa_log_warn("%s misses value for argument #%d", buf, i);
+                    do_reply = false;
+                    break;
+                }
+                substr++;
+
+                key = atoi(keystr);
+                val = atoi(substr);
+
+                switch (key) {
+                    case 1:
+                        pa_log_notice("Battery Level: %d0%%", val + 1);
+                        pa_bluetooth_device_report_battery_level(t->device, (val + 1) * 10, "Apple accessory indication");
+                        break;
+                    case 2:
+                        pa_log_notice("Dock Status: %s", val ? "docked" : "undocked");
+                        break;
+                    default:
+                        pa_log_debug("Unexpected IPHONEACCEV key %#x", key);
+                        break;
+                }
+            }
+            if (!do_reply)
+                rfcomm_write_response(fd, "ERROR");
+        } else if (t->config) { /* t->config is only non-null for hfp profile */
+            do_reply = hfp_rfcomm_handle(fd, t, buf);
         } else {
+            rfcomm_write_response(fd, "ERROR");
             do_reply = false;
         }
 
-        if (do_reply) {
-            pa_log_debug("RFCOMM >> OK");
-
-            len = write(fd, "\r\nOK\r\n", 6);
-
-            /* we ignore any errors, it's not critical and real errors should
-             * be caught with the HANGUP and ERROR events handled above */
-            if (len < 0)
-                pa_log_error("RFCOMM write error: %s", pa_cstrerror(errno));
-        }
+        if (do_reply)
+            rfcomm_write_response(fd, "OK");
     }
 
     return;
@@ -436,58 +880,54 @@ static void transport_destroy(pa_bluetooth_transport *t) {
     pa_xfree(trd);
 }
 
-static void set_speaker_gain(pa_bluetooth_transport *t, uint16_t gain) {
+static pa_volume_t set_sink_volume(pa_bluetooth_transport *t, pa_volume_t volume) {
     struct transport_data *trd = t->userdata;
-    char buf[512];
-    ssize_t len, written;
+    uint16_t gain = volume_to_hsp_gain(volume);
+
+    /* Propagate rounding and bound checks */
+    volume = hsp_gain_to_volume(gain);
 
-    if (t->speaker_gain == gain)
-      return;
+    if (t->sink_volume == volume)
+        return volume;
 
-    t->speaker_gain = gain;
+    t->sink_volume = volume;
 
-    /* If we are in the AG role, we send a command to the head set to change
-     * the speaker gain. In the HS role, source and sink are swapped, so
-     * in this case we notify the AG that the microphone gain has changed */
-    if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT) {
-        len = sprintf(buf, "\r\n+VGS=%d\r\n", gain);
-        pa_log_debug("RFCOMM >> +VGS=%d", gain);
+    /* If we are in the AG role, we send an unsolicited result-code to the headset
+     * to change the speaker gain. In the HS role, source and sink are swapped,
+     * so in this case we notify the AG that the microphone gain has changed
+     * by sending a command. */
+    if (is_pulseaudio_audio_gateway(t->profile)) {
+        rfcomm_write_response(trd->rfcomm_fd, "+VGS=%d", gain);
     } else {
-        len = sprintf(buf, "\r\nAT+VGM=%d\r\n", gain);
-        pa_log_debug("RFCOMM >> AT+VGM=%d", gain);
+        rfcomm_write_command(trd->rfcomm_fd, "AT+VGM=%d", gain);
     }
 
-    written = write(trd->rfcomm_fd, buf, len);
-
-    if (written != len)
-        pa_log_error("RFCOMM write error: %s", pa_cstrerror(errno));
+    return volume;
 }
 
-static void set_microphone_gain(pa_bluetooth_transport *t, uint16_t gain) {
+static pa_volume_t set_source_volume(pa_bluetooth_transport *t, pa_volume_t volume) {
     struct transport_data *trd = t->userdata;
-    char buf[512];
-    ssize_t len, written;
+    uint16_t gain = volume_to_hsp_gain(volume);
+
+    /* Propagate rounding and bound checks */
+    volume = hsp_gain_to_volume(gain);
 
-    if (t->microphone_gain == gain)
-      return;
+    if (t->source_volume == volume)
+        return volume;
 
-    t->microphone_gain = gain;
+    t->source_volume = volume;
 
-    /* If we are in the AG role, we send a command to the head set to change
-     * the microphone gain. In the HS role, source and sink are swapped, so
-     * in this case we notify the AG that the speaker gain has changed */
-    if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT) {
-        len = sprintf(buf, "\r\n+VGM=%d\r\n", gain);
-        pa_log_debug("RFCOMM >> +VGM=%d", gain);
+    /* If we are in the AG role, we send an unsolicited result-code to the headset
+     * to change the microphone gain. In the HS role, source and sink are swapped,
+     * so in this case we notify the AG that the speaker gain has changed
+     * by sending a command. */
+    if (is_pulseaudio_audio_gateway(t->profile)) {
+        rfcomm_write_response(trd->rfcomm_fd, "+VGM=%d", gain);
     } else {
-        len = sprintf(buf, "\r\nAT+VGS=%d\r\n", gain);
-        pa_log_debug("RFCOMM >> AT+VGS=%d", gain);
+        rfcomm_write_command(trd->rfcomm_fd, "AT+VGS=%d", gain);
     }
 
-    written = write (trd->rfcomm_fd, buf, len);
-
-    if (written != len)
-        pa_log_error("RFCOMM write error: %s", pa_cstrerror(errno));
+    return volume;
 }
 
 static DBusMessage *profile_new_connection(DBusConnection *conn, DBusMessage *m, void *userdata) {
@@ -509,9 +949,11 @@ static DBusMessage *profile_new_connection(DBusConnection *conn, DBusMessage *m,
 
     handler = dbus_message_get_path(m);
     if (pa_streq(handler, HSP_AG_PROFILE)) {
-        p = PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT;
+        p = PA_BLUETOOTH_PROFILE_HSP_HS;
     } else if (pa_streq(handler, HSP_HS_PROFILE)) {
-        p = PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY;
+        p = PA_BLUETOOTH_PROFILE_HSP_AG;
+    } else if (pa_streq(handler, HFP_AG_PROFILE)) {
+        p = PA_BLUETOOTH_PROFILE_HFP_HF;
     } else {
         pa_log_error("Invalid handler");
         goto fail;
@@ -522,10 +964,20 @@ static DBusMessage *profile_new_connection(DBusConnection *conn, DBusMessage *m,
 
     d = pa_bluetooth_discovery_get_device_by_path(b->discovery, path);
     if (d == NULL) {
-        pa_log_error("Device doesnt exist for %s", path);
+        pa_log_error("Device doesn't exist for %s", path);
         goto fail;
     }
 
+    if (d->enable_hfp_hf) {
+        if (p == PA_BLUETOOTH_PROFILE_HSP_HS && pa_hashmap_get(d->uuids, PA_BLUETOOTH_UUID_HFP_HF)) {
+            /* If peer connecting to HSP Audio Gateway supports HFP HF profile
+             * reject this connection to force it to connect to HSP Audio Gateway instead.
+             */
+            pa_log_info("HFP HF enabled in native backend and is supported by peer, rejecting HSP HS peer connection");
+            goto fail;
+        }
+    }
+
     pa_assert_se(dbus_message_iter_next(&arg_i));
 
     pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_UNIX_FD);
@@ -537,14 +989,35 @@ static DBusMessage *profile_new_connection(DBusConnection *conn, DBusMessage *m,
     sender = dbus_message_get_sender(m);
 
     pathfd = pa_sprintf_malloc ("%s/fd%d", path, fd);
-    t = pa_bluetooth_transport_new(d, sender, pathfd, p, NULL, 0);
+    t = pa_bluetooth_transport_new(d, sender, pathfd, p, NULL,
+                                   p == PA_BLUETOOTH_PROFILE_HFP_HF ?
+                                   sizeof(struct hfp_config) : 0);
     pa_xfree(pathfd);
 
     t->acquire = sco_acquire_cb;
     t->release = sco_release_cb;
     t->destroy = transport_destroy;
-    t->set_speaker_gain = set_speaker_gain;
-    t->set_microphone_gain = set_microphone_gain;
+
+    /* If PA is the HF/HS we are in control of volume attenuation and
+     * can always send volume commands (notifications) to keep the peer
+     * updated on actual volume value.
+     *
+     * If the peer is the HF/HS it is responsible for attenuation of both
+     * speaker and microphone gain.
+     * On HFP speaker/microphone gain support is reported by bit 4 in the
+     * `AT+BRSF=` command. Since it isn't explicitly documented whether this
+     * applies to speaker or microphone gain but the peer is required to send
+     * an initial value with `AT+VG[MS]=` either callback is hooked
+     * independently as soon as this command is received.
+     * On HSP this is not specified and is assumed to be dynamic for both
+     * speaker and microphone.
+     */
+    if (is_peer_audio_gateway(p)) {
+        t->set_sink_volume = set_sink_volume;
+        t->set_source_volume = set_source_volume;
+    }
+
+    pa_bluetooth_transport_reconfigure(t, pa_bluetooth_get_hf_codec("CVSD"), sco_transport_write, NULL);
 
     trd = pa_xnew0(struct transport_data, 1);
     trd->rfcomm_fd = fd;
@@ -555,16 +1028,15 @@ static DBusMessage *profile_new_connection(DBusConnection *conn, DBusMessage *m,
 
     sco_listen(t);
 
-    pa_bluetooth_transport_put(t);
-
-    pa_log_debug("Transport %s available for profile %s", t->path, pa_bluetooth_profile_to_string(t->profile));
+    if (p != PA_BLUETOOTH_PROFILE_HFP_HF)
+        transport_put(t);
 
     pa_assert_se(r = dbus_message_new_method_return(m));
 
     return r;
 
 fail:
-    pa_assert_se(r = dbus_message_new_error(m, "org.bluez.Error.InvalidArguments", "Unable to handle new connection"));
+    pa_assert_se(r = dbus_message_new_error(m, BLUEZ_ERROR_INVALID_ARGUMENTS, "Unable to handle new connection"));
     return r;
 }
 
@@ -589,10 +1061,11 @@ static DBusHandlerResult profile_handler(DBusConnection *c, DBusMessage *m, void
 
     pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
 
-    if (!pa_streq(path, HSP_AG_PROFILE) && !pa_streq(path, HSP_HS_PROFILE))
+    if (!pa_streq(path, HSP_AG_PROFILE) && !pa_streq(path, HSP_HS_PROFILE)
+        && !pa_streq(path, HFP_AG_PROFILE))
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
-    if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
+    if (dbus_message_is_method_call(m, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
         const char *xml = PROFILE_INTROSPECT_XML;
 
         pa_assert_se(r = dbus_message_new_method_return(m));
@@ -616,6 +1089,26 @@ static DBusHandlerResult profile_handler(DBusConnection *c, DBusMessage *m, void
     return DBUS_HANDLER_RESULT_HANDLED;
 }
 
+static pa_hook_result_t adapter_uuids_changed_cb(pa_bluetooth_discovery *y, const pa_bluetooth_adapter *a, pa_bluetooth_backend *b) {
+    pa_assert(y);
+    pa_assert(a);
+    pa_assert(b);
+
+    if (profile_status_get(y, PA_BLUETOOTH_PROFILE_HSP_HS) == PA_BLUETOOTH_PROFILE_STATUS_ACTIVE &&
+        !pa_hashmap_get(a->uuids, PA_BLUETOOTH_UUID_HSP_AG))
+        register_profile(b, HSP_AG_PROFILE, PA_BLUETOOTH_UUID_HSP_AG, PA_BLUETOOTH_PROFILE_HSP_HS);
+
+    if (profile_status_get(y, PA_BLUETOOTH_PROFILE_HSP_AG) == PA_BLUETOOTH_PROFILE_STATUS_ACTIVE &&
+        !pa_hashmap_get(a->uuids, PA_BLUETOOTH_UUID_HSP_HS))
+        register_profile(b, HSP_HS_PROFILE, PA_BLUETOOTH_UUID_HSP_HS, PA_BLUETOOTH_PROFILE_HSP_AG);
+
+    if (profile_status_get(y, PA_BLUETOOTH_PROFILE_HFP_HF) == PA_BLUETOOTH_PROFILE_STATUS_ACTIVE &&
+        !pa_hashmap_get(a->uuids, PA_BLUETOOTH_UUID_HFP_AG))
+        register_profile(b, HFP_AG_PROFILE, PA_BLUETOOTH_UUID_HFP_AG, PA_BLUETOOTH_PROFILE_HFP_HF);
+
+    return PA_HOOK_OK;
+}
+
 static void profile_init(pa_bluetooth_backend *b, pa_bluetooth_profile_t profile) {
     static const DBusObjectPathVTable vtable_profile = {
         .message_function = profile_handler,
@@ -626,53 +1119,73 @@ static void profile_init(pa_bluetooth_backend *b, pa_bluetooth_profile_t profile
     pa_assert(b);
 
     switch (profile) {
-        case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
+        case PA_BLUETOOTH_PROFILE_HSP_HS:
             object_name = HSP_AG_PROFILE;
             uuid = PA_BLUETOOTH_UUID_HSP_AG;
             break;
-        case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
+        case PA_BLUETOOTH_PROFILE_HSP_AG:
             object_name = HSP_HS_PROFILE;
             uuid = PA_BLUETOOTH_UUID_HSP_HS;
             break;
+        case PA_BLUETOOTH_PROFILE_HFP_HF:
+            object_name = HFP_AG_PROFILE;
+            uuid = PA_BLUETOOTH_UUID_HFP_AG;
+            break;
         default:
             pa_assert_not_reached();
             break;
     }
 
     pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(b->connection), object_name, &vtable_profile, b));
-    register_profile(b, object_name, uuid);
+
+    profile_status_set(b->discovery, profile, PA_BLUETOOTH_PROFILE_STATUS_ACTIVE);
+    register_profile(b, object_name, uuid, profile);
 }
 
 static void profile_done(pa_bluetooth_backend *b, pa_bluetooth_profile_t profile) {
     pa_assert(b);
 
+    profile_status_set(b->discovery, profile, PA_BLUETOOTH_PROFILE_STATUS_INACTIVE);
+
     switch (profile) {
-        case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
+        case PA_BLUETOOTH_PROFILE_HSP_HS:
             dbus_connection_unregister_object_path(pa_dbus_connection_get(b->connection), HSP_AG_PROFILE);
             break;
-        case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
+        case PA_BLUETOOTH_PROFILE_HSP_AG:
             dbus_connection_unregister_object_path(pa_dbus_connection_get(b->connection), HSP_HS_PROFILE);
             break;
+        case PA_BLUETOOTH_PROFILE_HFP_HF:
+            dbus_connection_unregister_object_path(pa_dbus_connection_get(b->connection), HFP_AG_PROFILE);
+            break;
         default:
             pa_assert_not_reached();
             break;
     }
 }
 
-void pa_bluetooth_native_backend_enable_hs_role(pa_bluetooth_backend *native_backend, bool enable_hs_role) {
+static void native_backend_apply_profile_registration_change(pa_bluetooth_backend *native_backend, bool enable_shared_profiles) {
+    if (enable_shared_profiles) {
+        profile_init(native_backend, PA_BLUETOOTH_PROFILE_HSP_AG);
+        if (native_backend->enable_hfp_hf)
+            profile_init(native_backend, PA_BLUETOOTH_PROFILE_HFP_HF);
+    } else {
+        profile_done(native_backend, PA_BLUETOOTH_PROFILE_HSP_AG);
+        if (native_backend->enable_hfp_hf)
+            profile_done(native_backend, PA_BLUETOOTH_PROFILE_HFP_HF);
+    }
+}
 
-   if (enable_hs_role == native_backend->enable_hs_role)
+void pa_bluetooth_native_backend_enable_shared_profiles(pa_bluetooth_backend *native_backend, bool enable) {
+
+   if (enable == native_backend->enable_shared_profiles)
        return;
 
-   if (enable_hs_role)
-       profile_init(native_backend, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-   else
-       profile_done(native_backend, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
+   native_backend_apply_profile_registration_change(native_backend, enable);
 
-   native_backend->enable_hs_role = enable_hs_role;
+   native_backend->enable_shared_profiles = enable;
 }
 
-pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_hs_role) {
+pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_shared_profiles) {
     pa_bluetooth_backend *backend;
     DBusError err;
 
@@ -690,11 +1203,22 @@ pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_d
     }
 
     backend->discovery = y;
-    backend->enable_hs_role = enable_hs_role;
+    backend->enable_shared_profiles = enable_shared_profiles;
+    backend->enable_hfp_hf = pa_bluetooth_discovery_get_enable_native_hfp_hf(y);
+    backend->enable_hsp_hs = pa_bluetooth_discovery_get_enable_native_hsp_hs(y);
+
+    backend->adapter_uuids_changed_slot =
+        pa_hook_connect(pa_bluetooth_discovery_hook(y, PA_BLUETOOTH_HOOK_ADAPTER_UUIDS_CHANGED), PA_HOOK_NORMAL,
+                        (pa_hook_cb_t) adapter_uuids_changed_cb, backend);
 
-    if (enable_hs_role)
-       profile_init(backend, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-    profile_init(backend, PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT);
+    if (!backend->enable_hsp_hs && !backend->enable_hfp_hf)
+        pa_log_warn("Both HSP HS and HFP HF bluetooth profiles disabled in native backend. Native backend will not register for headset connections.");
+
+    if (backend->enable_hsp_hs)
+        profile_init(backend, PA_BLUETOOTH_PROFILE_HSP_HS);
+
+    if (backend->enable_shared_profiles)
+        native_backend_apply_profile_registration_change(backend, true);
 
     return backend;
 }
@@ -704,9 +1228,14 @@ void pa_bluetooth_native_backend_free(pa_bluetooth_backend *backend) {
 
     pa_dbus_free_pending_list(&backend->pending);
 
-    if (backend->enable_hs_role)
-       profile_done(backend, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-    profile_done(backend, PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT);
+    if (backend->adapter_uuids_changed_slot)
+        pa_hook_slot_free(backend->adapter_uuids_changed_slot);
+
+    if (backend->enable_shared_profiles)
+        native_backend_apply_profile_registration_change(backend, false);
+
+    if (backend->enable_hsp_hs)
+        profile_done(backend, PA_BLUETOOTH_PROFILE_HSP_HS);
 
     pa_dbus_connection_unref(backend->connection);
 
diff --git a/src/modules/bluetooth/backend-ofono.c b/src/modules/bluetooth/backend-ofono.c
index 0e5bbe8..36fe787 100755
--- a/src/modules/bluetooth/backend-ofono.c
+++ b/src/modules/bluetooth/backend-ofono.c
@@ -43,12 +43,12 @@
 #define HF_AUDIO_AGENT_XML                                          \
     DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                       \
     "<node>"                                                        \
-    "  <interface name=\"org.freedesktop.DBus.Introspectable\">"    \
+    "  <interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">"      \
     "    <method name=\"Introspect\">"                              \
     "      <arg direction=\"out\" type=\"s\" />"                    \
     "    </method>"                                                 \
     "  </interface>"                                                \
-    "  <interface name=\"org.ofono.HandsfreeAudioAgent\">"          \
+    "  <interface name=\"" HF_AUDIO_AGENT_INTERFACE "\">"           \
     "    <method name=\"Release\">"                                 \
     "    </method>"                                                 \
     "    <method name=\"NewConnection\">"                           \
@@ -83,6 +83,61 @@ struct pa_bluetooth_backend {
     PA_LLIST_HEAD(pa_dbus_pending, pending);
 };
 
+static ssize_t sco_transport_write(pa_bluetooth_transport *t, int fd, const void* buffer, size_t size, size_t write_mtu) {
+    ssize_t l = 0;
+    size_t written = 0;
+    size_t write_size;
+
+    pa_assert(t);
+
+    /* since SCO setup is symmetric, fix write MTU to be size of last read packet */
+    if (t->last_read_size)
+        write_mtu = PA_MIN(t->last_read_size, write_mtu);
+
+    /* if encoder buffer has less data than required to make complete packet */
+    if (size < write_mtu)
+        return 0;
+
+    /* write out MTU sized chunks only */
+    while (written < size) {
+        write_size = PA_MIN(size - written, write_mtu);
+        if (write_size < write_mtu)
+            break;
+        l = pa_write(fd, buffer + written, write_size, &t->stream_write_type);
+        if (l < 0)
+            break;
+        written += l;
+    }
+
+    if (l < 0) {
+        if (errno == EAGAIN) {
+            /* Hmm, apparently the socket was not writable, give up for now */
+            pa_log_debug("Got EAGAIN on write() after POLLOUT, probably there is a temporary connection loss.");
+            /* Drain write buffer */
+            written = size;
+        } else if (errno == EINVAL && t->last_read_size == 0) {
+            /* Likely write_link_mtu is still wrong, retry after next successful read */
+            pa_log_debug("got write EINVAL, next successful read should fix MTU");
+            /* Drain write buffer */
+            written = size;
+        } else {
+            pa_log_error("Failed to write data to socket: %s", pa_cstrerror(errno));
+            /* Report error from write call */
+            return -1;
+        }
+    }
+
+    /* if too much data left discard it all */
+    if (size - written >= write_mtu) {
+        pa_log_warn("Wrote memory block to socket only partially! %lu written, discarding pending write size %lu larger than write_mtu %lu",
+                    written, size, write_mtu);
+        /* Drain write buffer */
+        written = size;
+    }
+
+    return written;
+}
+
 static pa_dbus_pending* hf_dbus_send_and_add_to_pending(pa_bluetooth_backend *backend, DBusMessage *m,
                                                     DBusPendingCallNotifyFunction func, void *call_data) {
     pa_dbus_pending *p;
@@ -165,14 +220,21 @@ static int card_acquire(struct hf_audio_card *card) {
                                       DBUS_TYPE_BYTE, &codec,
                                       DBUS_TYPE_INVALID) == true)) {
         dbus_message_unref(r);
-        if (codec != HFP_AUDIO_CODEC_CVSD) {
+
+        if (codec == HFP_AUDIO_CODEC_CVSD) {
+            pa_bluetooth_transport_reconfigure(card->transport, pa_bluetooth_get_hf_codec("CVSD"), sco_transport_write, NULL);
+        } else if (codec == HFP_AUDIO_CODEC_MSBC) {
+            /* oFono is expected to set up socket BT_VOICE_TRANSPARENT option */
+            pa_bluetooth_transport_reconfigure(card->transport, pa_bluetooth_get_hf_codec("mSBC"), sco_transport_write, NULL);
+        } else {
+            pa_assert_fp(codec != HFP_AUDIO_CODEC_CVSD && codec != HFP_AUDIO_CODEC_MSBC);
             pa_log_error("Invalid codec: %u", codec);
             /* shutdown to make sure connection is dropped immediately */
             shutdown(fd, SHUT_RDWR);
             close(fd);
             return -1;
         }
-        card->transport->codec = codec;
+
         card->fd = fd;
         return 0;
     }
@@ -188,6 +250,9 @@ static pa_hook_result_t device_unlink_cb(pa_bluetooth_discovery *y, const pa_blu
     pa_assert(d);
     pa_assert(card);
 
+    if (d != card->transport->device)
+        return PA_HOOK_OK;
+
     hf_audio_agent_card_removed(card->backend, card->path);
 
     return PA_HOOK_OK;
@@ -267,11 +332,16 @@ static int hf_audio_agent_transport_acquire(pa_bluetooth_transport *t, bool opti
      * the Bluetooth adapter and (for adapters in the USB bus) the MxPS
      * value from the Isoc USB endpoint in use by btusb and should be
      * made available to userspace by the Bluetooth kernel subsystem.
-     * Meanwhile the empiric value 48 will be used. */
+     *
+     * Set initial MTU to max known payload length of HCI packet
+     * in USB Alternate Setting 5 (144 bytes)
+     * See also pa_bluetooth_transport::last_read_size handling
+     * and comment about MTU size in bt_prepare_encoder_buffer()
+     */
     if (imtu)
-        *imtu = 48;
+        *imtu = 144;
     if (omtu)
-        *omtu = 48;
+        *omtu = 144;
 
     err = socket_accept(card->fd);
     if (err < 0) {
@@ -303,7 +373,7 @@ static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char
     const char *key, *value;
     struct hf_audio_card *card;
     pa_bluetooth_device *d;
-    pa_bluetooth_profile_t p = PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY;
+    pa_bluetooth_profile_t p = PA_BLUETOOTH_PROFILE_HFP_AG;
 
     pa_assert(backend);
     pa_assert(path);
@@ -337,7 +407,7 @@ static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char
             card->local_address = pa_xstrdup(value);
         } else if (pa_streq(key, "Type")) {
             if (pa_streq(value, "gateway"))
-                p = PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT;
+                p = PA_BLUETOOTH_PROFILE_HFP_HF;
         }
 
         pa_log_debug("%s: %s", key, value);
@@ -347,7 +417,7 @@ static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char
 
     d = pa_bluetooth_discovery_get_device_by_address(backend->discovery, card->remote_address, card->local_address);
     if (!d) {
-        pa_log_error("Device doesnt exist for %s", path);
+        pa_log_error("Device doesn't exist for %s", path);
         goto fail;
     }
 
@@ -355,6 +425,7 @@ static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char
     card->transport->acquire = hf_audio_agent_transport_acquire;
     card->transport->release = hf_audio_agent_transport_release;
     card->transport->userdata = card;
+    pa_bluetooth_transport_reconfigure(card->transport, pa_bluetooth_get_hf_codec("CVSD"), sco_transport_write, NULL);
 
     pa_bluetooth_transport_put(card->transport);
     pa_hashmap_put(backend->cards, card->path, card);
@@ -482,6 +553,8 @@ static void hf_audio_agent_register(pa_bluetooth_backend *hf) {
     pa_assert_se(m = dbus_message_new_method_call(OFONO_SERVICE, "/", HF_AUDIO_MANAGER_INTERFACE, "Register"));
 
     codecs[ncodecs++] = HFP_AUDIO_CODEC_CVSD;
+    if (pa_bluetooth_discovery_get_enable_msbc(hf->discovery))
+        codecs[ncodecs++] = HFP_AUDIO_CODEC_MSBC;
 
     pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &pcodecs, ncodecs,
                                           DBUS_TYPE_INVALID));
@@ -515,12 +588,12 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *da
     pa_assert(backend);
 
     sender = dbus_message_get_sender(m);
-    if (!pa_safe_streq(backend->ofono_bus_id, sender) && !pa_streq("org.freedesktop.DBus", sender))
+    if (!pa_safe_streq(backend->ofono_bus_id, sender) && !pa_streq(DBUS_SERVICE_DBUS, sender))
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
     dbus_error_init(&err);
 
-    if (dbus_message_is_signal(m, "org.freedesktop.DBus", "NameOwnerChanged")) {
+    if (dbus_message_is_signal(m, DBUS_INTERFACE_DBUS, "NameOwnerChanged")) {
         const char *name, *old_owner, *new_owner;
 
         if (!dbus_message_get_args(m, &err,
@@ -528,7 +601,7 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *da
                                    DBUS_TYPE_STRING, &old_owner,
                                    DBUS_TYPE_STRING, &new_owner,
                                    DBUS_TYPE_INVALID)) {
-            pa_log_error("Failed to parse org.freedesktop.DBus.NameOwnerChanged: %s", err.message);
+            pa_log_error("Failed to parse " DBUS_INTERFACE_DBUS ".NameOwnerChanged: %s", err.message);
             goto fail;
         }
 
@@ -627,9 +700,7 @@ static DBusMessage *hf_audio_agent_new_connection(DBusConnection *c, DBusMessage
 
     card = pa_hashmap_get(backend->cards, path);
 
-    card->connecting = false;
-
-    if (!card || codec != HFP_AUDIO_CODEC_CVSD || card->fd >= 0) {
+    if (!card || (codec != HFP_AUDIO_CODEC_CVSD && codec != HFP_AUDIO_CODEC_MSBC) || card->fd >= 0) {
         pa_log_warn("New audio connection invalid arguments (path=%s fd=%d, codec=%d)", path, fd, codec);
         pa_assert_se(r = dbus_message_new_error(m, "org.ofono.Error.InvalidArguments", "Invalid arguments in method call"));
         shutdown(fd, SHUT_RDWR);
@@ -639,8 +710,14 @@ static DBusMessage *hf_audio_agent_new_connection(DBusConnection *c, DBusMessage
 
     pa_log_debug("New audio connection on card %s (fd=%d, codec=%d)", path, fd, codec);
 
+    card->connecting = false;
     card->fd = fd;
-    card->transport->codec = codec;
+    if (codec == HFP_AUDIO_CODEC_CVSD) {
+        pa_bluetooth_transport_reconfigure(card->transport, pa_bluetooth_get_hf_codec("CVSD"), sco_transport_write, NULL);
+    } else if (codec == HFP_AUDIO_CODEC_MSBC) {
+        /* oFono is expected to set up socket BT_VOICE_TRANSPARENT option */
+        pa_bluetooth_transport_reconfigure(card->transport, pa_bluetooth_get_hf_codec("mSBC"), sco_transport_write, NULL);
+    }
 
     pa_bluetooth_transport_set_state(card->transport, PA_BLUETOOTH_TRANSPORT_STATE_PLAYING);
 
@@ -665,7 +742,7 @@ static DBusHandlerResult hf_audio_agent_handler(DBusConnection *c, DBusMessage *
 
     pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
 
-    if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
+    if (dbus_message_is_method_call(m, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
         const char *xml = HF_AUDIO_AGENT_XML;
 
         pa_assert_se(r = dbus_message_new_method_return(m));
@@ -719,7 +796,7 @@ pa_bluetooth_backend *pa_bluetooth_ofono_backend_new(pa_core *c, pa_bluetooth_di
     }
 
     if (pa_dbus_add_matches(pa_dbus_connection_get(backend->connection), &err,
-            "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',"
+            "type='signal',sender='" DBUS_SERVICE_DBUS "',interface='" DBUS_INTERFACE_DBUS "',member='NameOwnerChanged',"
             "arg0='" OFONO_SERVICE "'",
             "type='signal',sender='" OFONO_SERVICE "',interface='" HF_AUDIO_MANAGER_INTERFACE "',member='CardAdded'",
             "type='signal',sender='" OFONO_SERVICE "',interface='" HF_AUDIO_MANAGER_INTERFACE "',member='CardRemoved'",
@@ -749,7 +826,7 @@ void pa_bluetooth_ofono_backend_free(pa_bluetooth_backend *backend) {
     dbus_connection_unregister_object_path(pa_dbus_connection_get(backend->connection), HF_AUDIO_AGENT_PATH);
 
     pa_dbus_remove_matches(pa_dbus_connection_get(backend->connection),
-            "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',"
+            "type='signal',sender='" DBUS_SERVICE_DBUS "',interface='" DBUS_INTERFACE_DBUS "',member='NameOwnerChanged',"
             "arg0='" OFONO_SERVICE "'",
             "type='signal',sender='" OFONO_SERVICE "',interface='" HF_AUDIO_MANAGER_INTERFACE "',member='CardAdded'",
             "type='signal',sender='" OFONO_SERVICE "',interface='" HF_AUDIO_MANAGER_INTERFACE "',member='CardRemoved'",
diff --git a/src/modules/bluetooth/bluez5-util.c b/src/modules/bluetooth/bluez5-util.c
index d95c9c1..f9b9e6e 100755
--- a/src/modules/bluetooth/bluez5-util.c
+++ b/src/modules/bluetooth/bluez5-util.c
@@ -22,11 +22,14 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+
 #include <pulse/rtclock.h>
 #include <pulse/timeval.h>
 #include <pulse/xmalloc.h>
 
 #include <pulsecore/core.h>
+#include <pulsecore/core-error.h>
 #include <pulsecore/core-util.h>
 #include <pulsecore/dbus-shared.h>
 #include <pulsecore/log.h>
@@ -34,6 +37,7 @@
 #include <pulsecore/refcnt.h>
 #include <pulsecore/shared.h>
 
+#include "a2dp-codec-api.h"
 #include "a2dp-codec-util.h"
 #include "a2dp-codecs.h"
 
@@ -41,17 +45,40 @@
 
 #define WAIT_FOR_PROFILES_TIMEOUT_USEC (3 * PA_USEC_PER_SEC)
 
-#define BLUEZ_SERVICE "org.bluez"
-#define BLUEZ_ADAPTER_INTERFACE BLUEZ_SERVICE ".Adapter1"
-#define BLUEZ_DEVICE_INTERFACE BLUEZ_SERVICE ".Device1"
-#define BLUEZ_MEDIA_INTERFACE BLUEZ_SERVICE ".Media1"
-#define BLUEZ_MEDIA_ENDPOINT_INTERFACE BLUEZ_SERVICE ".MediaEndpoint1"
-#define BLUEZ_MEDIA_TRANSPORT_INTERFACE BLUEZ_SERVICE ".MediaTransport1"
-
-#define BLUEZ_ERROR_NOT_SUPPORTED "org.bluez.Error.NotSupported"
-
-#define A2DP_SOURCE_ENDPOINT "/MediaEndpoint/A2DPSource"
-#define A2DP_SINK_ENDPOINT "/MediaEndpoint/A2DPSink"
+#define DBUS_INTERFACE_OBJECT_MANAGER DBUS_INTERFACE_DBUS ".ObjectManager"
+
+#define A2DP_OBJECT_MANAGER_PATH "/MediaEndpoint"
+#define A2DP_SOURCE_ENDPOINT A2DP_OBJECT_MANAGER_PATH "/A2DPSource"
+#define A2DP_SINK_ENDPOINT A2DP_OBJECT_MANAGER_PATH "/A2DPSink"
+#define PULSEAUDIO_BASE_PATH "/org/pulseaudio"
+
+#define BLUEZ_PLAYER_INTERFACE "org.mpris.MediaPlayer2.Player"
+#define MEDIA_PALYER "/MediaPlayer/Player1"
+
+#define OBJECT_MANAGER_INTROSPECT_XML                                          \
+    DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                                  \
+    "<node>\n"                                                                 \
+    " <interface name=\"" DBUS_INTERFACE_OBJECT_MANAGER "\">\n"                \
+    "  <method name=\"GetManagedObjects\">\n"                                  \
+    "   <arg name=\"objects\" direction=\"out\" type=\"a{oa{sa{sv}}}\"/>\n"    \
+    "  </method>\n"                                                            \
+    "  <signal name=\"InterfacesAdded\">\n"                                    \
+    "   <arg name=\"object\" type=\"o\"/>\n"                                   \
+    "   <arg name=\"interfaces\" type=\"a{sa{sv}}\"/>\n"                       \
+    "  </signal>\n"                                                            \
+    "  <signal name=\"InterfacesRemoved\">\n"                                  \
+    "   <arg name=\"object\" type=\"o\"/>\n"                                   \
+    "   <arg name=\"interfaces\" type=\"as\"/>\n"                              \
+    "  </signal>\n"                                                            \
+    " </interface>\n"                                                          \
+    " <interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">\n"                \
+    "  <method name=\"Introspect\">\n"                                         \
+    "   <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"                   \
+    "  </method>\n"                                                            \
+    " </interface>\n"                                                          \
+    " <node name=\"A2DPSink\"/>\n"                                             \
+    " <node name=\"A2DPSource\"/>\n"                                           \
+    "</node>\n"
 
 #define ENDPOINT_INTROSPECT_XML                                         \
     DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                           \
@@ -71,13 +98,39 @@
     "  <method name=\"Release\">"                                       \
     "  </method>"                                                       \
     " </interface>"                                                     \
-    " <interface name=\"org.freedesktop.DBus.Introspectable\">"         \
+    " <interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">"           \
     "  <method name=\"Introspect\">"                                    \
     "   <arg name=\"data\" type=\"s\" direction=\"out\"/>"              \
     "  </method>"                                                       \
     " </interface>"                                                     \
     "</node>"
 
+static pa_volume_t a2dp_gain_to_volume(uint16_t gain) {
+    pa_volume_t volume = (pa_volume_t) ((
+        gain * PA_VOLUME_NORM
+        /* Round to closest by adding half the denominator */
+        + A2DP_MAX_GAIN / 2
+    ) / A2DP_MAX_GAIN);
+
+    if (volume > PA_VOLUME_NORM)
+        volume = PA_VOLUME_NORM;
+
+    return volume;
+}
+
+static uint16_t volume_to_a2dp_gain(pa_volume_t volume) {
+    uint16_t gain = (uint16_t) ((
+        volume * A2DP_MAX_GAIN
+        /* Round to closest by adding half the denominator */
+        + PA_VOLUME_NORM / 2
+    ) / PA_VOLUME_NORM);
+
+    if (gain > A2DP_MAX_GAIN)
+        gain = A2DP_MAX_GAIN;
+
+    return gain;
+}
+
 struct pa_bluetooth_discovery {
     PA_REFCNT_DECLARE;
 
@@ -90,10 +143,14 @@ struct pa_bluetooth_discovery {
     pa_hashmap *adapters;
     pa_hashmap *devices;
     pa_hashmap *transports;
+    pa_bluetooth_profile_status_t profiles_status[PA_BLUETOOTH_PROFILE_COUNT];
 
     int headset_backend;
     pa_bluetooth_backend *ofono_backend, *native_backend;
     PA_LLIST_HEAD(pa_dbus_pending, pending);
+    bool enable_native_hsp_hs;
+    bool enable_native_hfp_hf;
+    bool enable_msbc;
 };
 
 static pa_dbus_pending* send_and_add_to_pending(pa_bluetooth_discovery *y, DBusMessage *m,
@@ -138,6 +195,14 @@ static const char *check_variant_property(DBusMessageIter *i) {
     return key;
 }
 
+pa_bluetooth_profile_status_t profile_status_get(pa_bluetooth_discovery *y, pa_bluetooth_profile_t profile) {
+    return y->profiles_status[profile];
+}
+
+void profile_status_set(pa_bluetooth_discovery *y, pa_bluetooth_profile_t profile, pa_bluetooth_profile_status_t status) {
+    y->profiles_status[profile] = status;
+}
+
 pa_bluetooth_transport *pa_bluetooth_transport_new(pa_bluetooth_device *d, const char *owner, const char *path,
                                                    pa_bluetooth_profile_t p, const uint8_t *config, size_t size) {
     pa_bluetooth_transport *t;
@@ -148,15 +213,37 @@ pa_bluetooth_transport *pa_bluetooth_transport_new(pa_bluetooth_device *d, const
     t->path = pa_xstrdup(path);
     t->profile = p;
     t->config_size = size;
+    /* Always force initial volume to be set/propagated correctly */
+    t->sink_volume = PA_VOLUME_INVALID;
+    t->source_volume = PA_VOLUME_INVALID;
 
     if (size > 0) {
         t->config = pa_xnew(uint8_t, size);
-        memcpy(t->config, config, size);
+        if (config)
+            memcpy(t->config, config, size);
+        else
+            memset(t->config, 0, size);
     }
 
     return t;
 }
 
+void pa_bluetooth_transport_reconfigure(pa_bluetooth_transport *t, const pa_bt_codec *bt_codec,
+                                        pa_bluetooth_transport_write_cb write_cb, pa_bluetooth_transport_setsockopt_cb setsockopt_cb) {
+    pa_assert(t);
+
+    t->bt_codec = bt_codec;
+
+    t->write = write_cb;
+    t->setsockopt = setsockopt_cb;
+
+    /* reset stream write type hint */
+    t->stream_write_type = 0;
+
+    /* reset SCO MTU adjustment hint */
+    t->last_read_size = 0;
+}
+
 static const char *transport_state_to_string(pa_bluetooth_transport_state_t state) {
     switch(state) {
         case PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED:
@@ -170,24 +257,69 @@ static const char *transport_state_to_string(pa_bluetooth_transport_state_t stat
     return "invalid";
 }
 
-static bool device_supports_profile(pa_bluetooth_device *device, pa_bluetooth_profile_t profile) {
+bool pa_bluetooth_device_supports_profile(const pa_bluetooth_device *device, pa_bluetooth_profile_t profile) {
+    bool show_hfp, show_hsp, r;
+
+    pa_assert(device);
+
+    /* While discovery is being released adapters will be removed from devices,
+     * and there are no profiles to support without adapter.
+     */
+    if (!device->adapter) {
+        pa_log_debug("Device %s (%s) has no adapter to support profile %s",
+                device->alias, device->address, pa_bluetooth_profile_to_string(profile));
+        return false;
+    }
+
+    if (device->enable_hfp_hf) {
+        show_hfp = pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_HF);
+        show_hsp = !show_hfp;
+    } else {
+        show_hfp = false;
+        show_hsp = true;
+    }
+
     switch (profile) {
         case PA_BLUETOOTH_PROFILE_A2DP_SINK:
-            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SINK);
+            r = !!(pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SINK) &&
+                      pa_hashmap_get(device->adapter->uuids, PA_BLUETOOTH_UUID_A2DP_SOURCE));
+            break;
         case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SOURCE);
-        case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
-            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_HS)
-                || !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_HS_ALT)
-                || !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_HF);
-        case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
-            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_AG)
-                || !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_AG);
+            r = !!(pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SOURCE) &&
+                      pa_hashmap_get(device->adapter->uuids, PA_BLUETOOTH_UUID_A2DP_SINK));
+            break;
+        case PA_BLUETOOTH_PROFILE_HSP_HS:
+            r = show_hsp
+                && ( !!(pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_HS) &&
+                      pa_hashmap_get(device->adapter->uuids, PA_BLUETOOTH_UUID_HSP_AG)) ||
+                   !!(pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_HS_ALT) &&
+                      pa_hashmap_get(device->adapter->uuids, PA_BLUETOOTH_UUID_HSP_AG)) );
+            break;
+        case PA_BLUETOOTH_PROFILE_HSP_AG:
+            r = !!(pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_AG) &&
+                      pa_hashmap_get(device->adapter->uuids, PA_BLUETOOTH_UUID_HSP_HS)) ||
+                   !!(pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_AG) &&
+                      pa_hashmap_get(device->adapter->uuids, PA_BLUETOOTH_UUID_HSP_HS_ALT));
+            break;
+        case PA_BLUETOOTH_PROFILE_HFP_HF:
+            r = show_hfp
+                && !!(pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_HF) &&
+                      pa_hashmap_get(device->adapter->uuids, PA_BLUETOOTH_UUID_HFP_AG));
+            break;
+        case PA_BLUETOOTH_PROFILE_HFP_AG:
+            r = !!(pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_AG) &&
+                      pa_hashmap_get(device->adapter->uuids, PA_BLUETOOTH_UUID_HFP_HF));
+            break;
         case PA_BLUETOOTH_PROFILE_OFF:
+        default:
             pa_assert_not_reached();
+            break;
     }
 
-    pa_assert_not_reached();
+    pa_log_debug("Checking if device %s (%s) supports profile %s: %s",
+                 device->alias, device->address, pa_bluetooth_profile_to_string(profile), r ? "true" : "false");
+
+    return r;
 }
 
 static bool device_is_profile_connected(pa_bluetooth_device *device, pa_bluetooth_profile_t profile) {
@@ -202,7 +334,7 @@ static unsigned device_count_disconnected_profiles(pa_bluetooth_device *device)
     unsigned count = 0;
 
     for (profile = 0; profile < PA_BLUETOOTH_PROFILE_COUNT; profile++) {
-        if (!device_supports_profile(device, profile))
+        if (!pa_bluetooth_device_supports_profile(device, profile))
             continue;
 
         if (!device_is_profile_connected(device, profile))
@@ -235,7 +367,7 @@ static void wait_for_profiles_cb(pa_mainloop_api *api, pa_time_event* event, con
         if (device_is_profile_connected(device, profile))
             continue;
 
-        if (!device_supports_profile(device, profile))
+        if (!pa_bluetooth_device_supports_profile(device, profile))
             continue;
 
         if (first)
@@ -260,6 +392,123 @@ static void device_start_waiting_for_profiles(pa_bluetooth_device *device) {
                                                          wait_for_profiles_cb, device);
 }
 
+struct switch_codec_data {
+    char *pa_endpoint;
+    char *device_path;
+    pa_bluetooth_profile_t profile;
+    void (*cb)(bool, pa_bluetooth_profile_t profile, void *);
+    void *userdata;
+};
+
+static void pa_bluetooth_device_switch_codec_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+    pa_bluetooth_device *device;
+    struct switch_codec_data *data;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(data = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+
+    device = pa_hashmap_get(y->devices, data->device_path);
+    if (!device) {
+        pa_log_error("Changing codec for device %s with profile %s failed. Device is not connected anymore",
+                data->device_path, pa_bluetooth_profile_to_string(data->profile));
+        data->cb(false, data->profile, data->userdata);
+    } else if (dbus_message_get_type(r) != DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_info("Changing codec for device %s with profile %s succeeded",
+                data->device_path, pa_bluetooth_profile_to_string(data->profile));
+        data->cb(true, data->profile, data->userdata);
+    } else if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_error("Changing codec for device %s with profile %s failed. Error: %s",
+                data->device_path, pa_bluetooth_profile_to_string(data->profile),
+                dbus_message_get_error_name(r));
+    }
+
+    dbus_message_unref(r);
+
+    pa_xfree(data->pa_endpoint);
+    pa_xfree(data->device_path);
+    pa_xfree(data);
+
+    device->codec_switching_in_progress = false;
+}
+
+bool pa_bluetooth_device_switch_codec(pa_bluetooth_device *device, pa_bluetooth_profile_t profile,
+        pa_hashmap *capabilities_hashmap, const pa_a2dp_endpoint_conf *endpoint_conf,
+        void (*codec_switch_cb)(bool, pa_bluetooth_profile_t profile, void *), void *userdata) {
+    DBusMessageIter iter, dict;
+    DBusMessage *m;
+    struct switch_codec_data *data;
+    pa_a2dp_codec_capabilities *capabilities;
+    uint8_t config[MAX_A2DP_CAPS_SIZE];
+    uint8_t config_size;
+    bool is_a2dp_sink;
+    pa_hashmap *all_endpoints;
+    char *pa_endpoint;
+    const char *endpoint;
+
+    pa_assert(device);
+    pa_assert(capabilities_hashmap);
+    pa_assert(endpoint_conf);
+
+    if (device->codec_switching_in_progress) {
+        pa_log_error("Codec switching operation already in progress");
+        return false;
+    }
+
+    is_a2dp_sink = profile == PA_BLUETOOTH_PROFILE_A2DP_SINK;
+
+    all_endpoints = NULL;
+    all_endpoints = pa_hashmap_get(is_a2dp_sink ? device->a2dp_sink_endpoints : device->a2dp_source_endpoints,
+            &endpoint_conf->id);
+    pa_assert(all_endpoints);
+
+    pa_assert_se(endpoint = endpoint_conf->choose_remote_endpoint(capabilities_hashmap, &device->discovery->core->default_sample_spec, is_a2dp_sink));
+    pa_assert_se(capabilities = pa_hashmap_get(all_endpoints, endpoint));
+
+    config_size = endpoint_conf->fill_preferred_configuration(&device->discovery->core->default_sample_spec,
+            capabilities->buffer, capabilities->size, config);
+    if (config_size == 0)
+        return false;
+
+    pa_endpoint = pa_sprintf_malloc("%s/%s", is_a2dp_sink ? A2DP_SOURCE_ENDPOINT : A2DP_SINK_ENDPOINT,
+            endpoint_conf->bt_codec.name);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, endpoint,
+                BLUEZ_MEDIA_ENDPOINT_INTERFACE, "SetConfiguration"));
+
+    dbus_message_iter_init_append(m, &iter);
+    pa_assert_se(dbus_message_iter_append_basic(&iter, DBUS_TYPE_OBJECT_PATH, &pa_endpoint));
+    dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_VARIANT_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                     &dict);
+    pa_dbus_append_basic_array_variant_dict_entry(&dict, "Capabilities", DBUS_TYPE_BYTE, &config, config_size);
+    dbus_message_iter_close_container(&iter, &dict);
+
+    device->codec_switching_in_progress = true;
+
+    data = pa_xnew0(struct switch_codec_data, 1);
+    data->pa_endpoint = pa_endpoint;
+    data->device_path = pa_xstrdup(device->path);
+    data->profile = profile;
+    data->cb = codec_switch_cb;
+    data->userdata = userdata;
+
+    send_and_add_to_pending(device->discovery, m, pa_bluetooth_device_switch_codec_reply, data);
+
+    return true;
+}
+
 void pa_bluetooth_transport_set_state(pa_bluetooth_transport *t, pa_bluetooth_transport_state_t state) {
     bool old_any_connected;
     unsigned n_disconnected_profiles;
@@ -321,6 +570,112 @@ void pa_bluetooth_transport_set_state(pa_bluetooth_transport *t, pa_bluetooth_tr
     }
 }
 
+static pa_volume_t pa_bluetooth_transport_set_volume(pa_bluetooth_transport *t, pa_volume_t volume) {
+    static const char *volume_str = "Volume";
+    static const char *mediatransport_str = BLUEZ_MEDIA_TRANSPORT_INTERFACE;
+    DBusMessage *m;
+    DBusMessageIter iter;
+    uint16_t gain;
+
+    pa_assert(t);
+    pa_assert(t->device);
+    pa_assert(pa_bluetooth_profile_is_a2dp(t->profile));
+    pa_assert(t->device->discovery);
+
+    gain = volume_to_a2dp_gain(volume);
+    /* Propagate rounding and bound checks */
+    volume = a2dp_gain_to_volume(gain);
+
+    if (t->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE && t->source_volume == volume)
+        return volume;
+    else if (t->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK && t->sink_volume == volume)
+        return volume;
+
+    if (t->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE)
+        t->source_volume = volume;
+    else if (t->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK)
+        t->sink_volume = volume;
+
+    pa_log_debug("Sending A2DP volume %d/127 to peer", gain);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, t->path, DBUS_INTERFACE_PROPERTIES, "Set"));
+
+    dbus_message_iter_init_append(m, &iter);
+    pa_assert_se(dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &mediatransport_str));
+    pa_assert_se(dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &volume_str));
+    pa_dbus_append_basic_variant(&iter, DBUS_TYPE_UINT16, &gain);
+
+    /* Ignore replies, wait for the Volume property to change (generally arrives
+     * before this function replies).
+     *
+     * In an ideal world BlueZ exposes a function to change volume, that returns
+     * with the actual volume set by the peer as returned by the SetAbsoluteVolume
+     * AVRCP command.  That is required later to perform software volume compensation
+     * based on actual playback volume.
+     */
+    dbus_message_set_no_reply(m, true);
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(t->device->discovery->connection), m, NULL));
+    dbus_message_unref(m);
+
+    return volume;
+}
+
+static pa_volume_t pa_bluetooth_transport_set_sink_volume(pa_bluetooth_transport *t, pa_volume_t volume) {
+    pa_assert(t);
+    pa_assert(t->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK);
+    return pa_bluetooth_transport_set_volume(t, volume);
+}
+
+static pa_volume_t pa_bluetooth_transport_set_source_volume(pa_bluetooth_transport *t, pa_volume_t volume) {
+    pa_assert(t);
+    pa_assert(t->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE);
+    return pa_bluetooth_transport_set_volume(t, volume);
+}
+
+static void pa_bluetooth_transport_remote_volume_changed(pa_bluetooth_transport *t, pa_volume_t volume) {
+    pa_bluetooth_hook_t hook;
+    bool is_source;
+    char volume_str[PA_VOLUME_SNPRINT_MAX];
+
+    pa_assert(t);
+    pa_assert(t->device);
+
+    if (!t->device->avrcp_absolute_volume)
+        return;
+
+    is_source = t->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE;
+
+    if (is_source) {
+        if (t->source_volume == volume)
+            return;
+        t->source_volume = volume;
+        hook = PA_BLUETOOTH_HOOK_TRANSPORT_SOURCE_VOLUME_CHANGED;
+    } else if (t->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
+        if (t->sink_volume == volume)
+            return;
+        t->sink_volume = volume;
+        hook = PA_BLUETOOTH_HOOK_TRANSPORT_SINK_VOLUME_CHANGED;
+
+        /* A2DP Absolute Volume is optional.  This callback is only
+         * attached when the peer supports it, and the hook handler
+         * further attaches the necessary hardware callback to the
+         * pa_sink and disables software attenuation.
+         */
+        if (!t->set_sink_volume) {
+            pa_log_debug("A2DP sink supports volume control");
+            t->set_sink_volume = pa_bluetooth_transport_set_sink_volume;
+        }
+    } else {
+        pa_assert_not_reached();
+    }
+
+    pa_log_debug("Reporting volume change %s for %s",
+                 pa_volume_snprint(volume_str, sizeof(volume_str), volume),
+                 is_source ? "source" : "sink");
+
+    pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, hook), t);
+}
+
 void pa_bluetooth_transport_put(pa_bluetooth_transport *t) {
     pa_assert(t);
 
@@ -369,7 +724,7 @@ static int bluez5_transport_acquire_cb(pa_bluetooth_transport *t, bool optional,
     dbus_message_unref(m);
     m = NULL;
     if (!r) {
-        if (optional && pa_streq(err.name, "org.bluez.Error.NotAvailable"))
+        if (optional && pa_streq(err.name, BLUEZ_ERROR_NOT_AVAILABLE))
             pa_log_info("Failed optional acquire of unavailable transport %s", t->path);
         else
             pa_log_error("Transport %s() failed for transport %s (%s)", method, t->path, err.message);
@@ -428,6 +783,121 @@ static void bluez5_transport_release_cb(pa_bluetooth_transport *t) {
         pa_log_info("Transport %s released", t->path);
 }
 
+static void get_volume_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    DBusMessageIter iter, variant;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+    pa_bluetooth_transport *t;
+    uint16_t gain;
+    pa_volume_t volume;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(t = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_error(DBUS_INTERFACE_PROPERTIES ".Get %s Volume failed: %s: %s",
+                     dbus_message_get_path(p->message),
+                     dbus_message_get_error_name(r),
+                     pa_dbus_get_error_message(r));
+        goto finish;
+    }
+    dbus_message_iter_init(r, &iter);
+    pa_assert(dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_VARIANT);
+    dbus_message_iter_recurse(&iter, &variant);
+    pa_assert(dbus_message_iter_get_arg_type(&variant) == DBUS_TYPE_UINT16);
+    dbus_message_iter_get_basic(&variant, &gain);
+
+    if (gain > A2DP_MAX_GAIN)
+        gain = A2DP_MAX_GAIN;
+
+    pa_log_debug("Received A2DP Absolute Volume %d", gain);
+
+    volume = a2dp_gain_to_volume(gain);
+
+    pa_bluetooth_transport_remote_volume_changed(t, volume);
+
+finish:
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+}
+
+static void bluez5_transport_get_volume(pa_bluetooth_transport *t) {
+    static const char *volume_str = "Volume";
+    static const char *mediatransport_str = BLUEZ_MEDIA_TRANSPORT_INTERFACE;
+    DBusMessage *m;
+
+    pa_assert(t);
+    pa_assert(t->device);
+    pa_assert(t->device->discovery);
+
+    pa_assert(pa_bluetooth_profile_is_a2dp(t->profile));
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, t->path, DBUS_INTERFACE_PROPERTIES, "Get"));
+    pa_assert_se(dbus_message_append_args(m,
+        DBUS_TYPE_STRING, &mediatransport_str,
+        DBUS_TYPE_STRING, &volume_str,
+        DBUS_TYPE_INVALID));
+
+    send_and_add_to_pending(t->device->discovery, m, get_volume_reply, t);
+}
+
+void pa_bluetooth_transport_load_a2dp_sink_volume(pa_bluetooth_transport *t) {
+    pa_assert(t);
+    pa_assert(t->device);
+
+    if (!t->device->avrcp_absolute_volume)
+        return;
+
+    if (t->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK)
+        /* A2DP Absolute Volume control (AVRCP 1.4) is optional */
+        bluez5_transport_get_volume(t);
+}
+
+static ssize_t a2dp_transport_write(pa_bluetooth_transport *t, int fd, const void* buffer, size_t size, size_t write_mtu) {
+    ssize_t l = 0;
+    size_t written = 0;
+    size_t write_size;
+
+    pa_assert(t);
+
+    while (written < size) {
+        write_size = PA_MIN(size - written, write_mtu);
+        l = pa_write(fd, buffer + written, write_size, &t->stream_write_type);
+        if (l < 0)
+            break;
+        written += l;
+    }
+
+    if (l < 0) {
+        if (errno == EAGAIN) {
+            /* Hmm, apparently the socket was not writable, give up for now */
+            pa_log_debug("Got EAGAIN on write() after POLLOUT, probably there is a temporary connection loss.");
+            /* Drain write buffer */
+            written = size;
+        } else {
+            pa_log_error("Failed to write data to socket: %s", pa_cstrerror(errno));
+            /* Report error from write call */
+            return -1;
+        }
+    }
+
+    /* if too much data left discard it all */
+    if (size - written >= write_mtu) {
+        pa_log_warn("Wrote memory block to socket only partially! %lu written, discarding pending write size %lu larger than write_mtu %lu",
+                    written, size, write_mtu);
+        /* Drain write buffer */
+        written = size;
+    }
+
+    return written;
+}
+
 bool pa_bluetooth_device_any_transport_connected(const pa_bluetooth_device *d) {
     unsigned i;
 
@@ -443,6 +913,100 @@ bool pa_bluetooth_device_any_transport_connected(const pa_bluetooth_device *d) {
     return false;
 }
 
+/* Returns a path containing /org/pulseaudio + /bluez/hciXX */
+static char *adapter_battery_provider_path(pa_bluetooth_adapter *d) {
+    const char *devname = d->path + sizeof("/org") - 1;
+    return pa_sprintf_malloc(PULSEAUDIO_BASE_PATH "%s", devname);
+}
+
+/* Returns a path containing /org/pulseaudio + /bluez/hciXX/dev_XX_XX_XX_XX_XX_XX */
+static char *device_battery_provider_path(pa_bluetooth_device *d) {
+    const char *devname = d->path + sizeof("/org") - 1;
+    return pa_sprintf_malloc(PULSEAUDIO_BASE_PATH "%s", devname);
+}
+
+static void append_battery_provider(pa_bluetooth_device *d, DBusMessageIter *object);
+static void append_battery_provider_properties(pa_bluetooth_device *d, DBusMessageIter *object, bool only_percentage);
+
+void pa_bluetooth_device_report_battery_level(pa_bluetooth_device *d, uint8_t level, const char *reporting_source) {
+    bool had_battery_provider = d->has_battery_level;
+    d->has_battery_level = true;
+    d->battery_level = level;
+    pa_assert_se(d->battery_source = reporting_source);
+
+    pa_hook_fire(&d->discovery->hooks[PA_BLUETOOTH_HOOK_DEVICE_BATTERY_LEVEL_CHANGED], d);
+
+    if (!had_battery_provider) {
+        DBusMessage *m;
+        DBusMessageIter iter;
+        char *provider_path;
+
+        if (!d->adapter->battery_provider_registered) {
+            pa_log_debug("No battery provider registered on adapter of %s", d->path);
+            return;
+        }
+
+        provider_path = adapter_battery_provider_path(d->adapter);
+
+        pa_log_debug("Registering new battery for %s with level %d", d->path, level);
+
+        pa_assert_se(m = dbus_message_new_signal(provider_path, DBUS_INTERFACE_OBJECT_MANAGER, "InterfacesAdded"));
+        dbus_message_iter_init_append(m, &iter);
+        append_battery_provider(d, &iter);
+        pa_assert_se(dbus_connection_send(pa_dbus_connection_get(d->discovery->connection), m, NULL));
+
+        pa_xfree(provider_path);
+    } else {
+        DBusMessage *m;
+        DBusMessageIter iter;
+        char *battery_path = device_battery_provider_path(d);
+
+        pa_log_debug("Notifying battery Percentage for %s changed %d", battery_path, level);
+
+        pa_assert_se(m = dbus_message_new_signal(battery_path, DBUS_INTERFACE_PROPERTIES, "PropertiesChanged"));
+        dbus_message_iter_init_append(m, &iter);
+        append_battery_provider_properties(d, &iter, true);
+        pa_assert_se(dbus_connection_send(pa_dbus_connection_get(d->discovery->connection), m, NULL));
+        pa_xfree(battery_path);
+    }
+}
+
+/* Notify BlueZ that we're no longer providing battery info for this device */
+void pa_bluetooth_device_deregister_battery(pa_bluetooth_device *d) {
+    static const char *interface_name = BLUEZ_BATTERY_PROVIDER_INTERFACE;
+    DBusMessage *m;
+    DBusMessageIter iter, array;
+    char *battery_path, *provider_path;
+
+    if (!d->has_battery_level)
+        return;
+
+    d->has_battery_level = false;
+    pa_hook_fire(&d->discovery->hooks[PA_BLUETOOTH_HOOK_DEVICE_BATTERY_LEVEL_CHANGED], d);
+
+    if (!d->adapter->battery_provider_registered)
+        return;
+
+    battery_path = device_battery_provider_path(d);
+    provider_path = adapter_battery_provider_path(d->adapter);
+
+    pa_log_debug("Deregistering battery provider %s", battery_path);
+
+    pa_assert_se(m = dbus_message_new_signal(provider_path, DBUS_INTERFACE_OBJECT_MANAGER, "InterfacesRemoved"));
+    dbus_message_iter_init_append(m, &iter);
+    pa_assert_se(dbus_message_iter_append_basic(&iter, DBUS_TYPE_OBJECT_PATH, &battery_path));
+    pa_assert_se(dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, DBUS_TYPE_STRING_AS_STRING, &array));
+    pa_assert_se(dbus_message_iter_append_basic(&array, DBUS_TYPE_STRING, &interface_name));
+    pa_assert_se(dbus_message_iter_close_container(&iter, &array));
+
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(d->discovery->connection), m, NULL));
+    d->has_battery_level = false;
+
+    pa_xfree(battery_path);
+    pa_xfree(provider_path);
+}
+
+
 static int transport_state_from_string(const char* value, pa_bluetooth_transport_state_t *state) {
     pa_assert(value);
     pa_assert(state);
@@ -465,6 +1029,8 @@ static void parse_transport_property(pa_bluetooth_transport *t, DBusMessageIter
     if (key == NULL)
         return;
 
+    pa_log_debug("Transport property %s changed", key);
+
     dbus_message_iter_recurse(i, &variant_i);
 
     switch (dbus_message_iter_get_arg_type(&variant_i)) {
@@ -487,6 +1053,17 @@ static void parse_transport_property(pa_bluetooth_transport *t, DBusMessageIter
 
             break;
         }
+
+        case DBUS_TYPE_UINT16: {
+            uint16_t value;
+            dbus_message_iter_get_basic(&variant_i, &value);
+
+            if (pa_streq(key, "Volume")) {
+                pa_volume_t volume = a2dp_gain_to_volume(value);
+                pa_bluetooth_transport_remote_volume_changed(t, volume);
+            }
+            break;
+        }
     }
 
     return;
@@ -510,6 +1087,59 @@ static int parse_transport_properties(pa_bluetooth_transport *t, DBusMessageIter
     return 0;
 }
 
+static unsigned pa_a2dp_codec_id_hash_func(const void *_p) {
+    unsigned hash;
+    const pa_a2dp_codec_id *p = _p;
+
+    hash = p->codec_id;
+    hash = 31 * hash + ((p->vendor_id >>  0) & 0xFF);
+    hash = 31 * hash + ((p->vendor_id >>  8) & 0xFF);
+    hash = 31 * hash + ((p->vendor_id >> 16) & 0xFF);
+    hash = 31 * hash + ((p->vendor_id >> 24) & 0xFF);
+    hash = 31 * hash + ((p->vendor_codec_id >> 0) & 0xFF);
+    hash = 31 * hash + ((p->vendor_codec_id >> 8) & 0xFF);
+    return hash;
+}
+
+static int pa_a2dp_codec_id_compare_func(const void *_a, const void *_b) {
+    const pa_a2dp_codec_id *a = _a;
+    const pa_a2dp_codec_id *b = _b;
+
+    if (a->codec_id < b->codec_id)
+        return -1;
+    if (a->codec_id > b->codec_id)
+        return 1;
+
+    if (a->vendor_id < b->vendor_id)
+        return -1;
+    if (a->vendor_id > b->vendor_id)
+        return 1;
+
+    if (a->vendor_codec_id < b->vendor_codec_id)
+        return -1;
+    if (a->vendor_codec_id > b->vendor_codec_id)
+        return 1;
+
+    return 0;
+}
+
+static void remote_endpoint_remove(pa_bluetooth_discovery *y, const char *path) {
+    pa_bluetooth_device *device;
+    pa_hashmap *endpoints;
+    void *devices_state;
+    void *state;
+
+    PA_HASHMAP_FOREACH(device, y->devices, devices_state) {
+        PA_HASHMAP_FOREACH(endpoints, device->a2dp_sink_endpoints, state)
+            pa_hashmap_remove_and_free(endpoints, path);
+
+        PA_HASHMAP_FOREACH(endpoints, device->a2dp_source_endpoints, state)
+            pa_hashmap_remove_and_free(endpoints, path);
+    }
+
+    pa_log_debug("Remote endpoint %s was removed", path);
+}
+
 static pa_bluetooth_device* device_create(pa_bluetooth_discovery *y, const char *path) {
     pa_bluetooth_device *d;
 
@@ -518,8 +1148,11 @@ static pa_bluetooth_device* device_create(pa_bluetooth_discovery *y, const char
 
     d = pa_xnew0(pa_bluetooth_device, 1);
     d->discovery = y;
+    d->enable_hfp_hf = pa_bluetooth_discovery_get_enable_native_hfp_hf(y);
     d->path = pa_xstrdup(path);
     d->uuids = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL, pa_xfree);
+    d->a2dp_sink_endpoints = pa_hashmap_new_full(pa_a2dp_codec_id_hash_func, pa_a2dp_codec_id_compare_func, pa_xfree, (pa_free_cb_t)pa_hashmap_free);
+    d->a2dp_source_endpoints = pa_hashmap_new_full(pa_a2dp_codec_id_hash_func, pa_a2dp_codec_id_compare_func, pa_xfree, (pa_free_cb_t)pa_hashmap_free);
 
     pa_hashmap_put(y->devices, d->path, d);
 
@@ -539,6 +1172,30 @@ pa_bluetooth_device* pa_bluetooth_discovery_get_device_by_path(pa_bluetooth_disc
     return NULL;
 }
 
+bool pa_bluetooth_discovery_get_enable_native_hsp_hs(pa_bluetooth_discovery *y)
+{
+    pa_assert(y);
+    pa_assert(PA_REFCNT_VALUE(y) > 0);
+
+    return y->enable_native_hsp_hs;
+}
+
+bool pa_bluetooth_discovery_get_enable_native_hfp_hf(pa_bluetooth_discovery *y)
+{
+    pa_assert(y);
+    pa_assert(PA_REFCNT_VALUE(y) > 0);
+
+    return y->enable_native_hfp_hf;
+}
+
+bool pa_bluetooth_discovery_get_enable_msbc(pa_bluetooth_discovery *y)
+{
+    pa_assert(y);
+    pa_assert(PA_REFCNT_VALUE(y) > 0);
+
+    return y->enable_msbc;
+}
+
 pa_bluetooth_device* pa_bluetooth_discovery_get_device_by_address(pa_bluetooth_discovery *y, const char *remote, const char *local) {
     pa_bluetooth_device *d;
     void *state = NULL;
@@ -575,6 +1232,10 @@ static void device_free(pa_bluetooth_device *d) {
 
     if (d->uuids)
         pa_hashmap_free(d->uuids);
+    if (d->a2dp_sink_endpoints)
+        pa_hashmap_free(d->a2dp_sink_endpoints);
+    if (d->a2dp_source_endpoints)
+        pa_hashmap_free(d->a2dp_source_endpoints);
 
     pa_xfree(d->path);
     pa_xfree(d->alias);
@@ -642,6 +1303,179 @@ static void device_set_adapter(pa_bluetooth_device *device, pa_bluetooth_adapter
     device_update_valid(device);
 }
 
+static void append_battery_provider_properties(pa_bluetooth_device *d, DBusMessageIter *entry, bool only_percentage) {
+    static const char *interface_name = BLUEZ_BATTERY_PROVIDER_INTERFACE;
+    DBusMessageIter dict;
+
+    pa_assert_se(dbus_message_iter_append_basic(entry, DBUS_TYPE_STRING, &interface_name));
+
+    pa_assert_se(dbus_message_iter_open_container(entry, DBUS_TYPE_ARRAY,
+                                                 DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                                 DBUS_TYPE_STRING_AS_STRING
+                                                 DBUS_TYPE_VARIANT_AS_STRING
+                                                 DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                                 &dict));
+
+    pa_dbus_append_basic_variant_dict_entry(&dict, "Percentage", DBUS_TYPE_BYTE, &d->battery_level);
+
+    if (!only_percentage) {
+        pa_assert(d->battery_source);
+        pa_dbus_append_basic_variant_dict_entry(&dict, "Device", DBUS_TYPE_OBJECT_PATH, &d->path);
+        pa_dbus_append_basic_variant_dict_entry(&dict, "Source", DBUS_TYPE_STRING, &d->battery_source);
+    }
+
+    pa_assert_se(dbus_message_iter_close_container(entry, &dict));
+}
+
+static void append_battery_provider(pa_bluetooth_device *d, DBusMessageIter *object) {
+    char *battery_path = device_battery_provider_path(d);
+    DBusMessageIter array, entry;
+
+    pa_assert_se(dbus_message_iter_append_basic(object, DBUS_TYPE_OBJECT_PATH, &battery_path));
+
+    pa_assert_se(dbus_message_iter_open_container(object, DBUS_TYPE_ARRAY,
+                                                  DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                                  DBUS_TYPE_STRING_AS_STRING
+                                                  DBUS_TYPE_ARRAY_AS_STRING
+                                                  DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                                  DBUS_TYPE_STRING_AS_STRING
+                                                  DBUS_TYPE_VARIANT_AS_STRING
+                                                  DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                                  DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                                  &array));
+
+    pa_assert_se(dbus_message_iter_open_container(&array, DBUS_TYPE_DICT_ENTRY, NULL, &entry));
+    append_battery_provider_properties(d, &entry, false);
+    pa_assert_se(dbus_message_iter_close_container(&array, &entry));
+    pa_assert_se(dbus_message_iter_close_container(object, &array));
+
+    pa_xfree(battery_path);
+}
+
+static DBusHandlerResult battery_provider_handler(DBusConnection *c, DBusMessage *m, void *userdata) {
+    pa_bluetooth_adapter *a = userdata;
+    DBusMessage *r = NULL;
+    const char *path, *interface, *member;
+
+    pa_assert(a);
+
+    path = dbus_message_get_path(m);
+    interface = dbus_message_get_interface(m);
+    member = dbus_message_get_member(m);
+
+    pa_log_debug("%s %s %s", path, interface, member);
+
+    if (dbus_message_is_method_call(m, DBUS_INTERFACE_OBJECT_MANAGER, "GetManagedObjects")) {
+        DBusMessageIter iter, array, object;
+        pa_bluetooth_device *d;
+        void *state;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+
+        dbus_message_iter_init_append(r, &iter);
+        pa_assert_se(dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+                                                      DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                                      DBUS_TYPE_OBJECT_PATH_AS_STRING
+                                                      DBUS_TYPE_ARRAY_AS_STRING
+                                                      DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                                      DBUS_TYPE_STRING_AS_STRING
+                                                      DBUS_TYPE_ARRAY_AS_STRING
+                                                      DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                                      DBUS_TYPE_STRING_AS_STRING
+                                                      DBUS_TYPE_VARIANT_AS_STRING
+                                                      DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                                      DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                                      DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                                      &array));
+
+        PA_HASHMAP_FOREACH(d, a->discovery->devices, state) {
+
+            if (d->has_battery_level) {
+                pa_log_debug("%s: battery level  = %d", d->path, d->battery_level);
+                pa_assert_se(dbus_message_iter_open_container(&array, DBUS_TYPE_DICT_ENTRY, NULL, &object));
+                append_battery_provider(d, &object);
+                pa_assert_se(dbus_message_iter_close_container(&array, &object));
+            }
+        }
+
+        pa_assert_se(dbus_message_iter_close_container(&iter, &array));
+    } else
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    pa_assert_se(dbus_connection_send(c, r, NULL));
+    dbus_message_unref(r);
+
+    return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+static void adapter_register_battery_provider(pa_bluetooth_adapter *a) {
+    DBusMessage *m, *r;
+    DBusError error;
+
+    static const DBusObjectPathVTable vtable_profile = {
+        .message_function = battery_provider_handler,
+    };
+
+    char *provider_path = adapter_battery_provider_path(a);
+
+    pa_log_debug("Registering battery provider for %s at %s", a->path, provider_path);
+
+    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(a->discovery->connection), provider_path, &vtable_profile, a));
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, a->path, BLUEZ_BATTERY_PROVIDER_MANAGER_INTERFACE, "RegisterBatteryProvider"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_OBJECT_PATH, &provider_path, DBUS_TYPE_INVALID));
+
+    dbus_error_init(&error);
+    if (!(r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(a->discovery->connection), m, -1, &error))) {
+        if (dbus_error_has_name(&error, DBUS_ERROR_UNKNOWN_METHOD))
+            pa_log_notice("Could not find " BLUEZ_BATTERY_PROVIDER_MANAGER_INTERFACE
+                          ".RegisterBatteryProvider(), is bluetoothd started with experimental features enabled (-E flag)?");
+        else
+            pa_log_warn(BLUEZ_BATTERY_PROVIDER_MANAGER_INTERFACE ".RegisterBatteryProvider() Failed: %s:%s", error.name, error.message);
+        dbus_error_free(&error);
+        dbus_connection_unregister_object_path(pa_dbus_connection_get(a->discovery->connection), provider_path);
+    } else {
+        dbus_message_unref(r);
+        a->battery_provider_registered = true;
+    }
+
+    dbus_message_unref(m);
+    pa_xfree(provider_path);
+}
+
+static void adapter_deregister_battery_provider(pa_bluetooth_adapter *a) {
+    DBusMessage *m, *r;
+    DBusError error;
+    char *provider_path;
+
+    if (!a->battery_provider_registered) {
+        pa_log_debug("No battery provider registered for %s", a->path);
+        return;
+    }
+
+    provider_path = adapter_battery_provider_path(a);
+
+    pa_log_debug("Deregistering battery provider at %s", provider_path);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, a->path, BLUEZ_BATTERY_PROVIDER_MANAGER_INTERFACE, "UnregisterBatteryProvider"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_OBJECT_PATH, &provider_path, DBUS_TYPE_INVALID));
+
+    dbus_error_init(&error);
+    if (!(r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(a->discovery->connection), m, -1, &error))) {
+        pa_log_error(BLUEZ_BATTERY_PROVIDER_MANAGER_INTERFACE ".UnregisterBatteryProvider() Failed: %s:%s", error.name, error.message);
+        dbus_error_free(&error);
+    } else {
+        dbus_message_unref(r);
+        a->battery_provider_registered = false;
+    }
+
+    dbus_message_unref(m);
+
+    dbus_connection_unregister_object_path(pa_dbus_connection_get(a->discovery->connection), provider_path);
+
+    pa_xfree(provider_path);
+}
+
 static pa_bluetooth_adapter* adapter_create(pa_bluetooth_discovery *y, const char *path) {
     pa_bluetooth_adapter *a;
 
@@ -651,6 +1485,7 @@ static pa_bluetooth_adapter* adapter_create(pa_bluetooth_discovery *y, const cha
     a = pa_xnew0(pa_bluetooth_adapter, 1);
     a->discovery = y;
     a->path = pa_xstrdup(path);
+    a->uuids = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL, pa_xfree);
 
     pa_hashmap_put(y->adapters, a->path, a);
 
@@ -664,10 +1499,13 @@ static void adapter_free(pa_bluetooth_adapter *a) {
     pa_assert(a);
     pa_assert(a->discovery);
 
+    adapter_deregister_battery_provider(a);
+
     PA_HASHMAP_FOREACH(d, a->discovery->devices, state)
         if (d->adapter == a)
             device_set_adapter(d, NULL);
 
+    pa_hashmap_free(a->uuids);
     pa_xfree(a->path);
     pa_xfree(a->address);
     pa_xfree(a);
@@ -746,78 +1584,374 @@ static void parse_device_property(pa_bluetooth_device *d, DBusMessageIter *i) {
                 pa_log_debug("%s: %s", key, value);
             }
 
-            break;
-        }
+            break;
+        }
+
+        case DBUS_TYPE_UINT32: {
+            uint32_t value;
+            dbus_message_iter_get_basic(&variant_i, &value);
+
+            if (pa_streq(key, "Class")) {
+                d->class_of_device = value;
+                pa_log_debug("%s: %d", key, value);
+            }
+
+            break;
+        }
+
+        case DBUS_TYPE_ARRAY: {
+            DBusMessageIter ai;
+            dbus_message_iter_recurse(&variant_i, &ai);
+
+            if (dbus_message_iter_get_arg_type(&ai) == DBUS_TYPE_STRING && pa_streq(key, "UUIDs")) {
+                /* bluetoothd never removes UUIDs from a device object so we
+                 * don't need to check for disappeared UUIDs here. */
+                while (dbus_message_iter_get_arg_type(&ai) != DBUS_TYPE_INVALID) {
+                    const char *value;
+                    char *uuid;
+
+                    dbus_message_iter_get_basic(&ai, &value);
+
+                    if (pa_hashmap_get(d->uuids, value)) {
+                        dbus_message_iter_next(&ai);
+                        continue;
+                    }
+
+                    uuid = pa_xstrdup(value);
+                    pa_hashmap_put(d->uuids, uuid, uuid);
+
+                    pa_log_debug("%s: %s", key, value);
+                    dbus_message_iter_next(&ai);
+                }
+            }
+
+            break;
+        }
+    }
+}
+
+static void parse_device_properties(pa_bluetooth_device *d, DBusMessageIter *i) {
+    DBusMessageIter element_i;
+
+    dbus_message_iter_recurse(i, &element_i);
+
+    while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
+        DBusMessageIter dict_i;
+
+        dbus_message_iter_recurse(&element_i, &dict_i);
+        parse_device_property(d, &dict_i);
+        dbus_message_iter_next(&element_i);
+    }
+
+    if (!d->properties_received) {
+        d->properties_received = true;
+        device_update_valid(d);
+
+        if (!d->address || !d->adapter_path || !d->alias)
+            pa_log_error("Non-optional information missing for device %s", d->path);
+    }
+}
+
+static void parse_adapter_properties(pa_bluetooth_adapter *a, DBusMessageIter *i, bool is_property_change) {
+    DBusMessageIter element_i;
+
+    pa_assert(a);
+
+    dbus_message_iter_recurse(i, &element_i);
+
+    while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
+        DBusMessageIter dict_i, variant_i;
+        const char *key;
+
+        dbus_message_iter_recurse(&element_i, &dict_i);
+
+        key = check_variant_property(&dict_i);
+        if (key == NULL) {
+            pa_log_error("Received invalid property for adapter %s", a->path);
+            return;
+        }
+
+        dbus_message_iter_recurse(&dict_i, &variant_i);
+
+        if (dbus_message_iter_get_arg_type(&variant_i) == DBUS_TYPE_STRING && pa_streq(key, "Address")) {
+            const char *value;
+
+            if (is_property_change) {
+                pa_log_warn("Adapter property 'Address' expected to be constant but changed for %s, ignoring", a->path);
+                return;
+            }
+
+            if (a->address) {
+                pa_log_warn("Adapter %s received a duplicate 'Address' property, ignoring", a->path);
+                return;
+            }
+
+            dbus_message_iter_get_basic(&variant_i, &value);
+            a->address = pa_xstrdup(value);
+            a->valid = true;
+        } else if (dbus_message_iter_get_arg_type(&variant_i) == DBUS_TYPE_ARRAY) {
+            DBusMessageIter ai;
+            dbus_message_iter_recurse(&variant_i, &ai);
+
+            if (dbus_message_iter_get_arg_type(&ai) == DBUS_TYPE_STRING && pa_streq(key, "UUIDs")) {
+                pa_hashmap_remove_all(a->uuids);
+                while (dbus_message_iter_get_arg_type(&ai) != DBUS_TYPE_INVALID) {
+                    const char *value;
+                    char *uuid;
+
+                    dbus_message_iter_get_basic(&ai, &value);
+
+                    if (pa_hashmap_get(a->uuids, value)) {
+                        dbus_message_iter_next(&ai);
+                        continue;
+                    }
+
+                    uuid = pa_xstrdup(value);
+                    pa_hashmap_put(a->uuids, uuid, uuid);
+
+                    pa_log_debug("%s: %s", key, value);
+                    dbus_message_iter_next(&ai);
+                }
+                pa_hook_fire(pa_bluetooth_discovery_hook(a->discovery, PA_BLUETOOTH_HOOK_ADAPTER_UUIDS_CHANGED), a);
+            }
+        }
+
+        dbus_message_iter_next(&element_i);
+    }
+}
+
+static void register_legacy_sbc_endpoint_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+    char *endpoint;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(endpoint = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_SUPPORTED)) {
+        pa_log_info("Couldn't register endpoint %s because it is disabled in BlueZ", endpoint);
+        goto finish;
+    }
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_error(BLUEZ_MEDIA_INTERFACE ".RegisterEndpoint() failed: %s: %s", dbus_message_get_error_name(r),
+                     pa_dbus_get_error_message(r));
+        goto finish;
+    }
+
+finish:
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+
+    pa_xfree(endpoint);
+}
+
+static void register_legacy_sbc_endpoint(pa_bluetooth_discovery *y, const pa_a2dp_endpoint_conf *endpoint_conf, const char *path, const char *endpoint, const char *uuid) {
+    DBusMessage *m;
+    DBusMessageIter i, d;
+    uint8_t capabilities[MAX_A2DP_CAPS_SIZE];
+    size_t capabilities_size;
+    uint8_t codec_id;
+
+    pa_log_debug("Registering %s on adapter %s", endpoint, path);
+
+    codec_id = endpoint_conf->id.codec_id;
+    capabilities_size = endpoint_conf->fill_capabilities(capabilities);
+    pa_assert(capabilities_size != 0);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, path, BLUEZ_MEDIA_INTERFACE, "RegisterEndpoint"));
+
+    dbus_message_iter_init_append(m, &i);
+    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &endpoint));
+    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY,
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_VARIANT_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                     &d);
+    pa_dbus_append_basic_variant_dict_entry(&d, "UUID", DBUS_TYPE_STRING, &uuid);
+    pa_dbus_append_basic_variant_dict_entry(&d, "Codec", DBUS_TYPE_BYTE, &codec_id);
+    pa_dbus_append_basic_array_variant_dict_entry(&d, "Capabilities", DBUS_TYPE_BYTE, &capabilities, capabilities_size);
+
+    dbus_message_iter_close_container(&i, &d);
+
+    send_and_add_to_pending(y, m, register_legacy_sbc_endpoint_reply, pa_xstrdup(endpoint));
+}
+
+static void register_player_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_SUPPORTED)) {
+        pa_log_info("Couldn't register player because it is disabled in BlueZ");
+        goto finish;
+    }
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_error(BLUEZ_MEDIA_INTERFACE ".RegisterPlayer() failed: %s: %s", dbus_message_get_error_name(r),
+                     pa_dbus_get_error_message(r));
+        goto finish;
+    }
+
+finish:
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+}
+
+void send_player_properties_changed_event(pa_bluetooth_discovery *y, const char *value) {
+    pa_assert(y);
+    pa_assert(value);
+
+    DBusMessage *m;
+    DBusMessageIter i, d;
+    static const char *interface_name = BLUEZ_PLAYER_INTERFACE;
+
+    pa_log_info("send value %s to adapter", value);
+
+    pa_assert_se(m = dbus_message_new_signal(MEDIA_PALYER, DBUS_INTERFACE_PROPERTIES, "PropertiesChanged"));
+    dbus_message_iter_init_append(m, &i);
+    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_STRING, &interface_name));
+    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
+                                         DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
+
+    pa_dbus_append_basic_variant_dict_entry(&d, "PlaybackStatus", DBUS_TYPE_STRING, &value);
+    dbus_message_iter_close_container(&i, &d);
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(y->connection), m, NULL));
+}
+
+static void register_player(pa_bluetooth_discovery *y, const char *path, const char *player) {
+    DBusMessage *m;
+    DBusMessageIter i, d;
+    uint8_t codec = 0;
 
-        case DBUS_TYPE_UINT32: {
-            uint32_t value;
-            dbus_message_iter_get_basic(&variant_i, &value);
+    pa_log_debug("Registering %s on adapter %s", player, path);
 
-            if (pa_streq(key, "Class")) {
-                d->class_of_device = value;
-                pa_log_debug("%s: %d", key, value);
-            }
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, path, BLUEZ_MEDIA_INTERFACE, "RegisterPlayer"));
 
-            break;
-        }
+    dbus_message_iter_init_append(m, &i);
+    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &player));
+    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
+                                         DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
 
-        case DBUS_TYPE_ARRAY: {
-            DBusMessageIter ai;
-            dbus_message_iter_recurse(&variant_i, &ai);
+    dbus_message_iter_close_container(&i, &d);
 
-            if (dbus_message_iter_get_arg_type(&ai) == DBUS_TYPE_STRING && pa_streq(key, "UUIDs")) {
-                /* bluetoothd never removes UUIDs from a device object so we
-                 * don't need to check for disappeared UUIDs here. */
-                while (dbus_message_iter_get_arg_type(&ai) != DBUS_TYPE_INVALID) {
-                    const char *value;
-                    char *uuid;
+    send_and_add_to_pending(y, m, register_player_reply, pa_xstrdup(player));
+}
 
-                    dbus_message_iter_get_basic(&ai, &value);
+static void register_application_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_adapter *a;
+    pa_bluetooth_discovery *y;
+    char *path;
+    bool fallback = true;
 
-                    if (pa_hashmap_get(d->uuids, value)) {
-                        dbus_message_iter_next(&ai);
-                        continue;
-                    }
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(path = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
 
-                    uuid = pa_xstrdup(value);
-                    pa_hashmap_put(d->uuids, uuid, uuid);
+    if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_SUPPORTED)) {
+        pa_log_info("Couldn't register media application for adapter %s because it is disabled in BlueZ", path);
+        goto finish;
+    }
 
-                    pa_log_debug("%s: %s", key, value);
-                    dbus_message_iter_next(&ai);
-                }
-            }
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_warn(BLUEZ_MEDIA_INTERFACE ".RegisterApplication() failed: %s: %s",
+                dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
+        pa_log_warn("Couldn't register media application for adapter %s", path);
+        goto finish;
+    }
 
-            break;
-        }
+    a = pa_hashmap_get(y->adapters, path);
+    if (!a) {
+        pa_log_error("Couldn't register media application for adapter %s because it does not exist anymore", path);
+        goto finish;
     }
-}
 
-static void parse_device_properties(pa_bluetooth_device *d, DBusMessageIter *i) {
-    DBusMessageIter element_i;
+    fallback = false;
+    a->application_registered = true;
+    pa_log_debug("Media application for adapter %s was successfully registered", path);
 
-    dbus_message_iter_recurse(i, &element_i);
+finish:
+    dbus_message_unref(r);
 
-    while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
-        DBusMessageIter dict_i;
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
 
-        dbus_message_iter_recurse(&element_i, &dict_i);
-        parse_device_property(d, &dict_i);
-        dbus_message_iter_next(&element_i);
+    if (fallback) {
+        /* If bluez does not support RegisterApplication, fallback to old legacy API with just one SBC codec */
+        const pa_a2dp_endpoint_conf *endpoint_conf;
+        endpoint_conf = pa_bluetooth_get_a2dp_endpoint_conf("sbc");
+        pa_assert(endpoint_conf);
+        register_legacy_sbc_endpoint(y, endpoint_conf, path, A2DP_SINK_ENDPOINT "/sbc",
+                PA_BLUETOOTH_UUID_A2DP_SINK);
+        register_legacy_sbc_endpoint(y, endpoint_conf, path, A2DP_SOURCE_ENDPOINT "/sbc",
+                PA_BLUETOOTH_UUID_A2DP_SOURCE);
+        pa_log_warn("Only SBC codec is available for A2DP profiles");
     }
 
-    if (!d->properties_received) {
-        d->properties_received = true;
-        device_update_valid(d);
+    pa_xfree(path);
+}
 
-        if (!d->address || !d->adapter_path || !d->alias)
-            pa_log_error("Non-optional information missing for device %s", d->path);
+static void register_application(pa_bluetooth_adapter *a) {
+    DBusMessage *m;
+    DBusMessageIter i, d;
+    const char *object_manager_path = A2DP_OBJECT_MANAGER_PATH;
+
+    if (a->application_registered) {
+        pa_log_info("Media application is already registered for adapter %s", a->path);
+        return;
     }
+
+    pa_log_debug("Registering media application for adapter %s", a->path);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, a->path,
+                BLUEZ_MEDIA_INTERFACE, "RegisterApplication"));
+
+    dbus_message_iter_init_append(m, &i);
+    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &object_manager_path));
+    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY,
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_VARIANT_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                     &d);
+    dbus_message_iter_close_container(&i, &d);
+
+    send_and_add_to_pending(a->discovery, m, register_application_reply, pa_xstrdup(a->path));
 }
 
-static void parse_adapter_properties(pa_bluetooth_adapter *a, DBusMessageIter *i, bool is_property_change) {
+static void parse_remote_endpoint_properties(pa_bluetooth_discovery *y, const char *endpoint, DBusMessageIter *i) {
     DBusMessageIter element_i;
-
-    pa_assert(a);
+    pa_bluetooth_device *device;
+    pa_hashmap *codec_endpoints;
+    pa_hashmap *endpoints;
+    pa_a2dp_codec_id *a2dp_codec_id;
+    pa_a2dp_codec_capabilities *a2dp_codec_capabilities;
+    const char *uuid = NULL;
+    const char *device_path = NULL;
+    uint8_t codec_id = 0;
+    bool have_codec_id = false;
+    const uint8_t *capabilities = NULL;
+    int capabilities_size = 0;
+
+    pa_log_debug("Parsing remote endpoint %s", endpoint);
 
     dbus_message_iter_recurse(i, &element_i);
 
@@ -829,92 +1963,127 @@ static void parse_adapter_properties(pa_bluetooth_adapter *a, DBusMessageIter *i
 
         key = check_variant_property(&dict_i);
         if (key == NULL) {
-            pa_log_error("Received invalid property for adapter %s", a->path);
+            pa_log_error("Received invalid property for remote endpoint %s", endpoint);
             return;
         }
 
         dbus_message_iter_recurse(&dict_i, &variant_i);
 
-        if (dbus_message_iter_get_arg_type(&variant_i) == DBUS_TYPE_STRING && pa_streq(key, "Address")) {
-            const char *value;
+        if (pa_streq(key, "UUID")) {
+            if (dbus_message_iter_get_arg_type(&variant_i) != DBUS_TYPE_STRING) {
+                pa_log_warn("Remote endpoint %s property 'UUID' is not string, ignoring", endpoint);
+                return;
+            }
 
-            if (is_property_change) {
-                pa_log_warn("Adapter property 'Address' expected to be constant but changed for %s, ignoring", a->path);
+            dbus_message_iter_get_basic(&variant_i, &uuid);
+        } else if (pa_streq(key, "Codec")) {
+            if (dbus_message_iter_get_arg_type(&variant_i) != DBUS_TYPE_BYTE) {
+                pa_log_warn("Remote endpoint %s property 'Codec' is not byte, ignoring", endpoint);
                 return;
             }
 
-            if (a->address) {
-                pa_log_warn("Adapter %s received a duplicate 'Address' property, ignoring", a->path);
+            dbus_message_iter_get_basic(&variant_i, &codec_id);
+            have_codec_id = true;
+        } else if (pa_streq(key, "Capabilities")) {
+            DBusMessageIter array;
+
+            if (dbus_message_iter_get_arg_type(&variant_i) != DBUS_TYPE_ARRAY) {
+                pa_log_warn("Remote endpoint %s property 'Capabilities' is not array, ignoring", endpoint);
                 return;
             }
 
-            dbus_message_iter_get_basic(&variant_i, &value);
-            a->address = pa_xstrdup(value);
-            a->valid = true;
+            dbus_message_iter_recurse(&variant_i, &array);
+            if (dbus_message_iter_get_arg_type(&array) != DBUS_TYPE_BYTE) {
+                pa_log_warn("Remote endpoint %s property 'Capabilities' is not array of bytes, ignoring", endpoint);
+                return;
+            }
+
+            dbus_message_iter_get_fixed_array(&array, &capabilities, &capabilities_size);
+        } else if (pa_streq(key, "Device")) {
+            if (dbus_message_iter_get_arg_type(&variant_i) != DBUS_TYPE_OBJECT_PATH) {
+                pa_log_warn("Remote endpoint %s property 'Device' is not path, ignoring", endpoint);
+                return;
+            }
+
+            dbus_message_iter_get_basic(&variant_i, &device_path);
         }
 
         dbus_message_iter_next(&element_i);
     }
-}
-
-static void register_endpoint_reply(DBusPendingCall *pending, void *userdata) {
-    DBusMessage *r;
-    pa_dbus_pending *p;
-    pa_bluetooth_discovery *y;
-    char *endpoint;
-
-    pa_assert(pending);
-    pa_assert_se(p = userdata);
-    pa_assert_se(y = p->context_data);
-    pa_assert_se(endpoint = p->call_data);
-    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
 
-    if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_SUPPORTED)) {
-        pa_log_info("Couldn't register endpoint %s because it is disabled in BlueZ", endpoint);
-        goto finish;
+    if (!uuid) {
+        pa_log_warn("Remote endpoint %s does not have property 'UUID', ignoring", endpoint);
+        return;
     }
 
-    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
-        pa_log_error(BLUEZ_MEDIA_INTERFACE ".RegisterEndpoint() failed: %s: %s", dbus_message_get_error_name(r),
-                     pa_dbus_get_error_message(r));
-        goto finish;
+    if (!have_codec_id) {
+        pa_log_warn("Remote endpoint %s does not have property 'Codec', ignoring", endpoint);
+        return;
     }
 
-finish:
-    dbus_message_unref(r);
+    if (!capabilities || !capabilities_size) {
+        pa_log_warn("Remote endpoint %s does not have property 'Capabilities', ignoring", endpoint);
+        return;
+    }
 
-    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
-    pa_dbus_pending_free(p);
+    if (!device_path) {
+        pa_log_warn("Remote endpoint %s does not have property 'Device', ignoring", endpoint);
+        return;
+    }
 
-    pa_xfree(endpoint);
-}
+    device = pa_hashmap_get(y->devices, device_path);
+    if (!device) {
+        pa_log_warn("Device for remote endpoint %s was not found", endpoint);
+        return;
+    }
 
-static void register_endpoint(pa_bluetooth_discovery *y, const pa_a2dp_codec *a2dp_codec, const char *path, const char *endpoint, const char *uuid) {
-    DBusMessage *m;
-    DBusMessageIter i, d;
-    uint8_t capabilities[MAX_A2DP_CAPS_SIZE];
-    size_t capabilities_size;
-    uint8_t codec_id;
+    if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK)) {
+        codec_endpoints = device->a2dp_sink_endpoints;
+    } else if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE)) {
+        codec_endpoints = device->a2dp_source_endpoints;
+    } else {
+        pa_log_warn("Remote endpoint %s does not have valid property 'UUID', ignoring", endpoint);
+        return;
+    }
 
-    pa_log_debug("Registering %s on adapter %s", endpoint, path);
+    if (capabilities_size < 0 || capabilities_size > MAX_A2DP_CAPS_SIZE) {
+        pa_log_warn("Remote endpoint %s does not have valid property 'Capabilities', ignoring", endpoint);
+        return;
+    }
 
-    codec_id = a2dp_codec->id.codec_id;
-    capabilities_size = a2dp_codec->fill_capabilities(capabilities);
-    pa_assert(capabilities_size != 0);
+    a2dp_codec_id = pa_xmalloc0(sizeof(*a2dp_codec_id));
+    a2dp_codec_id->codec_id = codec_id;
+    if (codec_id == A2DP_CODEC_VENDOR) {
+        if ((size_t)capabilities_size < sizeof(a2dp_vendor_codec_t)) {
+            pa_log_warn("Remote endpoint %s does not have valid property 'Capabilities', ignoring", endpoint);
+            pa_xfree(a2dp_codec_id);
+            return;
+        }
+        a2dp_codec_id->vendor_id = A2DP_GET_VENDOR_ID(*(a2dp_vendor_codec_t *)capabilities);
+        a2dp_codec_id->vendor_codec_id = A2DP_GET_CODEC_ID(*(a2dp_vendor_codec_t *)capabilities);
+    } else {
+        a2dp_codec_id->vendor_id = 0;
+        a2dp_codec_id->vendor_codec_id = 0;
+    }
 
-    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, path, BLUEZ_MEDIA_INTERFACE, "RegisterEndpoint"));
+    if (!pa_bluetooth_a2dp_codec_is_available(a2dp_codec_id, pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK))) {
+        pa_xfree(a2dp_codec_id);
+        return;
+    }
 
-    dbus_message_iter_init_append(m, &i);
-    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &endpoint));
-    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
-                                         DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
-    pa_dbus_append_basic_variant_dict_entry(&d, "UUID", DBUS_TYPE_STRING, &uuid);
-    pa_dbus_append_basic_variant_dict_entry(&d, "Codec", DBUS_TYPE_BYTE, &codec_id);
-    pa_dbus_append_basic_array_variant_dict_entry(&d, "Capabilities", DBUS_TYPE_BYTE, &capabilities, capabilities_size);
+    a2dp_codec_capabilities = pa_xmalloc0(sizeof(*a2dp_codec_capabilities) + capabilities_size);
+    a2dp_codec_capabilities->size = capabilities_size;
+    memcpy(a2dp_codec_capabilities->buffer, capabilities, capabilities_size);
 
-    dbus_message_iter_close_container(&i, &d);
+    endpoints = pa_hashmap_get(codec_endpoints, a2dp_codec_id);
+    if (!endpoints) {
+        endpoints = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, pa_xfree, pa_xfree);
+        pa_hashmap_put(codec_endpoints, a2dp_codec_id, endpoints);
+    }
 
-    send_and_add_to_pending(y, m, register_endpoint_reply, pa_xstrdup(endpoint));
+    if (pa_hashmap_remove_and_free(endpoints, endpoint) >= 0)
+        pa_log_debug("Replacing existing remote endpoint %s", endpoint);
+    pa_hashmap_put(endpoints, pa_xstrdup(endpoint), a2dp_codec_capabilities);
 }
 
 static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessageIter *dict_i) {
@@ -945,7 +2114,6 @@ static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessa
 
         if (pa_streq(interface, BLUEZ_ADAPTER_INTERFACE)) {
             pa_bluetooth_adapter *a;
-            unsigned a2dp_codec_i;
 
             if ((a = pa_hashmap_get(y->adapters, path))) {
                 pa_log_error("Found duplicated D-Bus path for adapter %s", path);
@@ -960,21 +2128,9 @@ static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessa
             if (!a->valid)
                 return;
 
-            /* Order is important. bluez prefers endpoints registered earlier.
-             * And codec with higher number has higher priority. So iterate in reverse order. */
-            for (a2dp_codec_i = pa_bluetooth_a2dp_codec_count(); a2dp_codec_i > 0; a2dp_codec_i--) {
-                const pa_a2dp_codec *a2dp_codec = pa_bluetooth_a2dp_codec_iter(a2dp_codec_i-1);
-                char *endpoint;
-
-                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, a2dp_codec->name);
-                register_endpoint(y, a2dp_codec, path, endpoint, PA_BLUETOOTH_UUID_A2DP_SINK);
-                pa_xfree(endpoint);
-
-                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, a2dp_codec->name);
-                register_endpoint(y, a2dp_codec, path, endpoint, PA_BLUETOOTH_UUID_A2DP_SOURCE);
-                pa_xfree(endpoint);
-            }
-
+            register_application(a);
+            adapter_register_battery_provider(a);
+            register_player(y, path, MEDIA_PALYER);
         } else if (pa_streq(interface, BLUEZ_DEVICE_INTERFACE)) {
 
             if ((d = pa_hashmap_get(y->devices, path))) {
@@ -988,7 +2144,8 @@ static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessa
             pa_log_debug("Device %s found", d->path);
 
             parse_device_properties(d, &iface_i);
-
+        } else if (pa_streq(interface, BLUEZ_MEDIA_ENDPOINT_INTERFACE)) {
+            parse_remote_endpoint_properties(y, path, &iface_i);
         } else
             pa_log_debug("Unknown interface %s found, skipping", interface);
 
@@ -1007,6 +2164,8 @@ static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessa
             }
 
             d->tried_to_link_with_adapter = true;
+            if((!d->adapter) || (!d->adapter->valid))
+                d->tried_to_link_with_adapter = false;
         }
     }
 
@@ -1020,25 +2179,25 @@ void pa_bluetooth_discovery_set_ofono_running(pa_bluetooth_discovery *y, bool is
     if (y->headset_backend != HEADSET_BACKEND_AUTO)
         return;
 
-    /* If ofono starts running, all devices that might be connected to the HS role
+    pa_bluetooth_native_backend_enable_shared_profiles(y->native_backend, !is_running);
+
+    /* If ofono starts running, all devices that might be connected to the HS roles or HFP AG role
      * need to be disconnected, so that the devices can be handled by ofono */
     if (is_running) {
         void *state;
         pa_bluetooth_device *d;
 
         PA_HASHMAP_FOREACH(d, y->devices, state) {
-            if (device_supports_profile(d, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)) {
+            if (pa_bluetooth_device_supports_profile(d, PA_BLUETOOTH_PROFILE_HFP_AG) || pa_bluetooth_device_supports_profile(d, PA_BLUETOOTH_PROFILE_HFP_HF)) {
                 DBusMessage *m;
 
-                pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, d->path, "org.bluez.Device1", "Disconnect"));
+                pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, d->path, BLUEZ_DEVICE_INTERFACE, "Disconnect"));
                 dbus_message_set_no_reply(m, true);
                 pa_assert_se(dbus_connection_send(pa_dbus_connection_get(y->connection), m, NULL));
                 dbus_message_unref(m);
             }
         }
     }
-
-    pa_bluetooth_native_backend_enable_hs_role(y->native_backend, !is_running);
 }
 
 static void get_managed_objects_reply(DBusPendingCall *pending, void *userdata) {
@@ -1096,7 +2255,7 @@ static void get_managed_objects(pa_bluetooth_discovery *y) {
 
     pa_assert(y);
 
-    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, "/", "org.freedesktop.DBus.ObjectManager",
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, "/", DBUS_INTERFACE_OBJECT_MANAGER,
                                                   "GetManagedObjects"));
     send_and_add_to_pending(y, m, get_managed_objects_reply, NULL);
 }
@@ -1118,7 +2277,7 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
 
     dbus_error_init(&err);
 
-    if (dbus_message_is_signal(m, "org.freedesktop.DBus", "NameOwnerChanged")) {
+    if (dbus_message_is_signal(m, DBUS_INTERFACE_DBUS, "NameOwnerChanged")) {
         const char *name, *old_owner, *new_owner;
 
         if (!dbus_message_get_args(m, &err,
@@ -1126,7 +2285,7 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
                                    DBUS_TYPE_STRING, &old_owner,
                                    DBUS_TYPE_STRING, &new_owner,
                                    DBUS_TYPE_INVALID)) {
-            pa_log_error("Failed to parse org.freedesktop.DBus.NameOwnerChanged: %s", err.message);
+            pa_log_error("Failed to parse " DBUS_INTERFACE_DBUS ".NameOwnerChanged: %s", err.message);
             goto fail;
         }
 
@@ -1153,7 +2312,7 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
         }
 
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-    } else if (dbus_message_is_signal(m, "org.freedesktop.DBus.ObjectManager", "InterfacesAdded")) {
+    } else if (dbus_message_is_signal(m, DBUS_INTERFACE_OBJECT_MANAGER, "InterfacesAdded")) {
         DBusMessageIter arg_i;
 
         if (!y->objects_listed)
@@ -1167,7 +2326,7 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
         parse_interfaces_and_properties(y, &arg_i);
 
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-    } else if (dbus_message_is_signal(m, "org.freedesktop.DBus.ObjectManager", "InterfacesRemoved")) {
+    } else if (dbus_message_is_signal(m, DBUS_INTERFACE_OBJECT_MANAGER, "InterfacesRemoved")) {
         const char *p;
         DBusMessageIter arg_i;
         DBusMessageIter element_i;
@@ -1196,13 +2355,15 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
                 device_remove(y, p);
             else if (pa_streq(iface, BLUEZ_ADAPTER_INTERFACE))
                 adapter_remove(y, p);
+            else if (pa_streq(iface, BLUEZ_MEDIA_ENDPOINT_INTERFACE))
+                remote_endpoint_remove(y, p);
 
             dbus_message_iter_next(&element_i);
         }
 
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
-    } else if (dbus_message_is_signal(m, "org.freedesktop.DBus.Properties", "PropertiesChanged")) {
+    } else if (dbus_message_is_signal(m, DBUS_INTERFACE_PROPERTIES, "PropertiesChanged")) {
         DBusMessageIter arg_i;
         const char *iface;
 
@@ -1254,6 +2415,10 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
                 return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
             parse_transport_properties(t, &arg_i);
+        } else if (pa_streq(iface, BLUEZ_MEDIA_ENDPOINT_INTERFACE)) {
+            pa_log_info("Properties changed in remote endpoint %s", dbus_message_get_path(m));
+
+            parse_remote_endpoint_properties(y, dbus_message_get_path(m), &arg_i);
         }
 
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
@@ -1271,10 +2436,14 @@ const char *pa_bluetooth_profile_to_string(pa_bluetooth_profile_t profile) {
             return "a2dp_sink";
         case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
             return "a2dp_source";
-        case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
+        case PA_BLUETOOTH_PROFILE_HSP_HS:
             return "headset_head_unit";
-        case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
+        case PA_BLUETOOTH_PROFILE_HSP_AG:
             return "headset_audio_gateway";
+        case PA_BLUETOOTH_PROFILE_HFP_HF:
+            return "handsfree_head_unit";
+        case PA_BLUETOOTH_PROFILE_HFP_AG:
+            return "handsfree_audio_gateway";
         case PA_BLUETOOTH_PROFILE_OFF:
             return "off";
     }
@@ -1282,7 +2451,38 @@ const char *pa_bluetooth_profile_to_string(pa_bluetooth_profile_t profile) {
     return NULL;
 }
 
-static const pa_a2dp_codec *a2dp_endpoint_to_a2dp_codec(const char *endpoint) {
+/* Returns true when PA has to perform attenuation, false if this is the
+ * responsibility of the peer.
+ *
+ * `peer_profile` is the profile of the peer.
+ *
+ * When the peer is in the HFP/HSP Audio Gateway role (PA is in headset role) PA
+ * has to perform attenuation on both the incoming and outgoing stream. In the
+ * HandsFree/HeadSet role both are attenuated on the peer.
+ */
+bool pa_bluetooth_profile_should_attenuate_volume(pa_bluetooth_profile_t peer_profile) {
+    switch(peer_profile) {
+        case PA_BLUETOOTH_PROFILE_A2DP_SINK:
+            return false;
+        case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
+            return true;
+        case PA_BLUETOOTH_PROFILE_HFP_HF:
+        case PA_BLUETOOTH_PROFILE_HSP_HS:
+            return false;
+        case PA_BLUETOOTH_PROFILE_HFP_AG:
+        case PA_BLUETOOTH_PROFILE_HSP_AG:
+            return true;
+        case PA_BLUETOOTH_PROFILE_OFF:
+            pa_assert_not_reached();
+    }
+    pa_assert_not_reached();
+}
+
+bool pa_bluetooth_profile_is_a2dp(pa_bluetooth_profile_t profile) {
+    return profile == PA_BLUETOOTH_PROFILE_A2DP_SINK || profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE;
+}
+
+static const pa_a2dp_endpoint_conf *a2dp_sep_to_a2dp_endpoint_conf(const char *endpoint) {
     const char *codec_name;
 
     if (pa_startswith(endpoint, A2DP_SINK_ENDPOINT "/"))
@@ -1292,14 +2492,14 @@ static const pa_a2dp_codec *a2dp_endpoint_to_a2dp_codec(const char *endpoint) {
     else
         return NULL;
 
-    return pa_bluetooth_get_a2dp_codec(codec_name);
+    return pa_bluetooth_get_a2dp_endpoint_conf(codec_name);
 }
 
 static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage *m, void *userdata) {
     pa_bluetooth_discovery *y = userdata;
     pa_bluetooth_device *d;
     pa_bluetooth_transport *t;
-    const pa_a2dp_codec *a2dp_codec = NULL;
+    const pa_a2dp_endpoint_conf *endpoint_conf = NULL;
     const char *sender, *path, *endpoint_path, *dev_path = NULL, *uuid = NULL;
     const uint8_t *config = NULL;
     int size = 0;
@@ -1383,17 +2583,17 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
 
             dbus_message_iter_get_fixed_array(&array, &config, &size);
 
-            a2dp_codec = a2dp_endpoint_to_a2dp_codec(endpoint_path);
-            pa_assert(a2dp_codec);
+            endpoint_conf = a2dp_sep_to_a2dp_endpoint_conf(endpoint_path);
+            pa_assert(endpoint_conf);
 
-            if (!a2dp_codec->is_configuration_valid(config, size))
+            if (!endpoint_conf->is_configuration_valid(config, size))
                 goto fail;
         }
 
         dbus_message_iter_next(&props);
     }
 
-    if (!a2dp_codec)
+    if (!endpoint_conf)
         goto fail2;
 
     if ((d = pa_hashmap_get(y->devices, dev_path))) {
@@ -1419,12 +2619,20 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
     dbus_message_unref(r);
 
     t = pa_bluetooth_transport_new(d, sender, path, p, config, size);
-    t->a2dp_codec = a2dp_codec;
     t->acquire = bluez5_transport_acquire_cb;
     t->release = bluez5_transport_release_cb;
+    /* A2DP Absolute Volume is optional but BlueZ unconditionally reports
+     * feature category 2, meaning supporting it is mandatory.
+     * PulseAudio can and should perform the attenuation anyway in
+     * the source role as it is the audio rendering device.
+     */
+    t->set_source_volume = pa_bluetooth_transport_set_source_volume;
+
+    pa_bluetooth_transport_reconfigure(t, &endpoint_conf->bt_codec, a2dp_transport_write, NULL);
     pa_bluetooth_transport_put(t);
 
     pa_log_debug("Transport %s available for profile %s", t->path, pa_bluetooth_profile_to_string(t->profile));
+    pa_log_info("Selected codec: %s", endpoint_conf->bt_codec.name);
 
     return NULL;
 
@@ -1432,7 +2640,7 @@ fail:
     pa_log_error("Endpoint SetConfiguration(): invalid arguments");
 
 fail2:
-    pa_assert_se(r = dbus_message_new_error(m, "org.bluez.Error.InvalidArguments", "Unable to set configuration"));
+    pa_assert_se(r = dbus_message_new_error(m, BLUEZ_ERROR_INVALID_ARGUMENTS, "Unable to set configuration"));
     return r;
 }
 
@@ -1441,7 +2649,7 @@ static DBusMessage *endpoint_select_configuration(DBusConnection *conn, DBusMess
     const char *endpoint_path;
     uint8_t *cap;
     int size;
-    const pa_a2dp_codec *a2dp_codec;
+    const pa_a2dp_endpoint_conf *endpoint_conf;
     uint8_t config[MAX_A2DP_CAPS_SIZE];
     uint8_t *config_ptr = config;
     size_t config_size;
@@ -1458,10 +2666,10 @@ static DBusMessage *endpoint_select_configuration(DBusConnection *conn, DBusMess
         goto fail;
     }
 
-    a2dp_codec = a2dp_endpoint_to_a2dp_codec(endpoint_path);
-    pa_assert(a2dp_codec);
+    endpoint_conf = a2dp_sep_to_a2dp_endpoint_conf(endpoint_path);
+    pa_assert(endpoint_conf);
 
-    config_size = a2dp_codec->fill_preferred_configuration(&y->core->default_sample_spec, cap, size, config);
+    config_size = endpoint_conf->fill_preferred_configuration(&y->core->default_sample_spec, cap, size, config);
     if (config_size == 0)
         goto fail;
 
@@ -1471,14 +2679,14 @@ static DBusMessage *endpoint_select_configuration(DBusConnection *conn, DBusMess
     return r;
 
 fail:
-    pa_assert_se(r = dbus_message_new_error(m, "org.bluez.Error.InvalidArguments", "Unable to select configuration"));
+    pa_assert_se(r = dbus_message_new_error(m, BLUEZ_ERROR_INVALID_ARGUMENTS, "Unable to select configuration"));
     return r;
 }
 
 static DBusMessage *endpoint_clear_configuration(DBusConnection *conn, DBusMessage *m, void *userdata) {
     pa_bluetooth_discovery *y = userdata;
     pa_bluetooth_transport *t;
-    DBusMessage *r;
+    DBusMessage *r = NULL;
     DBusError err;
     const char *path;
 
@@ -1495,12 +2703,14 @@ static DBusMessage *endpoint_clear_configuration(DBusConnection *conn, DBusMessa
         pa_bluetooth_transport_free(t);
     }
 
-    pa_assert_se(r = dbus_message_new_method_return(m));
+    if (!dbus_message_get_no_reply(m))
+        pa_assert_se(r = dbus_message_new_method_return(m));
 
     return r;
 
 fail:
-    pa_assert_se(r = dbus_message_new_error(m, "org.bluez.Error.InvalidArguments", "Unable to clear configuration"));
+    if (!dbus_message_get_no_reply(m))
+        pa_assert_se(r = dbus_message_new_error(m, BLUEZ_ERROR_INVALID_ARGUMENTS, "Unable to clear configuration"));
     return r;
 }
 
@@ -1541,10 +2751,10 @@ static DBusHandlerResult endpoint_handler(DBusConnection *c, DBusMessage *m, voi
 
     pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
 
-    if (!a2dp_endpoint_to_a2dp_codec(path))
+    if (!a2dp_sep_to_a2dp_endpoint_conf(path))
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
-    if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
+    if (dbus_message_is_method_call(m, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
         const char *xml = ENDPOINT_INTROSPECT_XML;
 
         pa_assert_se(r = dbus_message_new_method_return(m));
@@ -1588,18 +2798,157 @@ static void endpoint_done(pa_bluetooth_discovery *y, const char *endpoint) {
     dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), endpoint);
 }
 
-pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backend) {
+static void append_a2dp_object(DBusMessageIter *iter, const char *endpoint, const char *uuid, uint8_t codec_id, uint8_t *capabilities, uint8_t capabilities_size) {
+    const char *interface_name = BLUEZ_MEDIA_ENDPOINT_INTERFACE;
+    DBusMessageIter object, array, entry, dict;
+
+    dbus_message_iter_open_container(iter, DBUS_TYPE_DICT_ENTRY, NULL, &object);
+    pa_assert_se(dbus_message_iter_append_basic(&object, DBUS_TYPE_OBJECT_PATH, &endpoint));
+
+    dbus_message_iter_open_container(&object, DBUS_TYPE_ARRAY,
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_ARRAY_AS_STRING
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_VARIANT_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                     &array);
+
+    dbus_message_iter_open_container(&array, DBUS_TYPE_DICT_ENTRY, NULL, &entry);
+    pa_assert_se(dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &interface_name));
+
+    dbus_message_iter_open_container(&entry, DBUS_TYPE_ARRAY,
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_VARIANT_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                     &dict);
+
+    pa_dbus_append_basic_variant_dict_entry(&dict, "UUID", DBUS_TYPE_STRING, &uuid);
+    pa_dbus_append_basic_variant_dict_entry(&dict, "Codec", DBUS_TYPE_BYTE, &codec_id);
+    pa_dbus_append_basic_array_variant_dict_entry(&dict, "Capabilities", DBUS_TYPE_BYTE,
+            capabilities, capabilities_size);
+
+    dbus_message_iter_close_container(&entry, &dict);
+    dbus_message_iter_close_container(&array, &entry);
+    dbus_message_iter_close_container(&object, &array);
+    dbus_message_iter_close_container(iter, &object);
+}
+
+static DBusHandlerResult object_manager_handler(DBusConnection *c, DBusMessage *m, void *userdata) {
+    struct pa_bluetooth_discovery *y = userdata;
+    DBusMessage *r;
+    const char *path, *interface, *member;
+
+    pa_assert(y);
+
+    path = dbus_message_get_path(m);
+    interface = dbus_message_get_interface(m);
+    member = dbus_message_get_member(m);
+
+    pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
+
+    if (dbus_message_is_method_call(m, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
+        const char *xml = OBJECT_MANAGER_INTROSPECT_XML;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+        pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_STRING, &xml, DBUS_TYPE_INVALID));
+    } else if (dbus_message_is_method_call(m, DBUS_INTERFACE_OBJECT_MANAGER, "GetManagedObjects")) {
+        DBusMessageIter iter, array;
+        int i;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+
+        dbus_message_iter_init_append(r, &iter);
+        dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+                                         DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                         DBUS_TYPE_OBJECT_PATH_AS_STRING
+                                         DBUS_TYPE_ARRAY_AS_STRING
+                                         DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                         DBUS_TYPE_STRING_AS_STRING
+                                         DBUS_TYPE_ARRAY_AS_STRING
+                                         DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                         DBUS_TYPE_STRING_AS_STRING
+                                         DBUS_TYPE_VARIANT_AS_STRING
+                                         DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                         DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                         DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                         &array);
+
+        for (i = 0; i < pa_bluetooth_a2dp_endpoint_conf_count(); i++) {
+            const pa_a2dp_endpoint_conf *endpoint_conf;
+            uint8_t capabilities[MAX_A2DP_CAPS_SIZE];
+            uint8_t capabilities_size;
+            uint8_t codec_id;
+            char *endpoint;
+
+            endpoint_conf = pa_bluetooth_a2dp_endpoint_conf_iter(i);
+
+            codec_id = endpoint_conf->id.codec_id;
+
+            if (endpoint_conf->can_be_supported(false)) {
+                capabilities_size = endpoint_conf->fill_capabilities(capabilities);
+                pa_assert(capabilities_size != 0);
+                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, endpoint_conf->bt_codec.name);
+                append_a2dp_object(&array, endpoint, PA_BLUETOOTH_UUID_A2DP_SINK, codec_id,
+                        capabilities, capabilities_size);
+                pa_xfree(endpoint);
+            }
+
+            if (endpoint_conf->can_be_supported(true)) {
+                capabilities_size = endpoint_conf->fill_capabilities(capabilities);
+                pa_assert(capabilities_size != 0);
+                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, endpoint_conf->bt_codec.name);
+                append_a2dp_object(&array, endpoint, PA_BLUETOOTH_UUID_A2DP_SOURCE, codec_id,
+                        capabilities, capabilities_size);
+                pa_xfree(endpoint);
+            }
+        }
+
+        dbus_message_iter_close_container(&iter, &array);
+    } else
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(y->connection), r, NULL));
+    dbus_message_unref(r);
+
+    return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+static void object_manager_init(pa_bluetooth_discovery *y) {
+    static const DBusObjectPathVTable vtable = {
+        .message_function = object_manager_handler,
+    };
+
+    pa_assert(y);
+    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(y->connection),
+                A2DP_OBJECT_MANAGER_PATH, &vtable, y));
+}
+
+static void object_manager_done(pa_bluetooth_discovery *y) {
+    pa_assert(y);
+    dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection),
+            A2DP_OBJECT_MANAGER_PATH);
+}
+
+pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backend, bool enable_native_hsp_hs, bool enable_native_hfp_hf, bool enable_msbc) {
     pa_bluetooth_discovery *y;
     DBusError err;
     DBusConnection *conn;
     unsigned i, count;
-    const pa_a2dp_codec *a2dp_codec;
+    const pa_a2dp_endpoint_conf *endpoint_conf;
     char *endpoint;
 
+    pa_bluetooth_a2dp_codec_gst_init();
     y = pa_xnew0(pa_bluetooth_discovery, 1);
     PA_REFCNT_INIT(y);
     y->core = c;
     y->headset_backend = headset_backend;
+    y->enable_native_hsp_hs = enable_native_hsp_hs;
+    y->enable_native_hfp_hf = enable_native_hfp_hf;
+    y->enable_msbc = enable_msbc;
     y->adapters = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL,
                                       (pa_free_cb_t) adapter_free);
     y->devices = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL,
@@ -1629,16 +2978,18 @@ pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backe
     y->filter_added = true;
 
     if (pa_dbus_add_matches(conn, &err,
-            "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged'"
+            "type='signal',sender='" DBUS_SERVICE_DBUS "',interface='" DBUS_INTERFACE_DBUS "',member='NameOwnerChanged'"
             ",arg0='" BLUEZ_SERVICE "'",
-            "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.ObjectManager',member='InterfacesAdded'",
-            "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.ObjectManager',"
+            "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_OBJECT_MANAGER "',member='InterfacesAdded'",
+            "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_OBJECT_MANAGER "',"
             "member='InterfacesRemoved'",
-            "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',member='PropertiesChanged'"
+            "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_PROPERTIES "',member='PropertiesChanged'"
             ",arg0='" BLUEZ_ADAPTER_INTERFACE "'",
-            "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',member='PropertiesChanged'"
+            "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_PROPERTIES "',member='PropertiesChanged'"
             ",arg0='" BLUEZ_DEVICE_INTERFACE "'",
-            "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',member='PropertiesChanged'"
+            "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_PROPERTIES "',member='PropertiesChanged'"
+            ",arg0='" BLUEZ_MEDIA_ENDPOINT_INTERFACE "'",
+            "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_PROPERTIES "',member='PropertiesChanged'"
             ",arg0='" BLUEZ_MEDIA_TRANSPORT_INTERFACE "'",
             NULL) < 0) {
         pa_log_error("Failed to add D-Bus matches: %s", err.message);
@@ -1646,17 +2997,22 @@ pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backe
     }
     y->matches_added = true;
 
-    count = pa_bluetooth_a2dp_codec_count();
-    for (i = 0; i < count; i++) {
-        a2dp_codec = pa_bluetooth_a2dp_codec_iter(i);
+    object_manager_init(y);
 
-        endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, a2dp_codec->name);
-        endpoint_init(y, endpoint);
-        pa_xfree(endpoint);
+    count = pa_bluetooth_a2dp_endpoint_conf_count();
+    for (i = 0; i < count; i++) {
+        endpoint_conf = pa_bluetooth_a2dp_endpoint_conf_iter(i);
+        if (endpoint_conf->can_be_supported(false)) {
+            endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, endpoint_conf->bt_codec.name);
+            endpoint_init(y, endpoint);
+            pa_xfree(endpoint);
+        }
 
-        endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, a2dp_codec->name);
-        endpoint_init(y, endpoint);
-        pa_xfree(endpoint);
+        if (endpoint_conf->can_be_supported(true)) {
+            endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, endpoint_conf->bt_codec.name);
+            endpoint_init(y, endpoint);
+            pa_xfree(endpoint);
+        }
     }
 
     get_managed_objects(y);
@@ -1681,7 +3037,7 @@ pa_bluetooth_discovery* pa_bluetooth_discovery_ref(pa_bluetooth_discovery *y) {
 
 void pa_bluetooth_discovery_unref(pa_bluetooth_discovery *y) {
     unsigned i, count;
-    const pa_a2dp_codec *a2dp_codec;
+    const pa_a2dp_endpoint_conf *endpoint_conf;
     char *endpoint;
 
     pa_assert(y);
@@ -1712,34 +3068,42 @@ void pa_bluetooth_discovery_unref(pa_bluetooth_discovery *y) {
 
         if (y->matches_added)
             pa_dbus_remove_matches(pa_dbus_connection_get(y->connection),
-                "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',"
+                "type='signal',sender='" DBUS_SERVICE_DBUS "',interface='" DBUS_INTERFACE_DBUS "',member='NameOwnerChanged',"
                 "arg0='" BLUEZ_SERVICE "'",
-                "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.ObjectManager',"
+                "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_OBJECT_MANAGER "',"
                 "member='InterfacesAdded'",
-                "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.ObjectManager',"
+                "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_OBJECT_MANAGER "',"
                 "member='InterfacesRemoved'",
-                "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',"
+                "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_PROPERTIES "',"
                 "member='PropertiesChanged',arg0='" BLUEZ_ADAPTER_INTERFACE "'",
-                "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',"
+                "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_PROPERTIES "',"
                 "member='PropertiesChanged',arg0='" BLUEZ_DEVICE_INTERFACE "'",
-                "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',"
+                "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_PROPERTIES "',"
+                "member='PropertiesChanged',arg0='" BLUEZ_MEDIA_ENDPOINT_INTERFACE "'",
+                "type='signal',sender='" BLUEZ_SERVICE "',interface='" DBUS_INTERFACE_PROPERTIES "',"
                 "member='PropertiesChanged',arg0='" BLUEZ_MEDIA_TRANSPORT_INTERFACE "'",
                 NULL);
 
         if (y->filter_added)
             dbus_connection_remove_filter(pa_dbus_connection_get(y->connection), filter_cb, y);
 
-        count = pa_bluetooth_a2dp_codec_count();
+        object_manager_done(y);
+
+        count = pa_bluetooth_a2dp_endpoint_conf_count();
         for (i = 0; i < count; i++) {
-            a2dp_codec = pa_bluetooth_a2dp_codec_iter(i);
+            endpoint_conf = pa_bluetooth_a2dp_endpoint_conf_iter(i);
 
-            endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, a2dp_codec->name);
-            endpoint_done(y, endpoint);
-            pa_xfree(endpoint);
+            if (endpoint_conf->can_be_supported(false)) {
+                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, endpoint_conf->bt_codec.name);
+                endpoint_done(y, endpoint);
+                pa_xfree(endpoint);
+            }
 
-            endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, a2dp_codec->name);
-            endpoint_done(y, endpoint);
-            pa_xfree(endpoint);
+            if (endpoint_conf->can_be_supported(true)) {
+                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, endpoint_conf->bt_codec.name);
+                endpoint_done(y, endpoint);
+                pa_xfree(endpoint);
+            }
         }
 
         pa_dbus_connection_unref(y->connection);
diff --git a/src/modules/bluetooth/bluez5-util.h b/src/modules/bluetooth/bluez5-util.h
index ff172e0..4abc1ca 100755
--- a/src/modules/bluetooth/bluez5-util.h
+++ b/src/modules/bluetooth/bluez5-util.h
@@ -25,6 +25,21 @@
 
 #include "a2dp-codec-util.h"
 
+#define BLUEZ_SERVICE "org.bluez"
+#define BLUEZ_ADAPTER_INTERFACE BLUEZ_SERVICE ".Adapter1"
+#define BLUEZ_BATTERY_PROVIDER_INTERFACE BLUEZ_SERVICE ".BatteryProvider1"
+#define BLUEZ_BATTERY_PROVIDER_MANAGER_INTERFACE BLUEZ_SERVICE ".BatteryProviderManager1"
+#define BLUEZ_DEVICE_INTERFACE BLUEZ_SERVICE ".Device1"
+#define BLUEZ_MEDIA_ENDPOINT_INTERFACE BLUEZ_SERVICE ".MediaEndpoint1"
+#define BLUEZ_MEDIA_INTERFACE BLUEZ_SERVICE ".Media1"
+#define BLUEZ_MEDIA_TRANSPORT_INTERFACE BLUEZ_SERVICE ".MediaTransport1"
+#define BLUEZ_PROFILE_INTERFACE BLUEZ_SERVICE ".Profile1"
+#define BLUEZ_PROFILE_MANAGER_INTERFACE BLUEZ_SERVICE ".ProfileManager1"
+
+#define BLUEZ_ERROR_INVALID_ARGUMENTS BLUEZ_SERVICE ".Error.InvalidArguments"
+#define BLUEZ_ERROR_NOT_AVAILABLE BLUEZ_SERVICE ".Error.NotAvailable"
+#define BLUEZ_ERROR_NOT_SUPPORTED BLUEZ_SERVICE ".Error.NotSupported"
+
 #define PA_BLUETOOTH_UUID_A2DP_SOURCE "0000110a-0000-1000-8000-00805f9b34fb"
 #define PA_BLUETOOTH_UUID_A2DP_SINK   "0000110b-0000-1000-8000-00805f9b34fb"
 
@@ -39,6 +54,9 @@
 #define PA_BLUETOOTH_UUID_HFP_HF      "0000111e-0000-1000-8000-00805f9b34fb"
 #define PA_BLUETOOTH_UUID_HFP_AG      "0000111f-0000-1000-8000-00805f9b34fb"
 
+#define A2DP_MAX_GAIN 127
+#define HSP_MAX_GAIN 15
+
 typedef struct pa_bluetooth_transport pa_bluetooth_transport;
 typedef struct pa_bluetooth_device pa_bluetooth_device;
 typedef struct pa_bluetooth_adapter pa_bluetooth_adapter;
@@ -46,23 +64,34 @@ typedef struct pa_bluetooth_discovery pa_bluetooth_discovery;
 typedef struct pa_bluetooth_backend pa_bluetooth_backend;
 
 typedef enum pa_bluetooth_hook {
-    PA_BLUETOOTH_HOOK_DEVICE_CONNECTION_CHANGED,          /* Call data: pa_bluetooth_device */
-    PA_BLUETOOTH_HOOK_DEVICE_UNLINK,                      /* Call data: pa_bluetooth_device */
-    PA_BLUETOOTH_HOOK_TRANSPORT_STATE_CHANGED,            /* Call data: pa_bluetooth_transport */
-    PA_BLUETOOTH_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED,  /* Call data: pa_bluetooth_transport */
-    PA_BLUETOOTH_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED,     /* Call data: pa_bluetooth_transport */
+    PA_BLUETOOTH_HOOK_ADAPTER_UUIDS_CHANGED,            /* Call data: pa_bluetooth_adapter */
+    PA_BLUETOOTH_HOOK_DEVICE_CONNECTION_CHANGED,        /* Call data: pa_bluetooth_device */
+    PA_BLUETOOTH_HOOK_DEVICE_UNLINK,                    /* Call data: pa_bluetooth_device */
+    PA_BLUETOOTH_HOOK_DEVICE_BATTERY_LEVEL_CHANGED,     /* Call data: pa_bluetooth_device */
+    PA_BLUETOOTH_HOOK_TRANSPORT_STATE_CHANGED,          /* Call data: pa_bluetooth_transport */
+    PA_BLUETOOTH_HOOK_TRANSPORT_SOURCE_VOLUME_CHANGED,  /* Call data: pa_bluetooth_transport */
+    PA_BLUETOOTH_HOOK_TRANSPORT_SINK_VOLUME_CHANGED,    /* Call data: pa_bluetooth_transport */
     PA_BLUETOOTH_HOOK_MAX
 } pa_bluetooth_hook_t;
 
 typedef enum profile {
     PA_BLUETOOTH_PROFILE_A2DP_SINK,
     PA_BLUETOOTH_PROFILE_A2DP_SOURCE,
-    PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT,
-    PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY,
+    PA_BLUETOOTH_PROFILE_HSP_HS,
+    PA_BLUETOOTH_PROFILE_HSP_AG,
+    PA_BLUETOOTH_PROFILE_HFP_HF,
+    PA_BLUETOOTH_PROFILE_HFP_AG,
     PA_BLUETOOTH_PROFILE_OFF
 } pa_bluetooth_profile_t;
 #define PA_BLUETOOTH_PROFILE_COUNT PA_BLUETOOTH_PROFILE_OFF
 
+typedef enum pa_bluetooth_profile_status {
+  PA_BLUETOOTH_PROFILE_STATUS_INACTIVE,
+  PA_BLUETOOTH_PROFILE_STATUS_ACTIVE,
+  PA_BLUETOOTH_PROFILE_STATUS_REGISTERING,
+  PA_BLUETOOTH_PROFILE_STATUS_REGISTERED
+} pa_bluetooth_profile_status_t;
+
 typedef enum pa_bluetooth_transport_state {
     PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED,
     PA_BLUETOOTH_TRANSPORT_STATE_IDLE,
@@ -72,8 +101,9 @@ typedef enum pa_bluetooth_transport_state {
 typedef int (*pa_bluetooth_transport_acquire_cb)(pa_bluetooth_transport *t, bool optional, size_t *imtu, size_t *omtu);
 typedef void (*pa_bluetooth_transport_release_cb)(pa_bluetooth_transport *t);
 typedef void (*pa_bluetooth_transport_destroy_cb)(pa_bluetooth_transport *t);
-typedef void (*pa_bluetooth_transport_set_speaker_gain_cb)(pa_bluetooth_transport *t, uint16_t gain);
-typedef void (*pa_bluetooth_transport_set_microphone_gain_cb)(pa_bluetooth_transport *t, uint16_t gain);
+typedef pa_volume_t (*pa_bluetooth_transport_set_volume_cb)(pa_bluetooth_transport *t, pa_volume_t volume);
+typedef ssize_t (*pa_bluetooth_transport_write_cb)(pa_bluetooth_transport *t, int fd, const void* buffer, size_t size, size_t write_mtu);
+typedef int (*pa_bluetooth_transport_setsockopt_cb)(pa_bluetooth_transport *t, int fd);
 
 struct pa_bluetooth_transport {
     pa_bluetooth_device *device;
@@ -82,22 +112,25 @@ struct pa_bluetooth_transport {
     char *path;
     pa_bluetooth_profile_t profile;
 
-    uint8_t codec;
-    uint8_t *config;
+    void *config;
     size_t config_size;
 
-    const pa_a2dp_codec *a2dp_codec;
+    const pa_bt_codec *bt_codec;
+    int stream_write_type;
+    size_t last_read_size;
 
-    uint16_t microphone_gain;
-    uint16_t speaker_gain;
+    pa_volume_t source_volume;
+    pa_volume_t sink_volume;
 
     pa_bluetooth_transport_state_t state;
 
     pa_bluetooth_transport_acquire_cb acquire;
     pa_bluetooth_transport_release_cb release;
+    pa_bluetooth_transport_write_cb write;
+    pa_bluetooth_transport_setsockopt_cb setsockopt;
     pa_bluetooth_transport_destroy_cb destroy;
-    pa_bluetooth_transport_set_speaker_gain_cb set_speaker_gain;
-    pa_bluetooth_transport_set_microphone_gain_cb set_microphone_gain;
+    pa_bluetooth_transport_set_volume_cb set_sink_volume;
+    pa_bluetooth_transport_set_volume_cb set_source_volume;
     void *userdata;
 };
 
@@ -105,10 +138,14 @@ struct pa_bluetooth_device {
     pa_bluetooth_discovery *discovery;
     pa_bluetooth_adapter *adapter;
 
+    bool enable_hfp_hf;
     bool properties_received;
     bool tried_to_link_with_adapter;
     bool valid;
     bool autodetect_mtu;
+    bool codec_switching_in_progress;
+    bool avrcp_absolute_volume;
+    uint32_t output_rate_refresh_interval_ms;
 
     /* Device information */
     char *path;
@@ -117,18 +154,28 @@ struct pa_bluetooth_device {
     char *address;
     uint32_t class_of_device;
     pa_hashmap *uuids; /* char* -> char* (hashmap-as-a-set) */
+    /* pa_a2dp_codec_id* -> pa_hashmap ( char* (remote endpoint) -> struct a2dp_codec_capabilities* ) */
+    pa_hashmap *a2dp_sink_endpoints;
+    pa_hashmap *a2dp_source_endpoints;
 
     pa_bluetooth_transport *transports[PA_BLUETOOTH_PROFILE_COUNT];
 
     pa_time_event *wait_for_profiles_timer;
+
+    bool has_battery_level;
+    uint8_t battery_level;
+    const char *battery_source;
 };
 
 struct pa_bluetooth_adapter {
     pa_bluetooth_discovery *discovery;
     char *path;
     char *address;
+    pa_hashmap *uuids; /* char* -> char* (hashmap-as-a-set) */
 
     bool valid;
+    bool application_registered;
+    bool battery_provider_registered;
 };
 
 #ifdef HAVE_BLUEZ_5_OFONO_HEADSET
@@ -142,26 +189,37 @@ static inline void pa_bluetooth_ofono_backend_free(pa_bluetooth_backend *b) {}
 #endif
 
 #ifdef HAVE_BLUEZ_5_NATIVE_HEADSET
-pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_hs_role);
+pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_shared_profiles);
 void pa_bluetooth_native_backend_free(pa_bluetooth_backend *b);
-void pa_bluetooth_native_backend_enable_hs_role(pa_bluetooth_backend *b, bool enable_hs_role);
+void pa_bluetooth_native_backend_enable_shared_profiles(pa_bluetooth_backend *b, bool enable);
 #else
-static inline pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_hs_role) {
+static inline pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_shared_profiles) {
     return NULL;
 }
 static inline void pa_bluetooth_native_backend_free(pa_bluetooth_backend *b) {}
-static inline void pa_bluetooth_native_backend_enable_hs_role(pa_bluetooth_backend *b, bool enable_hs_role) {}
+static inline void pa_bluetooth_native_backend_enable_shared_profiles(pa_bluetooth_backend *b, bool enable) {}
 #endif
 
+pa_bluetooth_profile_status_t profile_status_get(pa_bluetooth_discovery *y, pa_bluetooth_profile_t profile);
+void profile_status_set(pa_bluetooth_discovery *y, pa_bluetooth_profile_t profile, pa_bluetooth_profile_status_t status);
+
 pa_bluetooth_transport *pa_bluetooth_transport_new(pa_bluetooth_device *d, const char *owner, const char *path,
                                                    pa_bluetooth_profile_t p, const uint8_t *config, size_t size);
 
+void pa_bluetooth_transport_reconfigure(pa_bluetooth_transport *t, const pa_bt_codec *bt_codec,
+                                        pa_bluetooth_transport_write_cb write_cb, pa_bluetooth_transport_setsockopt_cb setsockopt_cb);
+
 void pa_bluetooth_transport_set_state(pa_bluetooth_transport *t, pa_bluetooth_transport_state_t state);
 void pa_bluetooth_transport_put(pa_bluetooth_transport *t);
 void pa_bluetooth_transport_unlink(pa_bluetooth_transport *t);
 void pa_bluetooth_transport_free(pa_bluetooth_transport *t);
+void pa_bluetooth_transport_load_a2dp_sink_volume(pa_bluetooth_transport *t);
 
+bool pa_bluetooth_device_supports_profile(const pa_bluetooth_device *device, pa_bluetooth_profile_t profile);
 bool pa_bluetooth_device_any_transport_connected(const pa_bluetooth_device *d);
+bool pa_bluetooth_device_switch_codec(pa_bluetooth_device *device, pa_bluetooth_profile_t profile, pa_hashmap *capabilities_hashmap, const pa_a2dp_endpoint_conf *endpoint_conf, void (*codec_switch_cb)(bool, pa_bluetooth_profile_t profile, void *), void *userdata);
+void pa_bluetooth_device_report_battery_level(pa_bluetooth_device *d, uint8_t level, const char *reporting_source);
+void pa_bluetooth_device_deregister_battery(pa_bluetooth_device *d);
 
 pa_bluetooth_device* pa_bluetooth_discovery_get_device_by_path(pa_bluetooth_discovery *y, const char *path);
 pa_bluetooth_device* pa_bluetooth_discovery_get_device_by_address(pa_bluetooth_discovery *y, const char *remote, const char *local);
@@ -169,6 +227,8 @@ pa_bluetooth_device* pa_bluetooth_discovery_get_device_by_address(pa_bluetooth_d
 pa_hook* pa_bluetooth_discovery_hook(pa_bluetooth_discovery *y, pa_bluetooth_hook_t hook);
 
 const char *pa_bluetooth_profile_to_string(pa_bluetooth_profile_t profile);
+bool pa_bluetooth_profile_should_attenuate_volume(pa_bluetooth_profile_t profile);
+bool pa_bluetooth_profile_is_a2dp(pa_bluetooth_profile_t profile);
 
 static inline bool pa_bluetooth_uuid_is_hsp_hs(const char *uuid) {
     return pa_streq(uuid, PA_BLUETOOTH_UUID_HSP_HS) || pa_streq(uuid, PA_BLUETOOTH_UUID_HSP_HS_ALT);
@@ -178,8 +238,45 @@ static inline bool pa_bluetooth_uuid_is_hsp_hs(const char *uuid) {
 #define HEADSET_BACKEND_NATIVE 1
 #define HEADSET_BACKEND_AUTO 2
 
-pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *core, int headset_backend);
+pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *core, int headset_backend, bool enable_native_hsp_hs, bool enable_native_hfp_hf, bool enable_msbc);
 pa_bluetooth_discovery* pa_bluetooth_discovery_ref(pa_bluetooth_discovery *y);
 void pa_bluetooth_discovery_unref(pa_bluetooth_discovery *y);
 void pa_bluetooth_discovery_set_ofono_running(pa_bluetooth_discovery *y, bool is_running);
+bool pa_bluetooth_discovery_get_enable_native_hsp_hs(pa_bluetooth_discovery *y);
+bool pa_bluetooth_discovery_get_enable_native_hfp_hf(pa_bluetooth_discovery *y);
+bool pa_bluetooth_discovery_get_enable_msbc(pa_bluetooth_discovery *y);
+
+void send_player_properties_changed_event(pa_bluetooth_discovery *y, const char *value);
+
+/** Port type. New types can be added in the future, so applications should
+ * gracefully handle situations where a type identifier doesn't match any item
+ * in this enumeration. \since 14.0 */
+typedef enum pa_device_port_type {
+    PA_DEVICE_PORT_TYPE_UNKNOWN = 0,
+    PA_DEVICE_PORT_TYPE_AUX = 1,
+    PA_DEVICE_PORT_TYPE_SPEAKER = 2,
+    PA_DEVICE_PORT_TYPE_HEADPHONES = 3,
+    PA_DEVICE_PORT_TYPE_LINE = 4,
+    PA_DEVICE_PORT_TYPE_MIC = 5,
+    PA_DEVICE_PORT_TYPE_HEADSET = 6,
+    PA_DEVICE_PORT_TYPE_HANDSET = 7,
+    PA_DEVICE_PORT_TYPE_EARPIECE = 8,
+    PA_DEVICE_PORT_TYPE_SPDIF = 9,
+    PA_DEVICE_PORT_TYPE_HDMI = 10,
+    PA_DEVICE_PORT_TYPE_TV = 11,
+    PA_DEVICE_PORT_TYPE_RADIO = 12,
+    PA_DEVICE_PORT_TYPE_VIDEO = 13,
+    PA_DEVICE_PORT_TYPE_USB = 14,
+    PA_DEVICE_PORT_TYPE_BLUETOOTH = 15,
+    PA_DEVICE_PORT_TYPE_PORTABLE = 16,
+    PA_DEVICE_PORT_TYPE_HANDSFREE = 17,
+    PA_DEVICE_PORT_TYPE_CAR = 18,
+    PA_DEVICE_PORT_TYPE_HIFI = 19,
+    PA_DEVICE_PORT_TYPE_PHONE = 20,
+    PA_DEVICE_PORT_TYPE_NETWORK = 21,
+    PA_DEVICE_PORT_TYPE_ANALOG = 22,
+} pa_device_port_type_t;
+
+#define PA_PROP_BLUETOOTH_CODEC "bluetooth.codec"
+
 #endif
diff --git a/src/modules/bluetooth/bt-codec-api.h b/src/modules/bluetooth/bt-codec-api.h
new file mode 100755
index 0000000..900ffe9
--- /dev/null
+++ b/src/modules/bluetooth/bt-codec-api.h
@@ -0,0 +1,67 @@
+#pragma once
+
+/***
+  This file is part of PulseAudio.
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#include <pulsecore/core.h>
+
+typedef struct pa_bt_codec {
+    /* Unique name of the codec, lowercase and without whitespaces, used for
+     * constructing identifier, D-Bus paths, ... */
+    const char *name;
+    /* Human readable codec description */
+    const char *description;
+
+    /* Initialize codec, returns codec info data and set sample_spec,
+     * for_encoding is true when codec_info is used for encoding,
+     * for_backchannel is true when codec_info is used for backchannel */
+    void *(*init)(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec, pa_core *core);
+    /* Deinitialize and release codec info data in codec_info */
+    void (*deinit)(void *codec_info);
+    /* Reset internal state of codec info data in codec_info, returns
+     * a negative value on failure */
+    int (*reset)(void *codec_info);
+
+    /* Get read block size for codec, it is minimal size of buffer
+     * needed to decode read_link_mtu bytes of encoded data */
+    size_t (*get_read_block_size)(void *codec_info, size_t read_link_mtu);
+    /* Get write block size for codec, it is maximal size of buffer
+     * which can produce at most write_link_mtu bytes of encoded data */
+    size_t (*get_write_block_size)(void *codec_info, size_t write_link_mtu);
+    /* Get encoded block size for codec to hold one encoded frame.
+     * Note HFP mSBC codec encoded block may not fit into one MTU and is sent out in chunks. */
+    size_t (*get_encoded_block_size)(void *codec_info, size_t input_size);
+
+    /* Reduce encoder bitrate for codec, returns new write block size or zero
+     * if not changed, called when socket is not accepting encoded data fast
+     * enough */
+    size_t (*reduce_encoder_bitrate)(void *codec_info, size_t write_link_mtu);
+
+    /* Increase encoder bitrate for codec, returns new write block size or zero
+     * if not changed, called periodically when socket is keeping up with
+     * encoded data */
+    size_t (*increase_encoder_bitrate)(void *codec_info, size_t write_link_mtu);
+
+    /* Encode input_buffer of input_size to output_buffer of output_size,
+     * returns size of filled ouput_buffer and set processed to size of
+     * processed input_buffer */
+    size_t (*encode_buffer)(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed);
+    /* Decode input_buffer of input_size to output_buffer of output_size,
+     * returns size of filled ouput_buffer and set processed to size of
+     * processed input_buffer */
+    size_t (*decode_buffer)(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed);
+} pa_bt_codec;
diff --git a/src/modules/bluetooth/bt-codec-cvsd.c b/src/modules/bluetooth/bt-codec-cvsd.c
new file mode 100755
index 0000000..fe229d2
--- /dev/null
+++ b/src/modules/bluetooth/bt-codec-cvsd.c
@@ -0,0 +1,123 @@
+/***
+  This file is part of PulseAudio.
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulsecore/core.h>
+#include "bt-codec-api.h"
+
+typedef struct codec_info {
+    pa_sample_spec sample_spec;
+} codec_info_t;
+
+static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec, pa_core *core) {
+    codec_info_t *info;
+
+    info = pa_xnew0(codec_info_t, 1);
+
+    info->sample_spec.format = PA_SAMPLE_S16LE;
+    info->sample_spec.channels = 1;
+    info->sample_spec.rate = 8000;
+
+    *sample_spec = info->sample_spec;
+
+    return info;
+}
+
+static void deinit(void *codec_info) {
+    pa_xfree(codec_info);
+}
+
+static int reset(void *codec_info) {
+    return 0;
+}
+
+static size_t get_block_size(void *codec_info, size_t link_mtu) {
+    codec_info_t *info = (codec_info_t *) codec_info;
+    size_t block_size = link_mtu;
+
+    if (!pa_frame_aligned(block_size, &info->sample_spec)) {
+        pa_log_debug("Got invalid block size: %lu, rounding down", block_size);
+        block_size = pa_frame_align(block_size, &info->sample_spec);
+    }
+
+    return block_size;
+}
+
+static size_t get_encoded_block_size(void *codec_info, size_t input_size) {
+    codec_info_t *info = (codec_info_t *) codec_info;
+
+    /* input size should be aligned to sample spec */
+    pa_assert_fp(pa_frame_aligned(input_size, &info->sample_spec));
+
+    return input_size;
+}
+
+static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
+    return 0;
+}
+
+static size_t increase_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
+    return 0;
+}
+
+static size_t encode_buffer(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    pa_assert(input_size <= output_size);
+
+    memcpy(output_buffer, input_buffer, input_size);
+    *processed = input_size;
+
+    return input_size;
+}
+
+static size_t decode_buffer(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    codec_info_t *info = (codec_info_t *) codec_info;
+
+    *processed = input_size;
+
+    /* In some rare occasions, we might receive packets of a very strange
+     * size. This could potentially be possible if the SCO packet was
+     * received partially over-the-air, or more probably due to hardware
+     * issues in our Bluetooth adapter. In these cases, in order to avoid
+     * an assertion failure due to unaligned data, just discard the whole
+     * packet */
+    if (!pa_frame_aligned(input_size, &info->sample_spec)) {
+        pa_log_warn("SCO packet received of unaligned size: %zu", input_size);
+        return 0;
+    }
+
+    memcpy(output_buffer, input_buffer, input_size);
+
+    return input_size;
+}
+
+/* dummy passthrough codec used with HSP/HFP CVSD */
+const pa_bt_codec pa_bt_codec_cvsd = {
+    .name = "CVSD",
+    .description = "CVSD",
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_block_size,
+    .get_write_block_size = get_block_size,
+    .get_encoded_block_size = get_encoded_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate,
+    .increase_encoder_bitrate = increase_encoder_bitrate,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
diff --git a/src/modules/bluetooth/bt-codec-msbc.c b/src/modules/bluetooth/bt-codec-msbc.c
new file mode 100755
index 0000000..7df837e
--- /dev/null
+++ b/src/modules/bluetooth/bt-codec-msbc.c
@@ -0,0 +1,317 @@
+/***
+  This file is part of PulseAudio.
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulsecore/core.h>
+#include "bt-codec-api.h"
+
+#include "bt-codec-msbc.h"
+#include <sbc/sbc.h>
+
+typedef struct sbc_info {
+    sbc_t sbc;                           /* Codec data */
+    size_t codesize, frame_length;       /* SBC Codesize, frame_length. We simply cache those values here */
+    uint8_t msbc_seq:2;                  /* mSBC packet sequence number, 2 bits only */
+
+    uint16_t msbc_push_offset;
+    uint8_t input_buffer[MSBC_PACKET_SIZE];                        /* Codec transfer buffer */
+
+    pa_sample_spec sample_spec;
+} sbc_info_t;
+
+static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec, pa_core *core) {
+    struct sbc_info *info;
+    int ret;
+
+    info = pa_xnew0(struct sbc_info, 1);
+
+    ret = sbc_init_msbc(&info->sbc, 0);
+    if (ret != 0) {
+        pa_xfree(info);
+        pa_log_error("mSBC initialization failed: %d", ret);
+        return NULL;
+    }
+
+    info->sbc.endian = SBC_LE;
+
+    info->codesize = sbc_get_codesize(&info->sbc);
+    info->frame_length = sbc_get_frame_length(&info->sbc);
+    pa_log_info("mSBC codesize=%d, frame_length=%d",
+                (int)info->codesize,
+                (int)info->frame_length);
+
+    info->sample_spec.format = PA_SAMPLE_S16LE;
+    info->sample_spec.channels = 1;
+    info->sample_spec.rate = 16000;
+
+    pa_assert(pa_frame_aligned(info->codesize, &info->sample_spec));
+
+    *sample_spec = info->sample_spec;
+
+    return info;
+}
+
+static void deinit(void *codec_info) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+
+    sbc_finish(&sbc_info->sbc);
+    pa_xfree(sbc_info);
+}
+
+static int reset(void *codec_info) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    int ret;
+
+    /* SBC library release 1.5 has a bug in sbc_reinit_msbc:
+     * it forgets to restore priv->msbc flag after clearing priv content.
+     * This causes decoder assertion on first call since codesize would be
+     * different from expected for mSBC configuration.
+     *
+     * Do not use sbc_reinit_msbc until it is fixed.
+     */
+
+    sbc_finish(&sbc_info->sbc);
+    ret = sbc_init_msbc(&sbc_info->sbc, 0);
+    if (ret != 0) {
+        pa_xfree(sbc_info);
+        pa_log_error("mSBC initialization failed: %d", ret);
+        return -1;
+    }
+
+    sbc_info->sbc.endian = SBC_LE;
+
+    sbc_info->msbc_seq = 0;
+    sbc_info->msbc_push_offset = 0;
+
+    return 0;
+}
+
+static size_t get_read_block_size(void *codec_info, size_t link_mtu) {
+    struct sbc_info *info = (struct sbc_info *) codec_info;
+    size_t block_size = info->codesize;
+
+    /* this never happens as sbc_info->codesize is always frame-aligned */
+    if (!pa_frame_aligned(block_size, &info->sample_spec)) {
+        pa_log_debug("Got invalid block size: %lu, rounding down", block_size);
+        block_size = pa_frame_align(block_size, &info->sample_spec);
+    }
+
+    return block_size;
+}
+
+static size_t get_write_block_size(void *codec_info, size_t link_mtu) {
+    struct sbc_info *info = (struct sbc_info *) codec_info;
+    return info->codesize;
+}
+
+static size_t get_encoded_block_size(void *codec_info, size_t input_size) {
+    struct sbc_info *info = (struct sbc_info *) codec_info;
+    size_t encoded_size = MSBC_PACKET_SIZE;
+
+    /* input size should be aligned to write block size */
+    pa_assert_fp(input_size % info->codesize == 0);
+
+    return encoded_size * (input_size / info->codesize);
+}
+
+static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
+    return 0;
+}
+
+static size_t increase_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
+    return 0;
+}
+
+static size_t encode_buffer(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    struct msbc_frame *frame;
+    uint8_t seq;
+    ssize_t encoded;
+    ssize_t written;
+
+    pa_assert(input_size == sbc_info->codesize);
+
+    /* must be room to render packet */
+    pa_assert(output_size >= MSBC_PACKET_SIZE);
+
+    frame = (struct msbc_frame *)output_buffer;
+    seq = sbc_info->msbc_seq++;
+    frame->hdr.id0 = MSBC_H2_ID0;
+    frame->hdr.id1.s.id1 = MSBC_H2_ID1;
+    if (seq & 0x02)
+        frame->hdr.id1.s.sn1 = 3;
+    else
+        frame->hdr.id1.s.sn1 = 0;
+    if (seq & 0x01)
+        frame->hdr.id1.s.sn0 = 3;
+    else
+        frame->hdr.id1.s.sn0 = 0;
+
+    encoded = sbc_encode(&sbc_info->sbc,
+                         input_buffer, input_size,
+                         frame->payload, MSBC_FRAME_SIZE,
+                         &written);
+
+    frame->padding = 0x00;
+
+    if (PA_UNLIKELY(encoded <= 0)) {
+        pa_log_error("SBC encoding error (%li) for input size %lu, SBC codesize %lu",
+                    (long) encoded, input_size, sbc_get_codesize(&sbc_info->sbc));
+
+        if (encoded < 0) {
+            *processed = 0;
+            return -1;
+        } else {
+            *processed = input_size;
+            return 0;
+        }
+    }
+
+    pa_assert_fp((size_t) encoded == sbc_info->codesize);
+    pa_assert_fp((size_t) written == sbc_info->frame_length);
+
+    *processed = encoded;
+
+    return MSBC_PACKET_SIZE;
+}
+
+static inline bool is_all_zero(const uint8_t *ptr, size_t len) {
+    size_t i;
+
+    for (i = 0; i < len; ++i)
+        if (ptr[i] != 0)
+            return false;
+
+    return true;
+}
+
+/*
+ * We build a msbc frame up in the sbc_info buffer until we have a whole one
+ */
+static struct msbc_frame *msbc_find_frame(struct sbc_info *si, ssize_t *len,
+                                          const uint8_t *buf, int *pseq)
+{
+    int i;
+    uint8_t *p = si->input_buffer;
+
+    /* skip input if it has all zero bytes
+     * this could happen with older kernels inserting all-zero blocks
+     * inside otherwise valid mSBC stream */
+    if (*len > 0 && is_all_zero(buf, *len))
+        *len = 0;
+
+    for (i = 0; i < *len; i++) {
+        union msbc_h2_id1 id1;
+
+        if (si->msbc_push_offset == 0) {
+            if (buf[i] != MSBC_H2_ID0)
+                continue;
+        } else if (si->msbc_push_offset == 1) {
+            id1.b = buf[i];
+
+            if (id1.s.id1 != MSBC_H2_ID1)
+                goto error;
+            if (id1.s.sn0 != 3 && id1.s.sn0 != 0)
+                goto error;
+            if (id1.s.sn1 != 3 && id1.s.sn1 != 0)
+                goto error;
+        } else if (si->msbc_push_offset == 2) {
+            if (buf[i] != MSBC_SYNC_BYTE)
+                goto error;
+        }
+        p[si->msbc_push_offset++] = buf[i];
+
+        if (si->msbc_push_offset == MSBC_PACKET_SIZE) {
+            id1.b = p[1];
+            *pseq = (id1.s.sn0 & 0x1) | (id1.s.sn1 & 0x2);
+            si->msbc_push_offset = 0;
+            *len = *len - i;
+            return (struct msbc_frame *)p;
+        }
+        continue;
+
+        error:
+        si->msbc_push_offset = 0;
+    }
+    *len = 0;
+    return NULL;
+}
+
+static size_t decode_buffer(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    ssize_t remaining;
+    ssize_t decoded;
+    size_t written = 0;
+    struct msbc_frame *frame;
+    int seq;
+
+    remaining = input_size;
+    frame = msbc_find_frame(sbc_info, &remaining, input_buffer, &seq);
+
+    /* only process when we have a full frame */
+    if (!frame) {
+        *processed = input_size - remaining;
+        return 0;
+    }
+
+    uint8_t lost_packets = (4 + seq - sbc_info->msbc_seq++) % 4;
+
+    if (lost_packets) {
+        pa_log_debug("Lost %d input audio packet(s)", lost_packets);
+        sbc_info->msbc_seq = seq + 1;
+    }
+
+    decoded = sbc_decode(&sbc_info->sbc, frame->payload, MSBC_FRAME_SIZE, output_buffer, output_size, &written);
+
+    /* now we've consumed the sbc_info buffer, start a new one with
+     * the partial frame we have */
+    if (remaining > 0)
+        msbc_find_frame(sbc_info, &remaining, input_buffer + input_size - remaining, &seq);
+
+    pa_assert_fp(remaining == 0);
+
+    if (PA_UNLIKELY(decoded <= 0)) {
+        pa_log_error("mSBC decoding error (%li)", (long) decoded);
+        pa_silence_memory(output_buffer, sbc_info->codesize, &sbc_info->sample_spec);
+        decoded = sbc_info->frame_length;
+        written = sbc_info->codesize;
+    }
+
+    pa_assert_fp((size_t)decoded == sbc_info->frame_length);
+    pa_assert_fp((size_t)written == sbc_info->codesize);
+
+    *processed = input_size - remaining;
+    return written;
+}
+
+/* Modified SBC codec for HFP Wideband Speech*/
+const pa_bt_codec pa_bt_codec_msbc = {
+    .name = "mSBC",
+    .description = "mSBC",
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_read_block_size,
+    .get_write_block_size = get_write_block_size,
+    .get_encoded_block_size = get_encoded_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate,
+    .increase_encoder_bitrate = increase_encoder_bitrate,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
diff --git a/src/modules/bluetooth/bt-codec-msbc.h b/src/modules/bluetooth/bt-codec-msbc.h
new file mode 100755
index 0000000..3236ca1
--- /dev/null
+++ b/src/modules/bluetooth/bt-codec-msbc.h
@@ -0,0 +1,35 @@
+#pragma once
+
+/*
+ * Parameters for use with mSBC over eSCO link
+ */
+
+#define MSBC_H2_ID0	0x01
+#define MSBC_H2_ID1	0x08
+#define MSBC_FRAME_SIZE	57
+
+#define MSBC_SYNC_BYTE	0xad
+
+struct msbc_h2_id1_s {
+    uint8_t id1:4;
+    uint8_t sn0:2;
+    uint8_t sn1:2;
+} __attribute__ ((packed));
+
+union msbc_h2_id1 {
+    struct msbc_h2_id1_s s;
+    uint8_t b;
+};
+
+struct msbc_h2_header {
+    uint8_t id0;
+    union msbc_h2_id1 id1;
+} __attribute__ ((packed));
+
+struct msbc_frame {
+    struct msbc_h2_header hdr;
+    uint8_t payload[MSBC_FRAME_SIZE];
+    uint8_t padding;		/* must be zero */
+} __attribute__ ((packed));
+
+#define MSBC_PACKET_SIZE	sizeof(struct msbc_frame)
diff --git a/src/modules/bluetooth/module-bluetooth-policy.c b/src/modules/bluetooth/module-bluetooth-policy.c
index 0a6d59d..40a241b 100755
--- a/src/modules/bluetooth/module-bluetooth-policy.c
+++ b/src/modules/bluetooth/module-bluetooth-policy.c
@@ -38,13 +38,12 @@ PA_MODULE_LOAD_ONCE(true);
 PA_MODULE_USAGE(
         "auto_switch=<Switch between hsp and a2dp profile? (0 - never, 1 - media.role=phone, 2 - heuristic> "
         "a2dp_source=<Handle a2dp_source card profile (sink role)?> "
-        "ag=<Handle headset_audio_gateway card profile (headset role)?> ");
+        "ag=<Handle headset_audio_gateway or handsfree_audio_gateway card profile (headset role)?> ");
 
 static const char* const valid_modargs[] = {
     "auto_switch",
     "a2dp_source",
     "ag",
-    "hfgw",
     NULL
 };
 
@@ -87,7 +86,7 @@ static pa_hook_result_t source_put_hook_callback(pa_core *c, pa_source *source,
 
     if (u->enable_a2dp_source && pa_streq(s, "a2dp_source"))
         role = "music";
-    else if (u->enable_ag && pa_streq(s, "headset_audio_gateway"))
+    else if (u->enable_ag && (pa_streq(s, "headset_audio_gateway") || pa_streq(s, "handsfree_audio_gateway")))
         role = "phone";
     else {
         pa_log_debug("Profile %s cannot be selected for loopback", s);
@@ -126,7 +125,7 @@ static pa_hook_result_t sink_put_hook_callback(pa_core *c, pa_sink *sink, void *
     if (!s)
         return PA_HOOK_OK;
 
-    if (u->enable_ag && pa_streq(s, "headset_audio_gateway"))
+    if (u->enable_ag && (pa_streq(s, "headset_audio_gateway") || pa_streq(s, "handsfree_audio_gateway")))
         role = "phone";
     else {
         pa_log_debug("Profile %s cannot be selected for loopback", s);
@@ -157,7 +156,7 @@ static void card_set_profile(struct userdata *u, pa_card *card, bool revert_to_a
             if (!pa_streq(profile->name, "a2dp_sink"))
                 continue;
         } else {
-            if (!pa_streq(profile->name, "headset_head_unit"))
+            if (!pa_streq(profile->name, "headset_head_unit") && !pa_streq(profile->name, "handsfree_head_unit"))
                 continue;
         }
 
@@ -191,8 +190,8 @@ static void switch_profile(pa_card *card, bool revert_to_a2dp, void *userdata) {
         if (!pa_hashmap_remove(u->will_need_revert_card_map, card))
             return;
 
-        /* Skip card if does not have active hsp profile */
-        if (!pa_streq(card->active_profile->name, "headset_head_unit"))
+        /* Skip card if does not have active headset profile */
+        if (!pa_streq(card->active_profile->name, "headset_head_unit") && !pa_streq(card->active_profile->name, "handsfree_head_unit"))
             return;
 
         /* Skip card if already has active a2dp profile */
@@ -203,8 +202,8 @@ static void switch_profile(pa_card *card, bool revert_to_a2dp, void *userdata) {
         if (!pa_streq(card->active_profile->name, "a2dp_sink"))
             return;
 
-        /* Skip card if already has active hsp profile */
-        if (pa_streq(card->active_profile->name, "headset_head_unit"))
+        /* Skip card if already has active headset profile */
+        if (pa_streq(card->active_profile->name, "headset_head_unit") || pa_streq(card->active_profile->name, "handsfree_head_unit"))
             return;
     }
 
@@ -359,7 +358,9 @@ static pa_hook_result_t profile_available_hook_callback(pa_core *c, pa_card_prof
         return PA_HOOK_OK;
 
     /* Do not automatically switch profiles for headsets, just in case */
-    if (pa_streq(profile->name, "a2dp_sink") || pa_streq(profile->name, "headset_head_unit"))
+    if (pa_streq(profile->name, "a2dp_sink") ||
+        pa_streq(profile->name, "headset_head_unit") ||
+        pa_streq(profile->name, "handsfree_head_unit"))
         return PA_HOOK_OK;
 
     is_active_profile = card->active_profile == profile;
diff --git a/src/modules/bluetooth/module-bluez5-device.c b/src/modules/bluetooth/module-bluez5-device.c
index cff1cd6..cc302b7 100755
--- a/src/modules/bluetooth/module-bluez5-device.c
+++ b/src/modules/bluetooth/module-bluez5-device.c
@@ -36,6 +36,8 @@
 #include <pulsecore/core-rtclock.h>
 #include <pulsecore/core-util.h>
 #include <pulsecore/i18n.h>
+//#include <pulsecore/json.h>
+//#include <pulsecore/message-handler.h>
 #include <pulsecore/module.h>
 #include <pulsecore/modargs.h>
 #include <pulsecore/poll.h>
@@ -44,7 +46,12 @@
 #include <pulsecore/socket-util.h>
 #include <pulsecore/thread.h>
 #include <pulsecore/thread-mq.h>
+
+#ifdef USE_SMOOTHER_2
+#include <pulsecore/time-smoother_2.h>
+#else
 #include <pulsecore/time-smoother.h>
+#endif
 
 #include "a2dp-codecs.h"
 #include "a2dp-codec-util.h"
@@ -54,19 +61,23 @@ PA_MODULE_AUTHOR("Joo Paulo Rechi Vita");
 PA_MODULE_DESCRIPTION("BlueZ 5 Bluetooth audio sink and source");
 PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(false);
-PA_MODULE_USAGE("path=<device object path>"
-                "autodetect_mtu=<boolean>");
+PA_MODULE_USAGE(
+    "path=<device object path>"
+    "autodetect_mtu=<boolean>"
+    "output_rate_refresh_interval_ms=<interval between attempts to improve output rate in milliseconds>"
+    "avrcp_absolute_volume=<synchronize volume with peer, true by default>"
+);
 
 #define FIXED_LATENCY_PLAYBACK_A2DP (25 * PA_USEC_PER_MSEC)
 #define FIXED_LATENCY_PLAYBACK_SCO  (25 * PA_USEC_PER_MSEC)
 #define FIXED_LATENCY_RECORD_A2DP   (25 * PA_USEC_PER_MSEC)
 #define FIXED_LATENCY_RECORD_SCO    (25 * PA_USEC_PER_MSEC)
 
-#define HSP_MAX_GAIN 15
-
 static const char* const valid_modargs[] = {
     "path",
     "autodetect_mtu",
+    "output_rate_refresh_interval_ms",
+    "avrcp_absolute_volume",
     NULL
 };
 
@@ -97,9 +108,13 @@ struct userdata {
     pa_core *core;
 
     pa_hook_slot *device_connection_changed_slot;
+    pa_hook_slot *device_battery_level_changed_slot;
     pa_hook_slot *transport_state_changed_slot;
-    pa_hook_slot *transport_speaker_gain_changed_slot;
-    pa_hook_slot *transport_microphone_gain_changed_slot;
+    pa_hook_slot *transport_sink_volume_changed_slot;
+    pa_hook_slot *transport_source_volume_changed_slot;
+
+    pa_hook_slot *sink_volume_changed_slot;
+    pa_hook_slot *source_volume_changed_slot;
 
     pa_bluetooth_discovery *discovery;
     pa_bluetooth_device *device;
@@ -121,7 +136,6 @@ struct userdata {
     bluetooth_msg *msg;
 
     int stream_fd;
-    int stream_write_type;
     size_t read_link_mtu;
     size_t write_link_mtu;
     size_t read_block_size;
@@ -129,20 +143,29 @@ struct userdata {
     uint64_t read_index;
     uint64_t write_index;
     pa_usec_t started_at;
+
+#ifdef USE_SMOOTHER_2
+    pa_smoother_2 *read_smoother;
+#else
     pa_smoother *read_smoother;
+#endif
+
     pa_memchunk write_memchunk;
 
-    const pa_a2dp_codec *a2dp_codec;
+    const pa_bt_codec *bt_codec;
 
     void *encoder_info;
     pa_sample_spec encoder_sample_spec;
     void *encoder_buffer;                        /* Codec transfer buffer */
     size_t encoder_buffer_size;                  /* Size of the buffer */
+    size_t encoder_buffer_used;                  /* Used space in the buffer */
 
     void *decoder_info;
     pa_sample_spec decoder_sample_spec;
     void *decoder_buffer;                        /* Codec transfer buffer */
     size_t decoder_buffer_size;                  /* Size of the buffer */
+
+    bool message_handler_registered;
 };
 
 typedef enum pa_bluetooth_form_factor {
@@ -175,8 +198,8 @@ static pa_bluetooth_form_factor_t form_factor_from_class(uint32_t class_of_devic
     };
 
     /*
-     * See Bluetooth Assigned Numbers:
-     * https://www.bluetooth.org/Technical/AssignedNumbers/baseband.htm
+     * See Bluetooth Assigned Numbers for Baseband
+     * https://www.bluetooth.com/specifications/assigned-numbers/baseband/
      */
     major = (class_of_device >> 8) & 0x1F;
     minor = (class_of_device >> 2) & 0x3F;
@@ -246,184 +269,151 @@ static void connect_ports(struct userdata *u, void *new_data, pa_direction_t dir
     }
 }
 
-/* Run from IO thread */
-static int sco_process_render(struct userdata *u) {
-    ssize_t l;
-    pa_memchunk memchunk;
-    int saved_errno;
-
+static bool bt_prepare_encoder_buffer(struct userdata *u)
+{
+    size_t encoded_size, reserved_size, encoded_frames;
     pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT ||
-                u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-    pa_assert(u->sink);
-
-    pa_sink_render_full(u->sink, u->write_block_size, &memchunk);
-
-    pa_assert(memchunk.length == u->write_block_size);
-
-    for (;;) {
-        const void *p;
-
-        /* Now write that data to the socket. The socket is of type
-         * SEQPACKET, and we generated the data of the MTU size, so this
-         * should just work. */
-
-        p = (const uint8_t *) pa_memblock_acquire_chunk(&memchunk);
-        l = pa_write(u->stream_fd, p, memchunk.length, &u->stream_write_type);
-        pa_memblock_release(memchunk.memblock);
+    pa_assert(u->bt_codec);
+
+    /* If socket write MTU is less than encoded frame size, there could be
+     * up to one write MTU of data left in encoder buffer from previous round.
+     *
+     * Reserve space for at least 2 encoded frames to cover that.
+     *
+     * Note for A2DP codecs it is expected that size of encoded frame is less
+     * than write link MTU. Therefore each encoded frame is sent out completely
+     * and there is no used space in encoder buffer before next encoder call.
+     *
+     * For SCO socket all writes will be of MTU size to match payload length
+     * of HCI packet. Depending on selected USB Alternate Setting the payload
+     * length of HCI packet may exceed encoded frame size. For mSBC frame size
+     * is 60 bytes, payload length of HCI packet in USB Alts 3 is 72 byte,
+     * in USB Alts 5 it is 144 bytes.
+     *
+     * Reserve space for up to 1 + MTU / (encoded frame size) encoded frames
+     * to cover that.
+     *
+     * Note for current linux kernel (up to 5.13.x at least) there is no way to
+     * reliably detect socket MTU size. For now we just set SCO socket MTU to be
+     * large enough to cover all known sizes (largest is USB ALts 5 with 144 bytes)
+     * and adjust SCO write size to be equal to last SCO read size. This makes
+     * write size less or equal to MTU size. Reserving the same number of encoded
+     * frames to cover full MTU is still enough.
+     * See also https://gitlab.freedesktop.org/pulseaudio/pulseaudio/-/merge_requests/254#note_779802
+     */
 
-        pa_assert(l != 0);
+    if (u->bt_codec->get_encoded_block_size)
+        encoded_size = u->bt_codec->get_encoded_block_size(u->encoder_info, u->write_block_size);
+    else
+        encoded_size = u->write_block_size;
 
-        if (l > 0)
-            break;
+    encoded_frames = u->write_link_mtu / u->write_block_size + 1;
 
-        saved_errno = errno;
+    if (encoded_frames < 2)
+        encoded_frames = 2;
 
-        if (saved_errno == EINTR)
-            /* Retry right away if we got interrupted */
-            continue;
+    reserved_size = encoded_frames * encoded_size;
 
-        pa_memblock_unref(memchunk.memblock);
+    if (u->encoder_buffer_size < reserved_size) {
+        u->encoder_buffer = pa_xrealloc(u->encoder_buffer, reserved_size);
+        u->encoder_buffer_size = reserved_size;
 
-        if (saved_errno == EAGAIN) {
-            /* Hmm, apparently the socket was not writable, give up for now.
-             * Because the data was already rendered, let's discard the block. */
-            pa_log_debug("Got EAGAIN on write() after POLLOUT, probably there is a temporary connection loss.");
-            return 1;
+        if (u->encoder_buffer_used > reserved_size) {
+            u->encoder_buffer_used = 0;
         }
-
-        pa_log_error("Failed to write data to SCO socket: %s", pa_cstrerror(saved_errno));
-        return -1;
     }
 
-    pa_assert((size_t) l <= memchunk.length);
+    /* Report if there is still not enough space for new block */
+    if (u->encoder_buffer_size < u->encoder_buffer_used + encoded_size)
+        return false;
 
-    if ((size_t) l != memchunk.length) {
-        pa_log_error("Wrote memory block to socket only partially! %llu written, wanted to write %llu.",
-                    (unsigned long long) l,
-                    (unsigned long long) memchunk.length);
-
-        pa_memblock_unref(memchunk.memblock);
-        return -1;
-    }
-
-    u->write_index += (uint64_t) memchunk.length;
-    pa_memblock_unref(memchunk.memblock);
-
-    return 1;
+    return true;
 }
 
 /* Run from IO thread */
-static int sco_process_push(struct userdata *u) {
-    ssize_t l;
-    pa_memchunk memchunk;
-    struct cmsghdr *cm;
-    struct msghdr m;
-    bool found_tstamp = false;
-    pa_usec_t tstamp = 0;
+static int bt_write_buffer(struct userdata *u) {
+    ssize_t written = 0;
 
     pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT ||
-                u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-    pa_assert(u->source);
-    pa_assert(u->read_smoother);
+    pa_assert(u->transport);
+    pa_assert(u->bt_codec);
 
-    memchunk.memblock = pa_memblock_new(u->core->mempool, u->read_block_size);
-    memchunk.index = memchunk.length = 0;
+    written = u->transport->write(u->transport, u->stream_fd, u->encoder_buffer, u->encoder_buffer_used, u->write_link_mtu);
 
-    for (;;) {
-        void *p;
-        uint8_t aux[1024];
-        struct iovec iov;
+    if (written > 0) {
+        /* calculate remainder */
+        u->encoder_buffer_used -= written;
 
-        pa_zero(m);
-        pa_zero(aux);
-        pa_zero(iov);
-
-        m.msg_iov = &iov;
-        m.msg_iovlen = 1;
-        m.msg_control = aux;
-        m.msg_controllen = sizeof(aux);
+        /* move any remainder back to start of u->encoder_buffer */
+        if (u->encoder_buffer_used)
+            memmove(u->encoder_buffer, u->encoder_buffer + written, u->encoder_buffer_used);
 
-        p = pa_memblock_acquire(memchunk.memblock);
-        iov.iov_base = p;
-        iov.iov_len = pa_memblock_get_length(memchunk.memblock);
-        l = recvmsg(u->stream_fd, &m, 0);
-        pa_memblock_release(memchunk.memblock);
+        return 1;
+    } else if (written == 0) {
+        /* Not enough data in encoder buffer */
+        return 0;
+    } else {
+        /* Reset encoder sequence number and buffer positions */
+        u->bt_codec->reset(u->encoder_info);
+        u->encoder_buffer_used = 0;
+        return -1;
+    }
+}
 
-        if (l > 0)
-            break;
+/* Run from IO thread */
+static int bt_process_render(struct userdata *u) {
+    int ret;
 
-        if (l < 0 && errno == EINTR)
-            /* Retry right away if we got interrupted */
-            continue;
+    const uint8_t *ptr;
+    size_t processed;
+    size_t length;
 
-        pa_memblock_unref(memchunk.memblock);
+    pa_assert(u);
+    pa_assert(u->sink);
+    pa_assert(u->bt_codec);
 
-        if (l < 0 && errno == EAGAIN)
-            /* Hmm, apparently the socket was not readable, give up for now. */
-            return 0;
+    if (!bt_prepare_encoder_buffer(u))
+        return false;
 
-        pa_log_error("Failed to read data from SCO socket: %s", l < 0 ? pa_cstrerror(errno) : "EOF");
-        return -1;
-    }
+    /* First, render some data */
+    if (!u->write_memchunk.memblock)
+        pa_sink_render_full(u->sink, u->write_block_size, &u->write_memchunk);
 
-    pa_assert((size_t) l <= pa_memblock_get_length(memchunk.memblock));
+    pa_assert(u->write_memchunk.length == u->write_block_size);
 
-    /* In some rare occasions, we might receive packets of a very strange
-     * size. This could potentially be possible if the SCO packet was
-     * received partially over-the-air, or more probably due to hardware
-     * issues in our Bluetooth adapter. In these cases, in order to avoid
-     * an assertion failure due to unaligned data, just discard the whole
-     * packet */
-    if (!pa_frame_aligned(l, &u->decoder_sample_spec)) {
-        pa_log_warn("SCO packet received of unaligned size: %zu", l);
-        pa_memblock_unref(memchunk.memblock);
-        return -1;
-    }
+    ptr = (const uint8_t *) pa_memblock_acquire_chunk(&u->write_memchunk);
 
-    memchunk.length = (size_t) l;
-    u->read_index += (uint64_t) l;
+    length = u->bt_codec->encode_buffer(u->encoder_info, u->write_index / pa_frame_size(&u->encoder_sample_spec),
+            ptr, u->write_memchunk.length,
+            u->encoder_buffer + u->encoder_buffer_used, u->encoder_buffer_size - u->encoder_buffer_used,
+            &processed);
 
-    for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))
-        if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SO_TIMESTAMP) {
-            struct timeval *tv = (struct timeval*) CMSG_DATA(cm);
-            pa_rtclock_from_wallclock(tv);
-            tstamp = pa_timeval_load(tv);
-            found_tstamp = true;
-            break;
-        }
+    pa_memblock_release(u->write_memchunk.memblock);
 
-    if (!found_tstamp) {
-        pa_log_warn("Couldn't find SO_TIMESTAMP data in auxiliary recvmsg() data!");
-        tstamp = pa_rtclock_now();
+    if (processed != u->write_memchunk.length) {
+        pa_log_error("Encoding error");
+        return -1;
     }
 
-    pa_smoother_put(u->read_smoother, tstamp, pa_bytes_to_usec(u->read_index, &u->decoder_sample_spec));
-    pa_smoother_resume(u->read_smoother, tstamp, true);
-
-    pa_source_post(u->source, &memchunk);
-    pa_memblock_unref(memchunk.memblock);
-
-    return l;
-}
+    /* Encoder function of BT codec may provide empty buffer, in this case do
+     * not post any empty buffer via BT socket. It may be because of codec
+     * internal state, e.g. encoder is waiting for more samples so it can
+     * provide encoded data. */
 
-/* Run from IO thread */
-static void a2dp_prepare_encoder_buffer(struct userdata *u) {
-    pa_assert(u);
+    if (PA_LIKELY(length)) {
+        u->encoder_buffer_used += length;
+        ret = 1;
+    } else
+        ret = 0;
 
-    if (u->encoder_buffer_size < u->write_link_mtu) {
-        pa_xfree(u->encoder_buffer);
-        u->encoder_buffer = pa_xmalloc(u->write_link_mtu);
-    }
+    u->write_index += (uint64_t) u->write_memchunk.length;
+    pa_memblock_unref(u->write_memchunk.memblock);
+    pa_memchunk_reset(&u->write_memchunk);
 
-    /* Encoder buffer cannot be larger then link MTU, otherwise
-     * encode method would produce larger packets then link MTU */
-    u->encoder_buffer_size = u->write_link_mtu;
+    return ret;
 }
 
-/* Run from IO thread */
-static void a2dp_prepare_decoder_buffer(struct userdata *u) {
+static void bt_prepare_decoder_buffer(struct userdata *u) {
     pa_assert(u);
 
     if (u->decoder_buffer_size < u->read_link_mtu) {
@@ -437,178 +427,138 @@ static void a2dp_prepare_decoder_buffer(struct userdata *u) {
 }
 
 /* Run from IO thread */
-static int a2dp_write_buffer(struct userdata *u, size_t nbytes) {
-    int ret = 0;
-
-    /* Encoder function of A2DP codec may provide empty buffer, in this case do
-     * not post any empty buffer via A2DP socket. It may be because of codec
-     * internal state, e.g. encoder is waiting for more samples so it can
-     * provide encoded data. */
-    if (PA_UNLIKELY(!nbytes)) {
-        u->write_index += (uint64_t) u->write_memchunk.length;
-        pa_memblock_unref(u->write_memchunk.memblock);
-        pa_memchunk_reset(&u->write_memchunk);
-        return 0;
-    }
+static ssize_t bt_transport_read(pa_bluetooth_transport *t, int fd, void *buffer, size_t size, pa_usec_t *p_timestamp) {
+    ssize_t received = 0;
 
+    pa_assert(t);
     for (;;) {
-        ssize_t l;
+        uint8_t aux[1024];
+        struct iovec iov;
+        struct cmsghdr *cm;
+        struct msghdr m;
+        bool found_tstamp = false;
+
+        pa_zero(m);
+        pa_zero(aux);
+        pa_zero(iov);
+
+        m.msg_iov = &iov;
+        m.msg_iovlen = 1;
+        m.msg_control = aux;
+        m.msg_controllen = sizeof(aux);
 
-        l = pa_write(u->stream_fd, u->encoder_buffer, nbytes, &u->stream_write_type);
+        iov.iov_base = buffer;
+        iov.iov_len = size;
 
-        pa_assert(l != 0);
+        received = recvmsg(fd, &m, 0);
 
-        if (l < 0) {
+        if (received <= 0) {
 
-            if (errno == EINTR)
+            if (received < 0 && errno == EINTR)
                 /* Retry right away if we got interrupted */
                 continue;
 
-            else if (errno == EAGAIN) {
-                /* Hmm, apparently the socket was not writable, give up for now */
-                pa_log_debug("Got EAGAIN on write() after POLLOUT, probably there is a temporary connection loss.");
-                break;
-            }
+            else if (received < 0 && errno == EAGAIN)
+                /* Hmm, apparently the socket was not readable, give up for now. */
+                return 0;
 
-            pa_log_error("Failed to write data to socket: %s", pa_cstrerror(errno));
-            ret = -1;
-            break;
+            pa_log_error("Failed to read data from socket: %s", received < 0 ? pa_cstrerror(errno) : "EOF");
+            return -1;
         }
 
-        pa_assert((size_t) l <= nbytes);
+        pa_assert((size_t) received <= size);
 
-        if ((size_t) l != nbytes) {
-            pa_log_warn("Wrote memory block to socket only partially! %llu written, wanted to write %llu.",
-                        (unsigned long long) l,
-                        (unsigned long long) nbytes);
-            ret = -1;
-            break;
-        }
+        /* allow write side to find out size of last read packet */
+        t->last_read_size = received;
 
-        u->write_index += (uint64_t) u->write_memchunk.length;
-        pa_memblock_unref(u->write_memchunk.memblock);
-        pa_memchunk_reset(&u->write_memchunk);
+        if (p_timestamp) {
+            /* TODO: get timestamp from rtp */
 
-        ret = 1;
+            for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm)) {
+                if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SO_TIMESTAMP) {
+                    struct timeval *tv = (struct timeval*) CMSG_DATA(cm);
+                    pa_rtclock_from_wallclock(tv);
+                    *p_timestamp = pa_timeval_load(tv);
+                    found_tstamp = true;
+                    break;
+                }
+            }
+
+            if (!found_tstamp) {
+                PA_ONCE_BEGIN {
+                    pa_log_warn("Couldn't find SO_TIMESTAMP data in auxiliary recvmsg() data!");
+                } PA_ONCE_END;
+                *p_timestamp = pa_rtclock_now();
+            }
+        }
 
         break;
     }
 
-    return ret;
+    return received;
 }
 
 /* Run from IO thread */
-static int a2dp_process_render(struct userdata *u) {
-    const uint8_t *ptr;
-    size_t processed;
-    size_t length;
+/* Read incoming data, decode it and post result (if any) to source output.
+ * Returns number of bytes posted to source output. */
+static int bt_process_push(struct userdata *u) {
+    pa_usec_t tstamp;
+    uint8_t *ptr;
+    ssize_t received;
+    size_t processed = 0;
 
     pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK);
-    pa_assert(u->sink);
-    pa_assert(u->a2dp_codec);
-
-    /* First, render some data */
-    if (!u->write_memchunk.memblock)
-        pa_sink_render_full(u->sink, u->write_block_size, &u->write_memchunk);
-
-    pa_assert(u->write_memchunk.length == u->write_block_size);
-
-    a2dp_prepare_encoder_buffer(u);
-
-    /* Try to create a packet of the full MTU */
-    ptr = (const uint8_t *) pa_memblock_acquire_chunk(&u->write_memchunk);
+    pa_assert(u->source);
+    pa_assert(u->read_smoother);
+    pa_assert(u->bt_codec);
+    pa_assert(u->transport);
 
-    length = u->a2dp_codec->encode_buffer(u->encoder_info, u->write_index / pa_frame_size(&u->encoder_sample_spec), ptr, u->write_memchunk.length, u->encoder_buffer, u->encoder_buffer_size, &processed);
+    bt_prepare_decoder_buffer(u);
 
-    pa_memblock_release(u->write_memchunk.memblock);
+    received = bt_transport_read(u->transport, u->stream_fd, u->decoder_buffer, u->decoder_buffer_size, &tstamp);
 
-    if (processed != u->write_memchunk.length) {
-        pa_log_error("Encoding error");
-        return -1;
+    if (received <= 0) {
+        return received;
     }
 
-    return a2dp_write_buffer(u, length);
-}
-
-/* Run from IO thread */
-static int a2dp_process_push(struct userdata *u) {
-    int ret = 0;
     pa_memchunk memchunk;
 
-    pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE);
-    pa_assert(u->source);
-    pa_assert(u->read_smoother);
-    pa_assert(u->a2dp_codec);
-
     memchunk.memblock = pa_memblock_new(u->core->mempool, u->read_block_size);
     memchunk.index = memchunk.length = 0;
 
-    a2dp_prepare_decoder_buffer(u);
-
-    for (;;) {
-        bool found_tstamp = false;
-        pa_usec_t tstamp;
-        uint8_t *ptr;
-        ssize_t l;
-        size_t processed;
-
-        l = pa_read(u->stream_fd, u->decoder_buffer, u->decoder_buffer_size, &u->stream_write_type);
-
-        if (l <= 0) {
-
-            if (l < 0 && errno == EINTR)
-                /* Retry right away if we got interrupted */
-                continue;
-
-            else if (l < 0 && errno == EAGAIN)
-                /* Hmm, apparently the socket was not readable, give up for now. */
-                break;
-
-            pa_log_error("Failed to read data from socket: %s", l < 0 ? pa_cstrerror(errno) : "EOF");
-            ret = -1;
-            break;
-        }
-
-        pa_assert((size_t) l <= u->decoder_buffer_size);
-
-        /* TODO: get timestamp from rtp */
-        if (!found_tstamp) {
-            /* pa_log_warn("Couldn't find SO_TIMESTAMP data in auxiliary recvmsg() data!"); */
-            tstamp = pa_rtclock_now();
-        }
-
-        ptr = pa_memblock_acquire(memchunk.memblock);
-        memchunk.length = pa_memblock_get_length(memchunk.memblock);
+    ptr = pa_memblock_acquire(memchunk.memblock);
+    memchunk.length = pa_memblock_get_length(memchunk.memblock);
 
-        memchunk.length = u->a2dp_codec->decode_buffer(u->decoder_info, u->decoder_buffer, l, ptr, memchunk.length, &processed);
+    memchunk.length = u->bt_codec->decode_buffer(u->decoder_info, u->decoder_buffer, received, ptr, memchunk.length, &processed);
 
-        pa_memblock_release(memchunk.memblock);
+    pa_memblock_release(memchunk.memblock);
 
-        if (processed != (size_t) l) {
-            pa_log_error("Decoding error");
-            ret = -1;
-            break;
-        }
+    if (processed != (size_t) received) {
+        pa_log_error("Decoding error");
+        return -1;
+    }
 
-        u->read_index += (uint64_t) memchunk.length;
+    u->read_index += (uint64_t) memchunk.length;
+#ifdef USE_SMOOTHER_2
+        pa_smoother_2_resume(u->read_smoother, tstamp);
+        pa_smoother_2_put(u->read_smoother, tstamp, u->read_index);
+#else
         pa_smoother_put(u->read_smoother, tstamp, pa_bytes_to_usec(u->read_index, &u->decoder_sample_spec));
         pa_smoother_resume(u->read_smoother, tstamp, true);
+#endif
 
-        /* Decoding of A2DP codec data may result in empty buffer, in this case
-         * do not post empty audio samples. It may happen due to algorithmic
-         * delay of audio codec. */
-        if (PA_LIKELY(memchunk.length))
-            pa_source_post(u->source, &memchunk);
+    /* Decoding of data may result in empty buffer, in this case
+     * do not post empty audio samples. It may happen due to algorithmic
+     * delay of audio codec. */
+    if (PA_LIKELY(memchunk.length))
+        pa_source_post(u->source, &memchunk);
 
-        ret = l;
-        break;
-    }
+    /* report decoded size */
+    received = memchunk.length;
 
     pa_memblock_unref(memchunk.memblock);
 
-    return ret;
+    return received;
 }
 
 static void update_sink_buffer_size(struct userdata *u) {
@@ -655,7 +605,11 @@ static void teardown_stream(struct userdata *u) {
     }
 
     if (u->read_smoother) {
+#ifdef USE_SMOOTHER_2
+        pa_smoother_2_free(u->read_smoother);
+#else
         pa_smoother_free(u->read_smoother);
+#endif
         u->read_smoother = NULL;
     }
 
@@ -736,25 +690,23 @@ static void handle_sink_block_size_change(struct userdata *u) {
 
 /* Run from I/O thread */
 static void transport_config_mtu(struct userdata *u) {
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        u->read_block_size = u->read_link_mtu;
-        u->write_block_size = u->write_link_mtu;
+    pa_assert(u->bt_codec);
 
-        if (!pa_frame_aligned(u->read_block_size, &u->source->sample_spec)) {
-            pa_log_debug("Got invalid read MTU: %lu, rounding down", u->read_block_size);
-            u->read_block_size = pa_frame_align(u->read_block_size, &u->source->sample_spec);
-        }
+    if (u->encoder_info) {
+        u->write_block_size = u->bt_codec->get_write_block_size(u->encoder_info, u->write_link_mtu);
 
         if (!pa_frame_aligned(u->write_block_size, &u->sink->sample_spec)) {
             pa_log_debug("Got invalid write MTU: %lu, rounding down", u->write_block_size);
             u->write_block_size = pa_frame_align(u->write_block_size, &u->sink->sample_spec);
         }
-    } else {
-        pa_assert(u->a2dp_codec);
-        if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
-            u->write_block_size = u->a2dp_codec->get_write_block_size(u->encoder_info, u->write_link_mtu);
-        } else {
-            u->read_block_size = u->a2dp_codec->get_read_block_size(u->decoder_info, u->read_link_mtu);
+    }
+
+    if (u->decoder_info) {
+        u->read_block_size = u->bt_codec->get_read_block_size(u->decoder_info, u->read_link_mtu);
+
+        if (!pa_frame_aligned(u->read_block_size, &u->source->sample_spec)) {
+            pa_log_debug("Got invalid read MTU: %lu, rounding down", u->read_block_size);
+            u->read_block_size = pa_frame_align(u->read_block_size, &u->source->sample_spec);
         }
     }
 
@@ -781,13 +733,15 @@ static int setup_stream(struct userdata *u) {
 
     pa_log_info("Transport %s resuming", u->transport->path);
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
-        pa_assert(u->a2dp_codec);
-        if (u->a2dp_codec->reset(u->encoder_info) < 0)
+    pa_assert(u->bt_codec);
+
+    if (u->encoder_info) {
+        if (u->bt_codec->reset(u->encoder_info) < 0)
             return -1;
-    } else if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE) {
-        pa_assert(u->a2dp_codec);
-        if (u->a2dp_codec->reset(u->decoder_info) < 0)
+    }
+
+    if (u->decoder_info) {
+        if (u->bt_codec->reset(u->decoder_info) < 0)
             return -1;
     }
 
@@ -812,7 +766,11 @@ static int setup_stream(struct userdata *u) {
     u->stream_setup_done = true;
 
     if (u->source)
+#ifdef USE_SMOOTHER_2
+        u->read_smoother = pa_smoother_2_new(5*PA_USEC_PER_SEC, pa_rtclock_now(), pa_frame_size(&u->decoder_sample_spec), u->decoder_sample_spec.rate);
+#else
         u->read_smoother = pa_smoother_new(PA_USEC_PER_SEC, 2*PA_USEC_PER_SEC, true, true, 10, pa_rtclock_now(), true);
+#endif
 
     return 0;
 }
@@ -833,6 +791,41 @@ static bool setup_transport_and_stream(struct userdata *u) {
     return true;
 }
 
+/* Run from main thread */
+static pa_hook_result_t sink_source_volume_changed_cb(void *hook_data, void *call_data, void *slot_data) {
+    struct userdata *u = slot_data;
+    const pa_cvolume *new_volume = NULL;
+    pa_volume_t volume;
+    pa_bluetooth_transport_set_volume_cb notify_volume_change;
+
+    /* In the HS/HF role, notify the AG of a change in speaker/microphone gain.
+     * In the AG role the command to change HW volume on the remote is already
+     * sent by the hardware callback (if the peer supports it and the sink
+     * or source set_volume callback is attached. Otherwise nothing is sent).
+     */
+    pa_assert(pa_bluetooth_profile_should_attenuate_volume(u->profile));
+
+    if (u->sink == call_data) {
+        new_volume = pa_sink_get_volume(u->sink, false);
+        notify_volume_change = u->transport->set_sink_volume;
+    } else if (u->source == call_data) {
+        new_volume = pa_source_get_volume(u->source, false);
+        notify_volume_change = u->transport->set_source_volume;
+    } else {
+        return PA_HOOK_OK;
+    }
+
+    /* Volume control/notifications are optional */
+    if (!notify_volume_change)
+        return PA_HOOK_OK;
+
+    volume = pa_cvolume_max(new_volume);
+
+    notify_volume_change(u->transport, volume);
+
+    return PA_HOOK_OK;
+}
+
 /* Run from IO thread */
 static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
     struct userdata *u = PA_SOURCE(o)->userdata;
@@ -842,14 +835,66 @@ static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t off
 
     switch (code) {
 
+        case PA_SOURCE_MESSAGE_SET_STATE:
+
+            /* Unlike A2DP, A2DP can be awakened by such as gstreamer.
+             * No program will wake up HFP after sink/source suspend. */
+            if (u->profile == PA_BLUETOOTH_PROFILE_HFP_HF)
+                break;
+
+            switch ((pa_source_state_t) PA_PTR_TO_UINT(data)) {
+
+                case PA_SOURCE_SUSPENDED:
+                    /* Ignore if transition is PA_SOURCE_INIT->PA_SOURCE_SUSPENDED */
+                    if (!PA_SOURCE_IS_OPENED(u->source->thread_info.state))
+                        break;
+
+                    /* Stop the device if the sink is suspended as well */
+                    if (!u->sink || u->sink->state == PA_SINK_SUSPENDED)
+                        transport_release(u);
+
+                    if (u->read_smoother)
+                        pa_smoother_pause(u->read_smoother, pa_rtclock_now());
+                    break;
+
+                case PA_SOURCE_IDLE:
+                case PA_SOURCE_RUNNING:
+                    if (u->source->thread_info.state != PA_SOURCE_SUSPENDED)
+                        break;
+
+                    /* Resume the device if the sink was suspended as well */
+                    if (!u->sink || !PA_SINK_IS_OPENED(u->sink->thread_info.state))
+                        if (!setup_transport_and_stream(u))
+                            return -1;
+
+                    /* We don't resume the smoother here. Instead we
+                     * wait until the first packet arrives */
+
+                    break;
+
+                case PA_SOURCE_UNLINKED:
+                case PA_SOURCE_INIT:
+                case PA_SOURCE_INVALID_STATE:
+                    break;
+
+            }
+
+        break;
+
         case PA_SOURCE_MESSAGE_GET_LATENCY: {
+#ifndef USE_SMOOTHER_2
             int64_t wi, ri;
+#endif
 
             if (u->read_smoother) {
+#ifdef USE_SMOOTHER_2
+                *((int64_t*) data) = u->source->thread_info.fixed_latency - pa_smoother_2_get_delay(u->read_smoother, pa_rtclock_now(), u->read_index);
+#else
                 wi = pa_smoother_get(u->read_smoother, pa_rtclock_now());
                 ri = pa_bytes_to_usec(u->read_index, &u->decoder_sample_spec);
 
                 *((int64_t*) data) = u->source->thread_info.fixed_latency + wi - ri;
+#endif
             } else
                 *((int64_t*) data) = 0;
 
@@ -875,91 +920,85 @@ static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t off
     return pa_source_process_msg(o, code, data, offset, chunk);
 }
 
-/* Called from the IO thread. */
-static int source_set_state_in_io_thread_cb(pa_source *s, pa_source_state_t new_state, pa_suspend_cause_t new_suspend_cause) {
+/* Run from main thread */
+static void source_set_volume_cb(pa_source *s) {
+    pa_volume_t volume;
     struct userdata *u;
 
     pa_assert(s);
-    pa_assert_se(u = s->userdata);
-
-    switch (new_state) {
-
-        case PA_SOURCE_SUSPENDED:
-            /* Ignore if transition is PA_SOURCE_INIT->PA_SOURCE_SUSPENDED */
-            if (!PA_SOURCE_IS_OPENED(s->thread_info.state))
-                break;
-
-            /* Stop the device if the sink is suspended as well */
-            if (!u->sink || u->sink->state == PA_SINK_SUSPENDED)
-                transport_release(u);
-
-            if (u->read_smoother)
-                pa_smoother_pause(u->read_smoother, pa_rtclock_now());
-
-            break;
-
-        case PA_SOURCE_IDLE:
-        case PA_SOURCE_RUNNING:
-            if (s->thread_info.state != PA_SOURCE_SUSPENDED)
-                break;
-
-            /* Resume the device if the sink was suspended as well */
-            if (!u->sink || !PA_SINK_IS_OPENED(u->sink->thread_info.state))
-                if (!setup_transport_and_stream(u))
-                    return -1;
+    pa_assert(s->core);
 
-            /* We don't resume the smoother here. Instead we
-             * wait until the first packet arrives */
+    u = s->userdata;
 
-            break;
+    pa_assert(u);
+    pa_assert(u->source == s);
+    pa_assert(!pa_bluetooth_profile_should_attenuate_volume(u->profile));
+    pa_assert(u->transport);
+    pa_assert(u->transport->set_source_volume);
 
-        case PA_SOURCE_UNLINKED:
-        case PA_SOURCE_INIT:
-        case PA_SOURCE_INVALID_STATE:
-            break;
-    }
+    /* In the AG role, send a command to change microphone gain on the HS/HF */
+    volume = u->transport->set_source_volume(u->transport, pa_cvolume_max(&s->real_volume));
 
-    return 0;
+    pa_cvolume_set(&s->real_volume, u->decoder_sample_spec.channels, volume);
 }
 
 /* Run from main thread */
-static void source_set_volume_cb(pa_source *s) {
-    uint16_t gain;
-    pa_volume_t volume;
+static void source_setup_volume_callback(pa_source *s) {
     struct userdata *u;
 
     pa_assert(s);
     pa_assert(s->core);
 
     u = s->userdata;
-
     pa_assert(u);
     pa_assert(u->source == s);
+    pa_assert(u->transport);
 
-    if (u->transport->set_microphone_gain == NULL)
-      return;
+    if (pa_bluetooth_profile_is_a2dp(u->profile) && !u->transport->device->avrcp_absolute_volume)
+        return;
 
-    gain = (pa_cvolume_max(&s->real_volume) * HSP_MAX_GAIN) / PA_VOLUME_NORM;
+    /* Remote volume control has to be supported for the callback to make sense,
+     * otherwise this source should continue performing attenuation in software
+     * without HW_VOLUME_CTL.
+     * If the peer is an AG however backend-native unconditionally provides this
+     * function, PA in the role of HS/HF is responsible for signalling support
+     * by emitting an initial volume command.
+     * For A2DP bluez-util also unconditionally provides this function to keep
+     * the peer informed about volume changes.
+     */
+    if (!u->transport->set_source_volume)
+        return;
 
-    if (gain > HSP_MAX_GAIN)
-        gain = HSP_MAX_GAIN;
+    if (pa_bluetooth_profile_should_attenuate_volume(u->profile)) {
+        if (u->source_volume_changed_slot)
+            return;
 
-    volume = (pa_volume_t) (gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
+        pa_log_debug("%s: Attaching volume hook to notify peer of changes", s->name);
 
-    /* increment volume by one to correct rounding errors */
-    if (volume < PA_VOLUME_NORM)
-        volume++;
+        u->source_volume_changed_slot = pa_hook_connect(&s->core->hooks[PA_CORE_HOOK_SOURCE_VOLUME_CHANGED],
+                                                        PA_HOOK_NORMAL, sink_source_volume_changed_cb, u);
 
-    pa_cvolume_set(&s->real_volume, u->decoder_sample_spec.channels, volume);
+        /* Send initial volume to peer, signalling support for volume control */
+        u->transport->set_source_volume(u->transport, pa_cvolume_max(&s->real_volume));
+    } else {
+        /* It is yet unknown how (if at all) volume is synchronized for bidirectional
+         * A2DP codecs.  Disallow attaching callbacks (and using HFP n_volume_steps)
+         * below to a pa_source if the peer is in A2DP_SINK role.  This assert should
+         * be replaced with the proper logic when bidirectional codecs are implemented.
+         */
+        pa_assert(u->profile != PA_BLUETOOTH_PROFILE_A2DP_SINK);
+
+        if (s->set_volume == source_set_volume_cb)
+            return;
+
+        pa_log_debug("%s: Resetting software volume for hardware attenuation by peer", s->name);
 
-    /* Set soft volume when in headset role */
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
-        pa_cvolume_set(&s->soft_volume, u->decoder_sample_spec.channels, volume);
+        /* Reset local attenuation */
+        pa_source_set_soft_volume(s, NULL);
 
-    /* If we are in the AG role, we send a command to the head set to change
-     * the microphone gain. In the HS role, source and sink are swapped, so
-     * in this case we notify the AG that the speaker gain has changed */
-    u->transport->set_microphone_gain(u->transport, gain);
+        pa_source_set_set_volume_callback(s, source_set_volume_cb);
+        s->n_volume_steps = HSP_MAX_GAIN + 1;
+    }
 }
 
 /* Run from main thread */
@@ -975,8 +1014,11 @@ static int add_source(struct userdata *u) {
     data.name = pa_sprintf_malloc("bluez_source.%s.%s", u->device->address, pa_bluetooth_profile_to_string(u->profile));
     data.namereg_fail = false;
     pa_proplist_sets(data.proplist, "bluetooth.protocol", pa_bluetooth_profile_to_string(u->profile));
+    if (u->bt_codec)
+        pa_proplist_sets(data.proplist, PA_PROP_BLUETOOTH_CODEC, u->bt_codec->name);
     pa_source_new_data_set_sample_spec(&data, &u->decoder_sample_spec);
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
+    if (u->profile == PA_BLUETOOTH_PROFILE_HSP_HS
+        || u->profile == PA_BLUETOOTH_PROFILE_HFP_HF)
         pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "phone");
 
     connect_ports(u, &data, PA_DIRECTION_INPUT);
@@ -984,10 +1026,12 @@ static int add_source(struct userdata *u) {
     if (!u->transport_acquired)
         switch (u->profile) {
             case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-            case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
+            case PA_BLUETOOTH_PROFILE_HFP_AG:
+            case PA_BLUETOOTH_PROFILE_HSP_AG:
                 data.suspend_cause = PA_SUSPEND_USER;
                 break;
-            case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
+            case PA_BLUETOOTH_PROFILE_HSP_HS:
+            case PA_BLUETOOTH_PROFILE_HFP_HF:
                 /* u->stream_fd contains the error returned by the last transport_acquire()
                  * EAGAIN means we are waiting for a NewConnection signal */
                 if (u->stream_fd == -EAGAIN)
@@ -1010,12 +1054,10 @@ static int add_source(struct userdata *u) {
 
     u->source->userdata = u;
     u->source->parent.process_msg = source_process_msg;
-    u->source->set_state_in_io_thread = source_set_state_in_io_thread_cb;
+    //u->source->set_state_in_io_thread = source_set_state_in_io_thread_cb;
+
+    source_setup_volume_callback(u->source);
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        pa_source_set_set_volume_callback(u->source, source_set_volume_cb);
-        u->source->n_volume_steps = 16;
-    }
     return 0;
 }
 
@@ -1028,18 +1070,70 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
 
     switch (code) {
 
+        case PA_SINK_MESSAGE_SET_STATE:
+
+            /* Unlike A2DP, A2DP can be awakened by such as gstreamer.
+             * No program will wake up HFP after sink/source suspend. */
+            if (u->profile == PA_BLUETOOTH_PROFILE_HFP_HF)
+                break;
+
+            switch ((pa_sink_state_t) PA_PTR_TO_UINT(data)) {
+
+                case PA_SINK_SUSPENDED:
+                /* Ignore if transition is PA_SINK_INIT->PA_SINK_SUSPENDED */
+                if (!PA_SINK_IS_OPENED(u->sink->thread_info.state))
+                    break;
+
+                /* Stop the device if the source is suspended as well */
+                if (!u->source || u->source->state == PA_SOURCE_SUSPENDED)
+                    /* We deliberately ignore whether stopping
+                     * actually worked. Since the stream_fd is
+                     * closed it doesn't really matter */
+                    transport_release(u);
+
+                break;
+
+                case PA_SINK_IDLE:
+                case PA_SINK_RUNNING:
+                    if (u->sink->thread_info.state != PA_SINK_SUSPENDED)
+                        break;
+
+                    /* Resume the device if the source was suspended as well */
+                    if (!u->source || !PA_SOURCE_IS_OPENED(u->source->thread_info.state))
+                        if (!setup_transport_and_stream(u))
+                            return -1;
+
+                    break;
+
+                case PA_SINK_UNLINKED:
+                case PA_SINK_INIT:
+                case PA_SINK_INVALID_STATE:
+                    break;
+			}
+
+        break;
+
         case PA_SINK_MESSAGE_GET_LATENCY: {
-            int64_t wi = 0, ri = 0;
+            int64_t wi, ri, delay = 0;
 
             if (u->read_smoother) {
+#ifdef USE_SMOOTHER_2
+                /* This is only used for SCO where encoder and decoder sample specs are
+                 * equal and output timing is based on the source. Therefore we can pass
+                 * the write index without conversion. */
+                delay = pa_smoother_2_get_delay(u->read_smoother, pa_rtclock_now(), u->write_index + u->write_block_size);
+#else
                 ri = pa_smoother_get(u->read_smoother, pa_rtclock_now());
                 wi = pa_bytes_to_usec(u->write_index + u->write_block_size, &u->encoder_sample_spec);
+                delay = wi - ri;
+#endif
             } else if (u->started_at) {
                 ri = pa_rtclock_now() - u->started_at;
                 wi = pa_bytes_to_usec(u->write_index, &u->encoder_sample_spec);
+                delay = wi - ri;
             }
 
-            *((int64_t*) data) = u->sink->thread_info.fixed_latency + wi - ri;
+            *((int64_t*) data) = u->sink->thread_info.fixed_latency + delay;
 
             return 0;
         }
@@ -1062,88 +1156,87 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
     return pa_sink_process_msg(o, code, data, offset, chunk);
 }
 
-/* Called from the IO thread. */
-static int sink_set_state_in_io_thread_cb(pa_sink *s, pa_sink_state_t new_state, pa_suspend_cause_t new_suspend_cause) {
+/* Run from main thread */
+static void sink_set_volume_cb(pa_sink *s) {
+    pa_volume_t volume;
     struct userdata *u;
 
     pa_assert(s);
-    pa_assert_se(u = s->userdata);
-
-    switch (new_state) {
-
-        case PA_SINK_SUSPENDED:
-            /* Ignore if transition is PA_SINK_INIT->PA_SINK_SUSPENDED */
-            if (!PA_SINK_IS_OPENED(s->thread_info.state))
-                break;
-
-            /* Stop the device if the source is suspended as well */
-            if (!u->source || u->source->state == PA_SOURCE_SUSPENDED)
-                /* We deliberately ignore whether stopping
-                 * actually worked. Since the stream_fd is
-                 * closed it doesn't really matter */
-                transport_release(u);
-
-            break;
-
-        case PA_SINK_IDLE:
-        case PA_SINK_RUNNING:
-            if (s->thread_info.state != PA_SINK_SUSPENDED)
-                break;
+    pa_assert(s->core);
 
-            /* Resume the device if the source was suspended as well */
-            if (!u->source || !PA_SOURCE_IS_OPENED(u->source->thread_info.state))
-                if (!setup_transport_and_stream(u))
-                    return -1;
+    u = s->userdata;
 
-            break;
+    pa_assert(u);
+    pa_assert(u->sink == s);
+    pa_assert(!pa_bluetooth_profile_should_attenuate_volume(u->profile));
+    pa_assert(u->transport);
+    pa_assert(u->transport->set_sink_volume);
 
-        case PA_SINK_UNLINKED:
-        case PA_SINK_INIT:
-        case PA_SINK_INVALID_STATE:
-            break;
-    }
+    /* In the AG role, send a command to change speaker gain on the HS/HF */
+    volume = u->transport->set_sink_volume(u->transport, pa_cvolume_max(&s->real_volume));
 
-    return 0;
+    pa_cvolume_set(&s->real_volume, u->encoder_sample_spec.channels, volume);
 }
 
 /* Run from main thread */
-static void sink_set_volume_cb(pa_sink *s) {
-    uint16_t gain;
-    pa_volume_t volume;
+static void sink_setup_volume_callback(pa_sink *s) {
     struct userdata *u;
 
     pa_assert(s);
     pa_assert(s->core);
 
     u = s->userdata;
-
     pa_assert(u);
     pa_assert(u->sink == s);
+    pa_assert(u->transport);
+
+    if (pa_bluetooth_profile_is_a2dp(u->profile) && !u->transport->device->avrcp_absolute_volume)
+        return;
 
-    if (u->transport->set_speaker_gain == NULL)
-      return;
+    /* Remote volume control has to be supported for the callback to make sense,
+     * otherwise this sink should continue performing attenuation in software
+     * without HW_VOLUME_CTL.
+     * If the peer is an AG however backend-native unconditionally provides this
+     * function, PA in the role of HS/HF is responsible for signalling support
+     * by emitting an initial volume command.
+     */
+    if (!u->transport->set_sink_volume)
+        return;
 
-    gain = (pa_cvolume_max(&s->real_volume) * HSP_MAX_GAIN) / PA_VOLUME_NORM;
+    if (pa_bluetooth_profile_should_attenuate_volume(u->profile)) {
+        /* It is yet unknown how (if at all) volume is synchronized for bidirectional
+         * A2DP codecs.  Disallow attaching hooks to a pa_sink if the peer is in
+         * A2DP_SOURCE role.  This assert should be replaced with the proper logic
+         * when bidirectional codecs are implemented.
+         */
+        pa_assert(u->profile != PA_BLUETOOTH_PROFILE_A2DP_SOURCE);
 
-    if (gain > HSP_MAX_GAIN)
-        gain = HSP_MAX_GAIN;
+        if (u->sink_volume_changed_slot)
+            return;
 
-    volume = (pa_volume_t) (gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
+        pa_log_debug("%s: Attaching volume hook to notify peer of changes", s->name);
 
-    /* increment volume by one to correct rounding errors */
-    if (volume < PA_VOLUME_NORM)
-        volume++;
+        u->sink_volume_changed_slot = pa_hook_connect(&s->core->hooks[PA_CORE_HOOK_SINK_VOLUME_CHANGED],
+                                                      PA_HOOK_NORMAL, sink_source_volume_changed_cb, u);
 
-    pa_cvolume_set(&s->real_volume, u->encoder_sample_spec.channels, volume);
+        /* Send initial volume to peer, signalling support for volume control */
+        u->transport->set_sink_volume(u->transport, pa_cvolume_max(&s->real_volume));
+    } else {
+        if (s->set_volume == sink_set_volume_cb)
+            return;
 
-    /* Set soft volume when in headset role */
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
-        pa_cvolume_set(&s->soft_volume, u->encoder_sample_spec.channels, volume);
+        pa_log_debug("%s: Resetting software volume for hardware attenuation by peer", s->name);
 
-    /* If we are in the AG role, we send a command to the head set to change
-     * the speaker gain. In the HS role, source and sink are swapped, so
-     * in this case we notify the AG that the microphone gain has changed */
-    u->transport->set_speaker_gain(u->transport, gain);
+        /* Reset local attenuation */
+        pa_sink_set_soft_volume(s, NULL);
+
+        pa_sink_set_set_volume_callback(s, sink_set_volume_cb);
+
+        if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK)
+            s->n_volume_steps = A2DP_MAX_GAIN + 1;
+        else
+            s->n_volume_steps = HSP_MAX_GAIN + 1;
+    }
 }
 
 /* Run from main thread */
@@ -1159,18 +1252,23 @@ static int add_sink(struct userdata *u) {
     data.name = pa_sprintf_malloc("bluez_sink.%s.%s", u->device->address, pa_bluetooth_profile_to_string(u->profile));
     data.namereg_fail = false;
     pa_proplist_sets(data.proplist, "bluetooth.protocol", pa_bluetooth_profile_to_string(u->profile));
+    if (u->bt_codec)
+        pa_proplist_sets(data.proplist, PA_PROP_BLUETOOTH_CODEC, u->bt_codec->name);
     pa_sink_new_data_set_sample_spec(&data, &u->encoder_sample_spec);
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
+    if (u->profile == PA_BLUETOOTH_PROFILE_HSP_HS
+        || u->profile == PA_BLUETOOTH_PROFILE_HFP_HF)
         pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "phone");
 
     connect_ports(u, &data, PA_DIRECTION_OUTPUT);
 
     if (!u->transport_acquired)
         switch (u->profile) {
-            case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
+            case PA_BLUETOOTH_PROFILE_HFP_AG:
+            case PA_BLUETOOTH_PROFILE_HSP_AG:
                 data.suspend_cause = PA_SUSPEND_USER;
                 break;
-            case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
+            case PA_BLUETOOTH_PROFILE_HSP_HS:
+            case PA_BLUETOOTH_PROFILE_HFP_HF:
                 /* u->stream_fd contains the error returned by the last transport_acquire()
                  * EAGAIN means we are waiting for a NewConnection signal */
                 if (u->stream_fd == -EAGAIN)
@@ -1195,49 +1293,62 @@ static int add_sink(struct userdata *u) {
 
     u->sink->userdata = u;
     u->sink->parent.process_msg = sink_process_msg;
-    u->sink->set_state_in_io_thread = sink_set_state_in_io_thread_cb;
+    //u->sink->set_state_in_io_thread = sink_set_state_in_io_thread_cb;
+
+    sink_setup_volume_callback(u->sink);
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        pa_sink_set_set_volume_callback(u->sink, sink_set_volume_cb);
-        u->sink->n_volume_steps = 16;
-    }
     return 0;
 }
 
 /* Run from main thread */
-static int transport_config(struct userdata *u) {
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        u->encoder_sample_spec.format = PA_SAMPLE_S16LE;
-        u->encoder_sample_spec.channels = 1;
-        u->encoder_sample_spec.rate = 8000;
-        u->decoder_sample_spec.format = PA_SAMPLE_S16LE;
-        u->decoder_sample_spec.channels = 1;
-        u->decoder_sample_spec.rate = 8000;
-        return 0;
-    } else {
-        bool is_a2dp_sink = u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK;
-        void *info;
+static pa_direction_t get_profile_direction(pa_bluetooth_profile_t p) {
+    static const pa_direction_t profile_direction[] = {
+        [PA_BLUETOOTH_PROFILE_A2DP_SINK] = PA_DIRECTION_OUTPUT,
+        [PA_BLUETOOTH_PROFILE_A2DP_SOURCE] = PA_DIRECTION_INPUT,
+        [PA_BLUETOOTH_PROFILE_HSP_HS] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
+        [PA_BLUETOOTH_PROFILE_HSP_AG] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
+        [PA_BLUETOOTH_PROFILE_HFP_HF] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
+        [PA_BLUETOOTH_PROFILE_HFP_AG] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
+        [PA_BLUETOOTH_PROFILE_OFF] = 0
+    };
 
-        pa_assert(u->transport);
+    return profile_direction[p];
+}
 
-        pa_assert(!u->a2dp_codec);
-        pa_assert(!u->encoder_info);
-        pa_assert(!u->decoder_info);
+/* Run from main thread */
+static int transport_config(struct userdata *u) {
+    pa_assert(u);
+    pa_assert(u->transport);
+    pa_assert(!u->bt_codec);
+    pa_assert(!u->encoder_info);
+    pa_assert(!u->decoder_info);
 
-        u->a2dp_codec = u->transport->a2dp_codec;
-        pa_assert(u->a2dp_codec);
+    u->bt_codec = u->transport->bt_codec;
+    pa_assert(u->bt_codec);
 
-        info = u->a2dp_codec->init(is_a2dp_sink, false, u->transport->config, u->transport->config_size, is_a2dp_sink ? &u->encoder_sample_spec : &u->decoder_sample_spec);
-        if (is_a2dp_sink)
-            u->encoder_info = info;
-        else
-            u->decoder_info = info;
+    /* reset encoder buffer contents */
+    u->encoder_buffer_used = 0;
 
-        if (!info)
+    if (get_profile_direction(u->profile) & PA_DIRECTION_OUTPUT) {
+        u->encoder_info = u->bt_codec->init(true, false, u->transport->config, u->transport->config_size, &u->encoder_sample_spec, u->core);
+
+        if (!u->encoder_info)
             return -1;
+    }
 
-        return 0;
+    if (get_profile_direction(u->profile) & PA_DIRECTION_INPUT) {
+        u->decoder_info = u->bt_codec->init(false, false, u->transport->config, u->transport->config_size, &u->decoder_sample_spec, u->core);
+
+        if (!u->decoder_info) {
+            if (u->encoder_info) {
+                u->bt_codec->deinit(u->encoder_info);
+                u->encoder_info = NULL;
+            }
+            return -1;
+        }
     }
+
+    return 0;
 }
 
 /* Run from main thread */
@@ -1257,7 +1368,7 @@ static int setup_transport(struct userdata *u) {
 
     u->transport = t;
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
+    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE || u->profile == PA_BLUETOOTH_PROFILE_HFP_AG || u->profile == PA_BLUETOOTH_PROFILE_HSP_AG)
         transport_acquire(u, true); /* In case of error, the sink/sources will be created suspended */
     else {
         int transport_error;
@@ -1270,26 +1381,16 @@ static int setup_transport(struct userdata *u) {
     return transport_config(u);
 }
 
-/* Run from main thread */
-static pa_direction_t get_profile_direction(pa_bluetooth_profile_t p) {
-    static const pa_direction_t profile_direction[] = {
-        [PA_BLUETOOTH_PROFILE_A2DP_SINK] = PA_DIRECTION_OUTPUT,
-        [PA_BLUETOOTH_PROFILE_A2DP_SOURCE] = PA_DIRECTION_INPUT,
-        [PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
-        [PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
-        [PA_BLUETOOTH_PROFILE_OFF] = 0
-    };
-
-    return profile_direction[p];
-}
-
 /* Run from main thread */
 static int init_profile(struct userdata *u) {
     int r = 0;
     pa_assert(u);
     pa_assert(u->profile != PA_BLUETOOTH_PROFILE_OFF);
 
-    if (setup_transport(u) < 0)
+    r = setup_transport(u);
+    if (r == -EINPROGRESS)
+        return 0;
+    else if (r < 0)
         return -1;
 
     pa_assert(u->transport);
@@ -1305,29 +1406,26 @@ static int init_profile(struct userdata *u) {
     return r;
 }
 
-static int write_block(struct userdata *u) {
-    int n_written;
+static int bt_render_block(struct userdata *u) {
+    int n_rendered;
 
     if (u->write_index <= 0)
         u->started_at = pa_rtclock_now();
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
-        if ((n_written = a2dp_process_render(u)) < 0)
-            return -1;
-    } else {
-        if ((n_written = sco_process_render(u)) < 0)
-            return -1;
-    }
+    n_rendered = bt_process_render(u);
 
-    return n_written;
-}
+    if (n_rendered < 0)
+        n_rendered = -1;
 
+    return n_rendered;
+}
 
 /* I/O thread function */
 static void thread_func(void *userdata) {
     struct userdata *u = userdata;
     unsigned blocks_to_write = 0;
     unsigned bytes_to_write = 0;
+    struct timeval tv_last_output_rate_change;
 
     pa_assert(u);
     pa_assert(u->transport);
@@ -1343,6 +1441,8 @@ static void thread_func(void *userdata) {
     if (u->transport_acquired)
         setup_stream(u);
 
+    pa_gettimeofday(&tv_last_output_rate_change);
+
     for (;;) {
         struct pollfd *pollfd;
         int ret;
@@ -1385,17 +1485,21 @@ static void thread_func(void *userdata) {
                 if (pollfd->revents & POLLIN) {
                     int n_read;
 
-                    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE)
-                        n_read = a2dp_process_push(u);
-                    else
-                        n_read = sco_process_push(u);
+                    n_read = bt_process_push(u);
 
                     if (n_read < 0)
                         goto fail;
 
                     if (have_sink && n_read > 0) {
-                        /* We just read something, so we are supposed to write something, too */
-                        bytes_to_write += n_read;
+                        /* We just read something, so we are supposed to write something, too
+                         *
+                         * If source and sink sample specifications are not equal,
+                         * expected write size needs to be adjusted accordingly.
+                         */
+                        if (pa_sample_spec_equal(&u->encoder_sample_spec, &u->decoder_sample_spec))
+                            bytes_to_write += n_read;
+                        else
+                            bytes_to_write += pa_usec_to_bytes(pa_bytes_to_usec(n_read, &u->decoder_sample_spec), &u->encoder_sample_spec);
                         blocks_to_write += bytes_to_write / u->write_block_size;
                         bytes_to_write = bytes_to_write % u->write_block_size;
                     }
@@ -1417,28 +1521,39 @@ static void thread_func(void *userdata) {
                  * for the sink */
                 if (have_source) {
 
-                    if (writable && blocks_to_write > 0) {
+                    /* If the stream is writable, send some data if necessary */
+                    if (writable) {
                         int result;
 
-                        if ((result = write_block(u)) < 0)
+                        if (blocks_to_write > 0) {
+                            result = bt_render_block(u);
+                            if (result < 0)
+                                goto fail;
+                            blocks_to_write -= result;
+                        }
+
+                        result = bt_write_buffer(u);
+
+                        if (result < 0)
                             goto fail;
 
-                        blocks_to_write -= result;
-
-                        /* writable controls whether we set POLLOUT when polling - we set it to
-                         * false to enable POLLOUT. If there are more blocks to write, we want to
-                         * be woken up immediately when the socket becomes writable. If there
-                         * aren't currently any more blocks to write, then we'll have to wait
-                         * until we've received more data, so in that case we only want to set
-                         * POLLIN. Note that when we are woken up the next time, POLLOUT won't be
-                         * set in revents even if the socket has meanwhile become writable, which
-                         * may seem bad, but in that case we'll set POLLOUT in the subsequent
-                         * poll, and the poll will return immediately, so our writes won't be
-                         * delayed. */
-                        if (blocks_to_write > 0)
+                        if (result)
                             writable = false;
                     }
 
+                    /* writable controls whether we set POLLOUT when polling - we set it to
+                     * false to enable POLLOUT. If there are more blocks to write, we want to
+                     * be woken up immediately when the socket becomes writable. If there
+                     * aren't currently any more blocks to write, then we'll have to wait
+                     * until we've received more data, so in that case we only want to set
+                     * POLLIN. Note that when we are woken up the next time, POLLOUT won't be
+                     * set in revents even if the socket has meanwhile become writable, which
+                     * may seem bad, but in that case we'll set POLLOUT in the subsequent
+                     * poll, and the poll will return immediately, so our writes won't be
+                     * delayed. */
+                    if (blocks_to_write > 0)
+                        writable = false;
+
                 /* There is no source, we have to use the system clock for timing */
                 } else {
                     bool have_written = false;
@@ -1461,7 +1576,7 @@ static void thread_func(void *userdata) {
                         if (bytes_to_send > 2 * u->write_block_size) {
                             uint64_t skip_bytes;
                             pa_memchunk tmp;
-                            size_t mempool_max_block_size = pa_mempool_block_size_max(u->core->mempool);
+                            size_t max_render_size = pa_frame_align(pa_mempool_block_size_max(u->core->mempool), &u->encoder_sample_spec);
                             pa_usec_t skip_usec;
 
                             skip_bytes = bytes_to_send - 2 * u->write_block_size;
@@ -1474,8 +1589,8 @@ static void thread_func(void *userdata) {
                             while (skip_bytes > 0) {
                                 size_t bytes_to_render;
 
-                                if (skip_bytes > mempool_max_block_size)
-                                    bytes_to_render = mempool_max_block_size;
+                                if (skip_bytes > max_render_size)
+                                    bytes_to_render = max_render_size;
                                 else
                                     bytes_to_render = skip_bytes;
 
@@ -1485,12 +1600,13 @@ static void thread_func(void *userdata) {
                                 skip_bytes -= bytes_to_render;
                             }
 
-                            if (u->write_index > 0 && u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
-                                size_t new_write_block_size = u->a2dp_codec->reduce_encoder_bitrate(u->encoder_info, u->write_link_mtu);
+                            if (u->write_index > 0 && (get_profile_direction(u->profile) & PA_DIRECTION_OUTPUT)) {
+                                size_t new_write_block_size = u->bt_codec->reduce_encoder_bitrate(u->encoder_info, u->write_link_mtu);
                                 if (new_write_block_size) {
                                     u->write_block_size = new_write_block_size;
                                     handle_sink_block_size_change(u);
                                 }
+                                pa_gettimeofday(&tv_last_output_rate_change);
                             }
                         }
 
@@ -1498,16 +1614,25 @@ static void thread_func(void *userdata) {
                     }
 
                     /* If the stream is writable, send some data if necessary */
-                    if (writable && blocks_to_write > 0) {
+                    if (writable) {
                         int result;
 
-                        if ((result = write_block(u)) < 0)
+                        if (blocks_to_write > 0) {
+                            int result = bt_render_block(u);
+                            if (result < 0)
+                                goto fail;
+                            blocks_to_write -= result;
+                        }
+
+                        result = bt_write_buffer(u);
+
+                        if (result < 0)
                             goto fail;
 
-                        blocks_to_write -= result;
-                        writable = false;
-                        if (result)
+                        if (result) {
+                            writable = false;
                             have_written = true;
+                        }
                     }
 
                     /* If nothing was written during this iteration, either the stream
@@ -1523,6 +1648,19 @@ static void thread_func(void *userdata) {
                             next_write_at = pa_bytes_to_usec(u->write_index, &u->encoder_sample_spec);
                             sleep_for = time_passed < next_write_at ? next_write_at - time_passed : 0;
                             /* pa_log("Sleeping for %lu; time passed %lu, next write at %lu", (unsigned long) sleep_for, (unsigned long) time_passed, (unsigned long)next_write_at); */
+
+                            if ((get_profile_direction(u->profile) & PA_DIRECTION_OUTPUT) && u->write_memchunk.memblock == NULL) {
+                                /* bt_write_buffer() is keeping up with input, try increasing bitrate */
+                                if (u->bt_codec->increase_encoder_bitrate
+                                    && pa_timeval_age(&tv_last_output_rate_change) >= u->device->output_rate_refresh_interval_ms * PA_USEC_PER_MSEC) {
+                                    size_t new_write_block_size = u->bt_codec->increase_encoder_bitrate(u->encoder_info, u->write_link_mtu);
+                                    if (new_write_block_size) {
+                                        u->write_block_size = new_write_block_size;
+                                        handle_sink_block_size_change(u);
+                                    }
+                                    pa_gettimeofday(&tv_last_output_rate_change);
+                                }
+                            }
                         } else
                             /* We could not write because the stream was not ready. Let's try
                              * again in 500 ms and drop audio if we still can't write. The
@@ -1590,7 +1728,7 @@ static int start_thread(struct userdata *u) {
 
         /* If we are in the headset role, the sink should not become default
          * unless there is no other sound device available. */
-        if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
+        if (u->profile == PA_BLUETOOTH_PROFILE_HFP_AG || u->profile == PA_BLUETOOTH_PROFILE_HSP_AG)
             u->sink->priority = 1500;
 
         pa_sink_put(u->sink);
@@ -1606,7 +1744,7 @@ static int start_thread(struct userdata *u) {
         /* If we are in the headset role or the device is an a2dp source,
          * the source should not become default unless there is no other
          * sound device available. */
-        if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY || u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE)
+        if (u->profile == PA_BLUETOOTH_PROFILE_HFP_AG || u->profile == PA_BLUETOOTH_PROFILE_HSP_AG || u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE)
             u->source->priority = 1500;
 
         pa_source_put(u->source);
@@ -1615,6 +1753,26 @@ static int start_thread(struct userdata *u) {
             u->source->set_volume(u->source);
     }
 
+    if (u->sink || u->source)
+        if (u->bt_codec)
+            pa_proplist_sets(u->card->proplist, PA_PROP_BLUETOOTH_CODEC, u->bt_codec->name);
+
+    /* Now that everything is set up we are ready to check for the Volume property.
+     * Sometimes its initial "change" notification arrives too early when the sink
+     * is not available or still in UNLINKED state; check it again here to know if
+     * our sink peer supports Absolute Volume; in that case we should not perform
+     * any attenuation but delegate all set_volume calls to the peer through this
+     * Volume property.
+     *
+     * Note that this works the other way around if the peer is in source profile:
+     * we are rendering audio and hence responsible for applying attenuation.  The
+     * set_volume callback is always registered, and Volume is always passed to
+     * BlueZ unconditionally.  BlueZ only sends a notification to the peer if it
+     * registered a notification request for absolute volume previously.
+     */
+    if (u->transport && u->sink)
+        pa_bluetooth_transport_load_a2dp_sink_volume(u->transport);
+
     return 0;
 }
 
@@ -1622,6 +1780,9 @@ static int start_thread(struct userdata *u) {
 static void stop_thread(struct userdata *u) {
     pa_assert(u);
 
+    if (u->sink || u->source)
+        pa_proplist_unset(u->card->proplist, PA_PROP_BLUETOOTH_CODEC);
+
     if (u->sink)
         pa_sink_unlink(u->sink);
 
@@ -1650,6 +1811,16 @@ static void stop_thread(struct userdata *u) {
         u->transport = NULL;
     }
 
+    if (u->sink_volume_changed_slot) {
+        pa_hook_slot_free(u->sink_volume_changed_slot);
+        u->sink_volume_changed_slot = NULL;
+    }
+
+    if (u->source_volume_changed_slot) {
+        pa_hook_slot_free(u->source_volume_changed_slot);
+        u->source_volume_changed_slot = NULL;
+    }
+
     if (u->sink) {
         pa_sink_unref(u->sink);
         u->sink = NULL;
@@ -1661,23 +1832,42 @@ static void stop_thread(struct userdata *u) {
     }
 
     if (u->read_smoother) {
+#ifdef USE_SMOOTHER_2
+        pa_smoother_2_free(u->read_smoother);
+#else
         pa_smoother_free(u->read_smoother);
+#endif
         u->read_smoother = NULL;
     }
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK || u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE) {
+    if (u->bt_codec) {
         if (u->encoder_info) {
-            u->a2dp_codec->deinit(u->encoder_info);
+            u->bt_codec->deinit(u->encoder_info);
             u->encoder_info = NULL;
         }
 
         if (u->decoder_info) {
-            u->a2dp_codec->deinit(u->decoder_info);
+            u->bt_codec->deinit(u->decoder_info);
             u->decoder_info = NULL;
         }
 
-        u->a2dp_codec = NULL;
+        u->bt_codec = NULL;
+    }
+
+    if (u->encoder_buffer) {
+        pa_xfree(u->encoder_buffer);
+        u->encoder_buffer = NULL;
     }
+
+    u->encoder_buffer_size = 0;
+    u->encoder_buffer_used = 0;
+
+    if (u->decoder_buffer) {
+        pa_xfree(u->decoder_buffer);
+        u->decoder_buffer = NULL;
+    }
+
+    u->decoder_buffer_size = 0;
 }
 
 /* Run from main thread */
@@ -1731,6 +1921,7 @@ static pa_available_t transport_state_to_availability(pa_bluetooth_transport_sta
 static void create_card_ports(struct userdata *u, pa_hashmap *ports) {
     pa_device_port *port;
     pa_device_port_new_data port_data;
+    pa_device_port_type_t input_type, output_type;
     const char *name_prefix, *input_description, *output_description;
 
     pa_assert(u);
@@ -1740,60 +1931,67 @@ static void create_card_ports(struct userdata *u, pa_hashmap *ports) {
     name_prefix = "unknown";
     input_description = _("Bluetooth Input");
     output_description = _("Bluetooth Output");
+    input_type = output_type = PA_DEVICE_PORT_TYPE_BLUETOOTH;
 
     switch (form_factor_from_class(u->device->class_of_device)) {
         case PA_BLUETOOTH_FORM_FACTOR_HEADSET:
             name_prefix = "headset";
             input_description = output_description = _("Headset");
+            input_type = output_type = PA_DEVICE_PORT_TYPE_HEADSET;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_HANDSFREE:
             name_prefix = "handsfree";
             input_description = output_description = _("Handsfree");
+            input_type = output_type = PA_DEVICE_PORT_TYPE_HANDSFREE;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_MICROPHONE:
             name_prefix = "microphone";
             input_description = _("Microphone");
             output_description = _("Bluetooth Output");
+            input_type = PA_DEVICE_PORT_TYPE_MIC;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_SPEAKER:
             name_prefix = "speaker";
             input_description = _("Bluetooth Input");
             output_description = _("Speaker");
+            output_type = PA_DEVICE_PORT_TYPE_SPEAKER;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_HEADPHONE:
             name_prefix = "headphone";
             input_description = _("Bluetooth Input");
             output_description = _("Headphone");
+            output_type = PA_DEVICE_PORT_TYPE_HEADPHONES;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_PORTABLE:
             name_prefix = "portable";
             input_description = output_description = _("Portable");
+            input_type = output_type = PA_DEVICE_PORT_TYPE_PORTABLE;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_CAR:
             name_prefix = "car";
             input_description = output_description = _("Car");
+            input_type = output_type = PA_DEVICE_PORT_TYPE_CAR;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_HIFI:
             name_prefix = "hifi";
             input_description = output_description = _("HiFi");
+            input_type = output_type = PA_DEVICE_PORT_TYPE_HIFI;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_PHONE:
             name_prefix = "phone";
             input_description = output_description = _("Phone");
+            input_type = output_type = PA_DEVICE_PORT_TYPE_PHONE;
             break;
 
         case PA_BLUETOOTH_FORM_FACTOR_UNKNOWN:
-            name_prefix = "unknown";
-            input_description = _("Bluetooth Input");
-            output_description = _("Bluetooth Output");
             break;
     }
 
@@ -1802,6 +2000,7 @@ static void create_card_ports(struct userdata *u, pa_hashmap *ports) {
     pa_device_port_new_data_set_name(&port_data, u->output_port_name);
     pa_device_port_new_data_set_description(&port_data, output_description);
     pa_device_port_new_data_set_direction(&port_data, PA_DIRECTION_OUTPUT);
+    //pa_device_port_new_data_set_type(&port_data, output_type);
     pa_device_port_new_data_set_available(&port_data, get_port_availability(u, PA_DIRECTION_OUTPUT));
     pa_assert_se(port = pa_device_port_new(u->core, &port_data, 0));
     pa_assert_se(pa_hashmap_put(ports, port->name, port) >= 0);
@@ -1812,6 +2011,7 @@ static void create_card_ports(struct userdata *u, pa_hashmap *ports) {
     pa_device_port_new_data_set_name(&port_data, u->input_port_name);
     pa_device_port_new_data_set_description(&port_data, input_description);
     pa_device_port_new_data_set_direction(&port_data, PA_DIRECTION_INPUT);
+    //pa_device_port_new_data_set_type(&port_data, input_type);
     pa_device_port_new_data_set_available(&port_data, get_port_availability(u, PA_DIRECTION_INPUT));
     pa_assert_se(port = pa_device_port_new(u->core, &port_data, 0));
     pa_assert_se(pa_hashmap_put(ports, port->name, port) >= 0);
@@ -1857,8 +2057,34 @@ static pa_card_profile *create_card_profile(struct userdata *u, pa_bluetooth_pro
         p = PA_CARD_PROFILE_DATA(cp);
         break;
 
-    case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
-        cp = pa_card_profile_new(name, _("Headset Head Unit (HSP/HFP)"), sizeof(pa_bluetooth_profile_t));
+    case PA_BLUETOOTH_PROFILE_HSP_HS:
+        cp = pa_card_profile_new(name, _("Headset Head Unit (HSP)"), sizeof(pa_bluetooth_profile_t));
+        cp->priority = 30;
+        cp->n_sinks = 1;
+        cp->n_sources = 1;
+        cp->max_sink_channels = 1;
+        cp->max_source_channels = 1;
+        pa_hashmap_put(input_port->profiles, cp->name, cp);
+        pa_hashmap_put(output_port->profiles, cp->name, cp);
+
+        p = PA_CARD_PROFILE_DATA(cp);
+        break;
+
+    case PA_BLUETOOTH_PROFILE_HSP_AG:
+        cp = pa_card_profile_new(name, _("Headset Audio Gateway (HSP)"), sizeof(pa_bluetooth_profile_t));
+        cp->priority = 10;
+        cp->n_sinks = 1;
+        cp->n_sources = 1;
+        cp->max_sink_channels = 1;
+        cp->max_source_channels = 1;
+        pa_hashmap_put(input_port->profiles, cp->name, cp);
+        pa_hashmap_put(output_port->profiles, cp->name, cp);
+
+        p = PA_CARD_PROFILE_DATA(cp);
+        break;
+
+    case PA_BLUETOOTH_PROFILE_HFP_HF:
+         cp = pa_card_profile_new(name, _("Handsfree Head Unit (HFP)"), sizeof(pa_bluetooth_profile_t));
         cp->priority = 30;
         cp->n_sinks = 1;
         cp->n_sources = 1;
@@ -1870,8 +2096,8 @@ static pa_card_profile *create_card_profile(struct userdata *u, pa_bluetooth_pro
         p = PA_CARD_PROFILE_DATA(cp);
         break;
 
-    case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
-        cp = pa_card_profile_new(name, _("Headset Audio Gateway (HSP/HFP)"), sizeof(pa_bluetooth_profile_t));
+    case PA_BLUETOOTH_PROFILE_HFP_AG:
+        cp = pa_card_profile_new(name, _("Handsfree Audio Gateway (HFP)"), sizeof(pa_bluetooth_profile_t));
         cp->priority = 10;
         cp->n_sinks = 1;
         cp->n_sources = 1;
@@ -1944,10 +2170,14 @@ static int uuid_to_profile(const char *uuid, pa_bluetooth_profile_t *_r) {
         *_r = PA_BLUETOOTH_PROFILE_A2DP_SINK;
     else if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE))
         *_r = PA_BLUETOOTH_PROFILE_A2DP_SOURCE;
-    else if (pa_bluetooth_uuid_is_hsp_hs(uuid) || pa_streq(uuid, PA_BLUETOOTH_UUID_HFP_HF))
-        *_r = PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT;
-    else if (pa_streq(uuid, PA_BLUETOOTH_UUID_HSP_AG) || pa_streq(uuid, PA_BLUETOOTH_UUID_HFP_AG))
-        *_r = PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY;
+    else if (pa_bluetooth_uuid_is_hsp_hs(uuid))
+        *_r = PA_BLUETOOTH_PROFILE_HSP_HS;
+    else if (pa_streq(uuid, PA_BLUETOOTH_UUID_HFP_HF))
+        *_r = PA_BLUETOOTH_PROFILE_HFP_HF;
+    else if (pa_streq(uuid, PA_BLUETOOTH_UUID_HSP_AG))
+        *_r = PA_BLUETOOTH_PROFILE_HSP_AG;
+    else if (pa_streq(uuid, PA_BLUETOOTH_UUID_HFP_AG))
+        *_r = PA_BLUETOOTH_PROFILE_HFP_AG;
     else
         return -PA_ERR_INVALID;
 
@@ -1992,6 +2222,12 @@ static int add_card(struct userdata *u) {
     data.name = pa_sprintf_malloc("bluez_card.%s", d->address);
     data.namereg_fail = false;
 
+    if (d->has_battery_level) {
+        // See device_battery_level_changed_cb
+        uint8_t level = d->battery_level;
+        pa_proplist_setf(data.proplist, "bluetooth.battery", "%d%%", level);
+    }
+
     create_card_ports(u, data.ports);
 
     PA_HASHMAP_FOREACH(uuid, d->uuids, state) {
@@ -2000,8 +2236,18 @@ static int add_card(struct userdata *u) {
         if (uuid_to_profile(uuid, &profile) < 0)
             continue;
 
-        if (pa_hashmap_get(data.profiles, pa_bluetooth_profile_to_string(profile)))
+        pa_log_debug("Trying to create profile %s (%s) for device %s (%s)",
+                     pa_bluetooth_profile_to_string(profile), uuid, d->alias, d->address);
+
+        if (pa_hashmap_get(data.profiles, pa_bluetooth_profile_to_string(profile))) {
+            pa_log_debug("%s already exists", pa_bluetooth_profile_to_string(profile));
             continue;
+        }
+
+        if (!pa_bluetooth_device_supports_profile(d, profile)) {
+            pa_log_debug("%s is not supported by the device or adapter", pa_bluetooth_profile_to_string(profile));
+            continue;
+        }
 
         cp = create_card_profile(u, profile, data.ports);
         pa_hashmap_put(data.profiles, cp->name, cp);
@@ -2046,7 +2292,12 @@ static void handle_transport_state_change(struct userdata *u, struct pa_bluetoot
     pa_assert_se(cp = pa_hashmap_get(u->card->profiles, pa_bluetooth_profile_to_string(t->profile)));
 
     oldavail = cp->available;
-    pa_card_profile_set_available(cp, transport_state_to_availability(t->state));
+    /*
+     * If codec switching is in progress, transport state change should not
+     * make profile unavailable.
+     */
+    if (!t->device->codec_switching_in_progress)
+        pa_card_profile_set_available(cp, transport_state_to_availability(t->state));
 
     /* Update port availability */
     pa_assert_se(port = pa_hashmap_get(u->card->ports, u->output_port_name));
@@ -2116,7 +2367,7 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
     pa_assert(d);
     pa_assert(u);
 
-    if (d != u->device || pa_bluetooth_device_any_transport_connected(d))
+    if (d != u->device || pa_bluetooth_device_any_transport_connected(d) || d->codec_switching_in_progress)
         return PA_HOOK_OK;
 
     pa_log_debug("Unloading module for device %s", d->path);
@@ -2125,6 +2376,25 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
     return PA_HOOK_OK;
 }
 
+static pa_hook_result_t device_battery_level_changed_cb(pa_bluetooth_discovery *y, const pa_bluetooth_device *d, struct userdata *u) {
+    uint8_t level;
+
+    pa_assert(d);
+    pa_assert(u);
+
+    if (d != u->device)
+        return PA_HOOK_OK;
+
+    if (d->has_battery_level) {
+        level = d->battery_level;
+        pa_proplist_setf(u->card->proplist, "bluetooth.battery", "%d%%", level);
+    } else {
+        pa_proplist_unset(u->card->proplist, "bluetooth.battery");
+    }
+
+    return PA_HOOK_OK;
+}
+
 /* Run from main thread */
 static pa_hook_result_t transport_state_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
     pa_assert(t);
@@ -2139,10 +2409,9 @@ static pa_hook_result_t transport_state_changed_cb(pa_bluetooth_discovery *y, pa
     return PA_HOOK_OK;
 }
 
-static pa_hook_result_t transport_speaker_gain_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
+static pa_hook_result_t transport_sink_volume_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
     pa_volume_t volume;
     pa_cvolume v;
-    uint16_t gain;
 
     pa_assert(t);
     pa_assert(u);
@@ -2150,26 +2419,27 @@ static pa_hook_result_t transport_speaker_gain_changed_cb(pa_bluetooth_discovery
     if (t != u->transport)
       return PA_HOOK_OK;
 
-    gain = t->speaker_gain;
-    volume = (pa_volume_t) (gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
+    volume = t->sink_volume;
+
+    if (!u->sink) {
+        pa_log_warn("Received peer transport volume change without connected sink");
+        return PA_HOOK_OK;
+    }
 
-    /* increment volume by one to correct rounding errors */
-    if (volume < PA_VOLUME_NORM)
-        volume++;
+    sink_setup_volume_callback(u->sink);
 
     pa_cvolume_set(&v, u->encoder_sample_spec.channels, volume);
-    if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
-        pa_sink_volume_changed(u->sink, &v);
-    else
+    if (pa_bluetooth_profile_should_attenuate_volume(t->profile))
         pa_sink_set_volume(u->sink, &v, true, true);
+    else
+        pa_sink_volume_changed(u->sink, &v);
 
     return PA_HOOK_OK;
 }
 
-static pa_hook_result_t transport_microphone_gain_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
+static pa_hook_result_t transport_source_volume_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
     pa_volume_t volume;
     pa_cvolume v;
-    uint16_t gain;
 
     pa_assert(t);
     pa_assert(u);
@@ -2177,23 +2447,54 @@ static pa_hook_result_t transport_microphone_gain_changed_cb(pa_bluetooth_discov
     if (t != u->transport)
       return PA_HOOK_OK;
 
-    gain = t->microphone_gain;
-    volume = (pa_volume_t) (gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
+    volume = t->source_volume;
 
-    /* increment volume by one to correct rounding errors */
-    if (volume < PA_VOLUME_NORM)
-        volume++;
+    if (!u->source) {
+        pa_log_warn("Received peer transport volume change without connected source");
+        return PA_HOOK_OK;
+    }
+
+    source_setup_volume_callback(u->source);
 
     pa_cvolume_set(&v, u->decoder_sample_spec.channels, volume);
 
-    if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
-        pa_source_volume_changed(u->source, &v);
-    else
+    if (pa_bluetooth_profile_should_attenuate_volume(t->profile))
         pa_source_set_volume(u->source, &v, true, true);
+    else
+        pa_source_volume_changed(u->source, &v);
 
     return PA_HOOK_OK;
 }
 
+static void switch_codec_cb_handler(bool success, pa_bluetooth_profile_t profile, void *userdata)
+{
+    struct userdata *u = (struct userdata *) userdata;
+
+    if (!success)
+        goto off;
+
+    u->profile = profile;
+
+    if (init_profile(u) < 0) {
+        pa_log_info("Failed to initialise profile after codec switching");
+        goto off;
+    }
+
+    if (u->sink || u->source)
+        if (start_thread(u) < 0) {
+            pa_log_info("Failed to start thread after codec switching");
+            goto off;
+        }
+
+    pa_log_info("Codec successfully switched to %s with profile: %s",
+            u->bt_codec->name, pa_bluetooth_profile_to_string(u->profile));
+
+    return;
+
+off:
+    pa_assert_se(pa_card_set_profile(u->card, pa_hashmap_get(u->card->profiles, "off"), false) >= 0);
+}
+
 /* Run from main thread context */
 static int device_process_msg(pa_msgobject *obj, int code, void *data, int64_t offset, pa_memchunk *chunk) {
     struct bluetooth_msg *m = BLUETOOTH_MSG(obj);
@@ -2230,13 +2531,16 @@ int pa__init(pa_module* m) {
     struct userdata *u;
     const char *path;
     pa_modargs *ma;
-    bool autodetect_mtu;
+    bool autodetect_mtu, avrcp_absolute_volume;
+    char *message_handler_path;
+    uint32_t output_rate_refresh_interval_ms;
 
     pa_assert(m);
 
     m->userdata = u = pa_xnew0(struct userdata, 1);
     u->module = m;
     u->core = m->core;
+    u->message_handler_registered = false;
 
     if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
         pa_log_error("Failed to parse module arguments");
@@ -2268,21 +2572,41 @@ int pa__init(pa_module* m) {
 
     u->device->autodetect_mtu = autodetect_mtu;
 
+    output_rate_refresh_interval_ms = DEFAULT_OUTPUT_RATE_REFRESH_INTERVAL_MS;
+    if (pa_modargs_get_value_u32(ma, "output_rate_refresh_interval_ms", &output_rate_refresh_interval_ms) < 0) {
+        pa_log("Invalid value for output_rate_refresh_interval parameter.");
+        goto fail_free_modargs;
+    }
+
+    u->device->output_rate_refresh_interval_ms = output_rate_refresh_interval_ms;
+
+    avrcp_absolute_volume = true;
+    if (pa_modargs_get_value_boolean(ma, "avrcp_absolute_volume", &avrcp_absolute_volume) < 0) {
+        pa_log("Invalid boolean value for avrcp_absolute_volume parameter");
+        goto fail_free_modargs;
+    }
+
+    u->device->avrcp_absolute_volume = avrcp_absolute_volume;
+
     pa_modargs_free(ma);
 
     u->device_connection_changed_slot =
         pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_DEVICE_CONNECTION_CHANGED),
                         PA_HOOK_NORMAL, (pa_hook_cb_t) device_connection_changed_cb, u);
 
+    u->device_battery_level_changed_slot =
+        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_DEVICE_BATTERY_LEVEL_CHANGED),
+                        PA_HOOK_NORMAL, (pa_hook_cb_t) device_battery_level_changed_cb, u);
+
     u->transport_state_changed_slot =
         pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_STATE_CHANGED),
                         PA_HOOK_NORMAL, (pa_hook_cb_t) transport_state_changed_cb, u);
 
-    u->transport_speaker_gain_changed_slot =
-        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED), PA_HOOK_NORMAL, (pa_hook_cb_t) transport_speaker_gain_changed_cb, u);
+    u->transport_sink_volume_changed_slot =
+        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_SINK_VOLUME_CHANGED), PA_HOOK_NORMAL, (pa_hook_cb_t) transport_sink_volume_changed_cb, u);
 
-    u->transport_microphone_gain_changed_slot =
-        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED), PA_HOOK_NORMAL, (pa_hook_cb_t) transport_microphone_gain_changed_cb, u);
+    u->transport_source_volume_changed_slot =
+        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_SOURCE_VOLUME_CHANGED), PA_HOOK_NORMAL, (pa_hook_cb_t) transport_source_volume_changed_cb, u);
 
     if (add_card(u) < 0)
         goto fail;
@@ -2302,6 +2626,13 @@ int pa__init(pa_module* m) {
         if (start_thread(u) < 0)
             goto off;
 
+    //message_handler_path = make_message_handler_path(u->card->name);
+    //pa_message_handler_register(m->core, message_handler_path, "Bluez5 device message handler",
+    //        bluez5_device_message_handler, (void *) u);
+    //pa_log_info("Bluez5 device message handler registered at path: %s", message_handler_path);
+    //pa_xfree(message_handler_path);
+    //u->message_handler_registered = true;
+
     return 0;
 
 off:
@@ -2324,6 +2655,7 @@ fail:
 }
 
 void pa__done(pa_module *m) {
+    char *message_handler_path;
     struct userdata *u;
 
     pa_assert(m);
@@ -2331,19 +2663,28 @@ void pa__done(pa_module *m) {
     if (!(u = m->userdata))
         return;
 
+    //if (u->message_handler_registered) {
+    //    message_handler_path = make_message_handler_path(u->card->name);
+    //    pa_message_handler_unregister(m->core, message_handler_path);
+    //   pa_xfree(message_handler_path);
+    //}
+
     stop_thread(u);
 
     if (u->device_connection_changed_slot)
         pa_hook_slot_free(u->device_connection_changed_slot);
 
+    if (u->device_battery_level_changed_slot)
+        pa_hook_slot_free(u->device_battery_level_changed_slot);
+
     if (u->transport_state_changed_slot)
         pa_hook_slot_free(u->transport_state_changed_slot);
 
-    if (u->transport_speaker_gain_changed_slot)
-        pa_hook_slot_free(u->transport_speaker_gain_changed_slot);
+    if (u->transport_sink_volume_changed_slot)
+        pa_hook_slot_free(u->transport_sink_volume_changed_slot);
 
-    if (u->transport_microphone_gain_changed_slot)
-        pa_hook_slot_free(u->transport_microphone_gain_changed_slot);
+    if (u->transport_source_volume_changed_slot)
+        pa_hook_slot_free(u->transport_source_volume_changed_slot);
 
     if (u->encoder_buffer)
         pa_xfree(u->encoder_buffer);
diff --git a/src/modules/bluetooth/module-bluez5-discover.c b/src/modules/bluetooth/module-bluez5-discover.c
index b6c8eb0..b13517e 100755
--- a/src/modules/bluetooth/module-bluez5-discover.c
+++ b/src/modules/bluetooth/module-bluez5-discover.c
@@ -37,11 +37,21 @@ PA_MODULE_LOAD_ONCE(true);
 PA_MODULE_USAGE(
     "headset=ofono|native|auto"
     "autodetect_mtu=<boolean>"
+    "enable_msbc=<boolean, enable mSBC support in native and oFono backends, default is true>"
+    "output_rate_refresh_interval_ms=<interval between attempts to improve output rate in milliseconds>"
+    "enable_native_hsp_hs=<boolean, enable HSP support in native backend>"
+    "enable_native_hfp_hf=<boolean, enable HFP support in native backend>"
+    "avrcp_absolute_volume=<synchronize volume with peer, true by default>"
 );
 
 static const char* const valid_modargs[] = {
     "headset",
     "autodetect_mtu",
+    "enable_msbc",
+    "output_rate_refresh_interval_ms",
+    "enable_native_hsp_hs",
+    "enable_native_hfp_hf",
+    "avrcp_absolute_volume",
     NULL
 };
 
@@ -52,6 +62,8 @@ struct userdata {
     pa_hook_slot *device_connection_changed_slot;
     pa_bluetooth_discovery *discovery;
     bool autodetect_mtu;
+    bool avrcp_absolute_volume;
+    uint32_t output_rate_refresh_interval_ms;
 };
 
 static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y, const pa_bluetooth_device *d, struct userdata *u) {
@@ -62,7 +74,9 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
 
     module_loaded = pa_hashmap_get(u->loaded_device_paths, d->path) ? true : false;
 
-    if (module_loaded && !pa_bluetooth_device_any_transport_connected(d)) {
+    /* When changing A2DP codec there is no transport connected, ensure that no module is unloaded */
+    if (module_loaded && !pa_bluetooth_device_any_transport_connected(d) &&
+            !d->codec_switching_in_progress) {
         /* disconnection, the module unloads itself */
         pa_log_debug("Unregistering module for %s", d->path);
         pa_hashmap_remove(u->loaded_device_paths, d->path);
@@ -72,7 +86,12 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
     if (!module_loaded && pa_bluetooth_device_any_transport_connected(d)) {
         /* a new device has been connected */
         pa_module *m;
-        char *args = pa_sprintf_malloc("path=%s autodetect_mtu=%i", d->path, (int)u->autodetect_mtu);
+        char *args = pa_sprintf_malloc("path=%s autodetect_mtu=%i output_rate_refresh_interval_ms=%u"
+                                       " avrcp_absolute_volume=%i",
+                                       d->path,
+                                       (int)u->autodetect_mtu,
+                                       u->output_rate_refresh_interval_ms,
+                                       (int)u->avrcp_absolute_volume);
 
         pa_log_debug("Loading module-bluez5-device %s", args);
         pa_module_load(&m, u->module->core, "module-bluez5-device", args);
@@ -92,7 +111,7 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
 }
 
 #ifdef HAVE_BLUEZ_5_NATIVE_HEADSET
-const char *default_headset_backend = "auto";
+const char *default_headset_backend = "native";
 #else
 const char *default_headset_backend = "ofono";
 #endif
@@ -103,6 +122,11 @@ int pa__init(pa_module *m) {
     const char *headset_str;
     int headset_backend;
     bool autodetect_mtu;
+    bool enable_msbc;
+    bool avrcp_absolute_volume;
+    uint32_t output_rate_refresh_interval_ms;
+    bool enable_native_hsp_hs;
+    bool enable_native_hfp_hf;
 
     pa_assert(m);
 
@@ -123,9 +147,37 @@ int pa__init(pa_module *m) {
         goto fail;
     }
 
+    /* default value if no module parameter */
+    enable_native_hfp_hf = (headset_backend == HEADSET_BACKEND_NATIVE);
+
     autodetect_mtu = false;
     if (pa_modargs_get_value_boolean(ma, "autodetect_mtu", &autodetect_mtu) < 0) {
         pa_log("Invalid boolean value for autodetect_mtu parameter");
+    }
+    enable_msbc = true;
+    if (pa_modargs_get_value_boolean(ma, "enable_msbc", &enable_msbc) < 0) {
+        pa_log("Invalid boolean value for enable_msbc parameter");
+    }
+    enable_native_hfp_hf = true;
+    if (pa_modargs_get_value_boolean(ma, "enable_native_hfp_hf", &enable_native_hfp_hf) < 0) {
+        pa_log("enable_native_hfp_hf must be true or false");
+        goto fail;
+    }
+    enable_native_hsp_hs = !enable_native_hfp_hf;
+    if (pa_modargs_get_value_boolean(ma, "enable_native_hsp_hs", &enable_native_hsp_hs) < 0) {
+        pa_log("enable_native_hsp_hs must be true or false");
+        goto fail;
+    }
+
+    avrcp_absolute_volume = true;
+    if (pa_modargs_get_value_boolean(ma, "avrcp_absolute_volume", &avrcp_absolute_volume) < 0) {
+        pa_log("avrcp_absolute_volume must be true or false");
+        goto fail;
+    }
+
+    output_rate_refresh_interval_ms = DEFAULT_OUTPUT_RATE_REFRESH_INTERVAL_MS;
+    if (pa_modargs_get_value_u32(ma, "output_rate_refresh_interval_ms", &output_rate_refresh_interval_ms) < 0) {
+        pa_log("Invalid value for output_rate_refresh_interval parameter.");
         goto fail;
     }
 
@@ -133,9 +185,11 @@ int pa__init(pa_module *m) {
     u->module = m;
     u->core = m->core;
     u->autodetect_mtu = autodetect_mtu;
+    u->avrcp_absolute_volume = avrcp_absolute_volume;
+    u->output_rate_refresh_interval_ms = output_rate_refresh_interval_ms;
     u->loaded_device_paths = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
 
-    if (!(u->discovery = pa_bluetooth_discovery_get(u->core, headset_backend)))
+    if (!(u->discovery = pa_bluetooth_discovery_get(u->core, headset_backend, enable_native_hsp_hs, enable_native_hfp_hf, enable_msbc)))
         goto fail;
 
     u->device_connection_changed_slot =
@@ -163,11 +217,11 @@ void pa__done(pa_module *m) {
     if (u->device_connection_changed_slot)
         pa_hook_slot_free(u->device_connection_changed_slot);
 
-    if (u->discovery)
-        pa_bluetooth_discovery_unref(u->discovery);
-
     if (u->loaded_device_paths)
         pa_hashmap_free(u->loaded_device_paths);
 
+    if (u->discovery)
+        pa_bluetooth_discovery_unref(u->discovery);
+
     pa_xfree(u);
 }
diff --git a/src/modules/bluetooth/rtp.h b/src/modules/bluetooth/rtp.h
index 813d9e3..d72c085 100755
--- a/src/modules/bluetooth/rtp.h
+++ b/src/modules/bluetooth/rtp.h
@@ -41,7 +41,7 @@ struct rtp_header {
 	uint32_t csrc[0];
 } __attribute__ ((packed));
 
-struct rtp_sbc_payload {
+struct rtp_payload {
 	uint8_t frame_count:4;
 	uint8_t rfa0:1;
 	uint8_t is_last_fragment:1;
@@ -67,7 +67,7 @@ struct rtp_header {
 	uint32_t csrc[0];
 } __attribute__ ((packed));
 
-struct rtp_sbc_payload {
+struct rtp_payload {
 	uint8_t is_fragmented:1;
 	uint8_t is_first_fragment:1;
 	uint8_t is_last_fragment:1;
diff --git a/src/modules/list.h b/src/modules/list.h
new file mode 100755
index 0000000..f959d2a
--- /dev/null
+++ b/src/modules/list.h
@@ -0,0 +1,72 @@
+
+#ifndef _LIST_H
+#define _LIST_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+struct listnode
+{
+    struct listnode *next;
+    struct listnode *prev;
+};
+
+#define node_to_item(node, container, member) \
+    (container *) (((char*) (node)) - offsetof(container, member))
+
+#define list_declare(name) \
+    struct listnode name = { \
+        .next = &(name), \
+        .prev = &(name), \
+    }
+
+#define list_for_each(node, list) \
+    for ((node) = (list)->next; (node) != (list); (node) = (node)->next)
+
+#define list_for_each_reverse(node, list) \
+    for ((node) = (list)->prev; (node) != (list); (node) = (node)->prev)
+
+#define list_for_each_safe(node, n, list) \
+    for ((node) = (list)->next, (n) = (node)->next; \
+         (node) != (list); \
+         (node) = (n), (n) = (node)->next)
+
+static inline void list_init(struct listnode *node)
+{
+    node->next = node;
+    node->prev = node;
+}
+
+static inline void list_add_tail(struct listnode *head, struct listnode *item)
+{
+    item->next = head;
+    item->prev = head->prev;
+    head->prev->next = item;
+    head->prev = item;
+}
+
+static inline void list_add_head(struct listnode *head, struct listnode *item)
+{
+    item->next = head->next;
+    item->prev = head;
+    head->next->prev = item;
+    head->next = item;
+}
+
+static inline void list_remove(struct listnode *item)
+{
+    item->next->prev = item->prev;
+    item->prev->next = item->next;
+}
+
+#define list_empty(list) ((list) == (list)->next)
+#define list_head(list) ((list)->next)
+#define list_tail(list) ((list)->prev)
+
+#ifdef __cplusplus
+};
+#endif /* __cplusplus */
+
+#endif
+
diff --git a/src/modules/module-device-manager.c b/src/modules/module-device-manager.c
index 15fdaaa..759ea67 100755
--- a/src/modules/module-device-manager.c
+++ b/src/modules/module-device-manager.c
@@ -29,6 +29,16 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+#include <dirent.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/inotify.h>
+#include <linux/input.h>
+#include <err.h>
+#include <sys/poll.h>
+#include <sys/stat.h>
+#include "list.h"
+
 #include <pulse/gccmacro.h>
 #include <pulse/xmalloc.h>
 #include <pulse/timeval.h>
@@ -41,6 +51,7 @@
 #include <pulsecore/log.h>
 #include <pulsecore/core-subscribe.h>
 #include <pulsecore/sink-input.h>
+#include <pulsecore/sink.h>
 #include <pulsecore/source-output.h>
 #include <pulsecore/namereg.h>
 #include <pulsecore/protocol-native.h>
@@ -48,6 +59,8 @@
 #include <pulsecore/pstream-util.h>
 #include <pulsecore/database.h>
 #include <pulsecore/tagstruct.h>
+#include <pulsecore/thread.h>
+
 
 PA_MODULE_AUTHOR("Colin Guthrie");
 PA_MODULE_DESCRIPTION("Keep track of devices (and their descriptions) both past and present and prioritise by role");
@@ -122,6 +135,11 @@ struct userdata {
 
     role_indexes_t preferred_sinks;
     role_indexes_t preferred_sources;
+
+    pa_thread *thread;
+    int devm_wake_pipe;
+    bool thread_exit;
+    int key[3];
 };
 
 #define ENTRY_VERSION 1
@@ -134,6 +152,11 @@ struct entry {
     role_indexes_t priority;
 };
 
+struct prioritised_indexes {
+    uint32_t index;
+    int32_t priority;
+};
+
 enum {
     SUBCOMMAND_TEST,
     SUBCOMMAND_READ,
@@ -150,6 +173,7 @@ enum {
 static void dump_database(struct userdata *);
 #endif
 static void notify_subscribers(struct userdata *);
+static void subscribe_callback(pa_core *c, pa_subscription_event_type_t t, uint32_t idx, void *userdata);
 
 static void save_time_callback(pa_mainloop_api*a, pa_time_event* e, const struct timeval *t, void *userdata) {
     struct userdata *u = userdata;
@@ -487,6 +511,41 @@ static char *get_name(const char *key, const char *prefix) {
     return t;
 }
 
+static int sink_prioity_recheck(struct userdata *u) {
+    uint32_t idx;
+    pa_sink *sink;
+    uint32_t total_devices;
+
+
+    total_devices = PA_MAX(pa_idxset_size(u->core->sinks), pa_idxset_size(u->core->sources));
+    pa_log_info("sink_prioity_recheck:total_devices:%d", total_devices);
+    if (total_devices > 0 && total_devices < 128) {
+        uint32_t i;
+        struct prioritised_indexes p_i[128];
+
+        /* We cycle over all the available sinks so that they are added to our database if they are not in it yet */
+        i = 0;
+        PA_IDXSET_FOREACH(sink, u->core->sinks, idx) {
+            pa_log_info("sink_prioity_recheck:Found sink index %u,sink->priority:%d,sink->name:%s \n", sink->index,sink->priority,sink->name);
+            p_i[i  ].index = sink->index;
+            p_i[i++].priority = sink->priority;
+        }
+        /* Bubble sort it (only really useful for first time creation) */
+        if (i > 1)
+          for (uint32_t j = 0; j < i; ++j)
+              for (uint32_t k = 0; k < i; ++k)
+                  if (p_i[j].priority > p_i[k].priority) {
+                      struct prioritised_indexes tmp_pi = p_i[k];
+                      p_i[k] = p_i[j];
+                      p_i[j] = tmp_pi;
+                  }
+        /* Register it */
+        for (uint32_t j = 0; j < i; ++j)
+            subscribe_callback(u->core, PA_SUBSCRIPTION_EVENT_SINK|PA_SUBSCRIPTION_EVENT_NEW, p_i[j].index, u);
+    }
+    return 0;
+}
+
 static inline struct entry *load_or_initialize_entry(struct userdata *u, struct entry *entry, const char *name, const char *prefix) {
     struct entry *old;
 
@@ -793,6 +852,75 @@ static pa_hook_result_t route_source_outputs(struct userdata *u, pa_source* igno
     return PA_HOOK_OK;
 }
 
+static char *mystrstr(char *s1 , char *s2)
+{
+     if (*s1 == 0) {
+        if (*s2) return(char*)NULL;
+            return (char*)s1;
+    }
+    while (*s1) {
+        int i = 0;
+        while (1) {
+            if (s2[i] == 0) return s1;
+            if (s2[i] != s1[i]) break;
+            i++;
+        }
+        s1++;
+    }
+    return (char*)NULL;
+}
+
+static pa_hook_result_t route_sink_headphone_port(struct userdata *u,bool is_headphone) {
+    pa_sink *s;
+    uint32_t idx;
+
+    pa_assert(u);
+    pa_log_debug("route_sink_input u->do_routing:%d", u->do_routing);
+
+    PA_IDXSET_FOREACH(s, u->core->sinks, idx) {
+        if(s && s->name && mystrstr(s->name, "music-playback-output") &&
+                s->driver && mystrstr(s->driver, "module-unisoc-card")) {
+
+            /* if we set save_volume true, when we switch speaker to headphone or the other way round,
+             * volume of previous port may be stored in the next port. The reason we can see
+             * pa_sink_set_port. In this function, pa_subscription_post(...) will store volume and
+             * pa_hook_fire(...) will restore volume, I think pa_hook_fire(...) must be use before
+             * pa_subscription_post(...) */
+            s->save_volume = false;
+
+            if (is_headphone) {
+                pa_sink_set_port(s, "headphone_output", true);
+            } else {
+                pa_sink_set_port(s, "speaker_output", true);
+            }
+        }
+    }
+    return PA_HOOK_OK;
+}
+
+static pa_hook_result_t route_source_headphone_port(struct userdata *u,bool is_headphone) {
+    pa_source *s;
+    uint32_t idx;
+    
+    pa_assert(u);
+    pa_log_debug("route_sink_input u->do_routing:%d", u->do_routing);
+
+    PA_IDXSET_FOREACH(s, u->core->sources, idx) {
+        if (s && s->name && mystrstr(s->name, "record-stereo-input") &&
+            s->driver && mystrstr(s->driver, "module-unisoc-card"))  {
+
+            s->save_volume = false;
+
+            if (is_headphone) {
+                pa_source_set_port(s, "sprd-input-headphone-mic", true);
+            } else {
+                pa_source_set_port(s, "sprd-input-internal-mic", true);
+            }
+        }
+    }
+    return PA_HOOK_OK;
+}
+
 static void subscribe_callback(pa_core *c, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
     struct userdata *u = userdata;
     struct entry *entry, *old = NULL;
@@ -861,6 +989,15 @@ static void subscribe_callback(pa_core *c, pa_subscription_event_type_t t, uint3
         pa_xfree(entry->icon);
         entry->icon = pa_xstrdup(pa_proplist_gets(sink->proplist, PA_PROP_DEVICE_ICON_NAME));
 
+         for (uint32_t i = 0; i < NUM_ROLES; ++i) {
+            if (mystrstr(sink->name,"a2dp_sink")) {
+                entry->priority[i]= 1;
+            } else if (mystrstr(sink->name,"usb") || mystrstr(sink->name,"USB")) {
+                entry->priority[i]= 2;
+            } else {
+                entry->priority[i]= 3;
+            }
+         }
     } else if ((t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) == PA_SUBSCRIPTION_EVENT_SOURCE) {
         pa_source *source;
 
@@ -1052,7 +1189,7 @@ static pa_hook_result_t sink_put_hook_callback(pa_core *c, PA_GCC_UNUSED pa_sink
     pa_assert(u->on_hotplug);
 
     notify_subscribers(u);
-
+    sink_prioity_recheck(u);
     return route_sink_inputs(u, NULL);
 }
 
@@ -1536,11 +1673,656 @@ static pa_hook_result_t connection_unlink_hook_cb(pa_native_protocol *p, pa_nati
     return PA_HOOK_OK;
 }
 
-struct prioritised_indexes {
-    uint32_t index;
-    int32_t priority;
+struct file_info {
+    int fd;
+    char *file_path;
+    char *dev_name;
+};
+
+struct file_info_item {
+    struct listnode item;
+    struct file_info *file_info;
+    int (*event_process)(struct userdata *u, struct listnode *item);
 };
 
+#define WAKE_FILE_PATH   "/var/audio/devm_wake_pipe"
+#define TUNING_VOLUME_STEP_PERCENTAGE 5
+#define PA_STREAM_CORKED_OR_UNCORDED "stream_corked_or_uncorked"
+enum {
+    VOLUME_DOWN,
+    VOLUME_UP
+};
+
+enum {
+    KEY_VOLUME_UP,
+    KEY_VOLUME_DOWN,
+    KEY_MEDIA_PAUSE
+};
+
+static void sprd_headset_info_init(struct userdata *u) {
+    u->key[KEY_VOLUME_UP] = 0;
+    u->key[KEY_VOLUME_DOWN] = 0;
+    u->key[KEY_MEDIA_PAUSE] = 0;
+}
+
+/* Do relative volume changed in TUNING_STEP%. */
+static void fill_volume(pa_cvolume *cv, int inc) {
+    uint32_t i;
+    double volume_value;
+    int volume_step = inc ? TUNING_VOLUME_STEP_PERCENTAGE : TUNING_VOLUME_STEP_PERCENTAGE * -1;
+
+    volume_value = (volume_step + 100.0) * (double) PA_VOLUME_NORM / 100;
+
+    for (i = 0; i < cv->channels; i++) {
+        if (cv->values[i] + volume_value < PA_VOLUME_NORM)
+            cv->values[i] = PA_VOLUME_MUTED;
+        else
+            cv->values[i] = cv->values[i] + volume_value - PA_VOLUME_NORM;
+
+        if (cv->values[i] >= PA_VOLUME_NORM)
+            cv->values[i] = PA_VOLUME_NORM;
+    }
+}
+
+static int sprd_headset_jk_process(struct userdata *u, struct file_info_item *item) {
+    int ret = 0;
+    struct input_event event;
+
+    if (item->file_info->fd < 0 || !u) {
+        pa_log_error("Can't have valid fd for headset jack event, fd error:%d", item->file_info->fd);
+        return -1;
+    }
+
+    ret = read(item->file_info->fd, &event, sizeof(event));
+    if (ret < (int)sizeof(event)) {
+        pa_log_error("Can't get headset jack event\n");
+        return -1;
+    }
+
+    pa_log_info("Get headset jack event information, event:%x, code:%x, value:%x", event.type, event.code, event.value);
+
+    if (event.type == EV_SW) {
+        sprd_headset_info_init(u);
+
+        if (event.code == SW_HEADPHONE_INSERT) {
+            if (event.value == 1) {
+                route_sink_headphone_port(u, true);
+            } else if (event.value == 0) {
+                route_sink_headphone_port(u, false);
+            }
+        }
+        if (event.code == SW_MICROPHONE_INSERT) {
+            if (event.value == 1) {
+                route_source_headphone_port(u, true);
+            } else if ( event.value == 0) {
+                route_source_headphone_port(u, false);
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int sprd_headset_kb_process(struct userdata *u, struct file_info_item *item) {
+    int ret = 0;
+    struct input_event event;
+    pa_sink *s;
+    pa_sink_input *i;
+    uint32_t idx;
+    pa_cvolume volume;
+    bool is_sink_input_corked = true;
+
+    if (item->file_info->fd < 0 || !u) {
+        pa_log_error("Can't have valid fd for headset keyboard event, fd error:%d", item->file_info->fd);
+        return -1;
+    }
+
+    ret = read(item->file_info->fd, &event, sizeof(event));
+    if (ret < (int)sizeof(event)) {
+        pa_log_error("Can't get headset keyboard event\n");
+        return -1;
+    }
+
+    pa_log_debug("Get headset keyboard event information, event:%x, code:%x, value:%x", event.type, event.code, event.value);
+
+    PA_IDXSET_FOREACH(s, u->core->sinks, idx) {
+        if(s && s->name && mystrstr(s->name, "music-playback-output") &&
+                s->driver && mystrstr(s->driver, "module-unisoc-card")) {
+            break;
+        }
+    }
+
+    volume = s->reference_volume;
+
+    if (1) {
+        if (event.code == KEY_VOLUMEUP) {
+            if (event.value == 1) {
+                if (u->key[KEY_VOLUME_UP] > 0)
+                    return 0;
+
+                fill_volume(&volume, VOLUME_UP);
+                pa_sink_set_volume(s, &volume, true, true);
+
+                pa_log_info("headset volume_up keyboard is pushed, we should increase volume");
+                u->key[KEY_VOLUME_UP]++;
+            } else if (event.value == 0) {
+                if (u->key[KEY_VOLUME_UP] == 0)
+                    return 0;
+
+                u->key[KEY_VOLUME_UP]--;
+            }
+        } else if (event.code == KEY_VOLUMEDOWN) {
+            if (event.value == 1) {
+                if (u->key[KEY_VOLUME_DOWN] > 0)
+                    return 0;
+
+                fill_volume(&volume, VOLUME_DOWN);
+                pa_sink_set_volume(s, &volume, true, true);
+
+                pa_log_info("headset volume_down keyboard is pushed, we should decrease volume");
+                u->key[KEY_VOLUME_DOWN]++;
+            } else if (event.value == 0) {
+                if (u->key[KEY_VOLUME_DOWN] == 0)
+                    return 0;
+
+                u->key[KEY_VOLUME_DOWN]--;
+            }
+        } else if (event.code == KEY_MEDIA) {
+            if (event.value == 1) {
+                if (u->key[KEY_MEDIA_PAUSE] > 0)
+                    return 0;
+
+                u->key[KEY_MEDIA_PAUSE]++;
+            } else if (event.value == 0) {
+                if (u->key[KEY_MEDIA_PAUSE] == 0)
+                    return 0;
+
+                /* if none sink-input connect this sink, this sink can't be running, 
+                 * so we don't have to suspend and we can't switch sink to run, 
+                 * There are no data transmitted to sink!!! */
+                if (!pa_idxset_size(s->inputs)) {
+                    pa_log_info("None sink-input connect this sink, we can't switch this sink's state");
+                    u->key[KEY_MEDIA_PAUSE]--;
+                    return 0;
+                }
+
+                /* send event to all sink-input connects this sink corked or uncorked. */
+                PA_IDXSET_FOREACH(i, s->inputs, idx) {
+                    pa_sink_input_state_t state;
+
+                    //state = pa_sink_input_get_state(i);
+					state = i->state;
+                    if (state == PA_SINK_INPUT_RUNNING)
+                        pa_sink_input_send_event(i, PA_STREAM_EVENT_REQUEST_CORK, NULL);
+                    else if (state == PA_SINK_INPUT_CORKED)
+                        pa_sink_input_send_event(i, PA_STREAM_EVENT_REQUEST_UNCORK, NULL);
+
+                    pa_log_info("headset pause keyboard is pushed, we should send %s to sink-input",
+                        state == PA_SINK_INPUT_RUNNING ? "cork" : "uncork");
+                }
+
+                /*
+                s->state == PA_SINK_SUSPENDED ? pa_sink_suspend(s, false, PA_SUSPEND_USER):
+                                                pa_sink_suspend(s, true, PA_SUSPEND_USER);
+                */
+
+                u->key[KEY_MEDIA_PAUSE]--;
+            }
+        }
+    }
+
+    return 0;
+}
+
+static struct file_info *file_info_init( char * filepath)
+{
+    int fd;
+    char name[80];
+    struct file_info * info = NULL;
+
+    if (!filepath) {
+        pa_log_error("file path is NULL");
+        return NULL;
+    }
+
+    info = malloc(sizeof(struct file_info));
+    if (!info) {
+        pa_log_error("file path is NULL");
+        return NULL;
+    }
+
+    fd = open(filepath, O_RDONLY | O_CLOEXEC);
+    if(fd < 0) {
+            pa_log_error("could not open %s, %s\n", filepath, strerror(errno));
+            free(info);
+        return NULL;
+    }
+
+    name[sizeof(name) - 1] = '\0';
+
+    if(ioctl(fd, EVIOCGNAME(sizeof(name) - 1), &name) < 1) {
+        pa_log_error( "could not get device name for %s, %s\n", filepath, strerror(errno));
+        name[0] = '\0';
+    }
+
+    pa_log_info(" file dev-name: %s", name);
+
+    info->fd = fd;
+    info->file_path = strdup(filepath);
+    info->dev_name = strdup(name);
+
+    return info;
+}
+
+static int file_info_deinit( struct file_info *info) {
+    if (!info) {
+        pa_log_error("info is NULL");
+        return -1;
+    }
+    if (info->fd >= 0) {
+        close(info->fd);
+    }
+
+    if (info->dev_name) {
+        free(info->dev_name);
+    }
+
+    if (info->file_path) {
+        free(info->file_path);
+    }
+
+    free(info);
+    return 0;
+}
+
+static int file_info_add( struct file_info *info, struct listnode *head) {
+    struct file_info_item * info_item = NULL;
+    info_item = malloc(sizeof(struct file_info_item));
+    if (!info_item) {
+        pa_log_error("file info itemmalloc failed");
+        return -1;
+    }
+    info_item->file_info = info;
+    list_add_tail(head, &info_item->item);
+    return 0;
+}
+
+static int file_info_remove( struct file_info_item*info) {
+
+    if (!info || !info->file_info ) {
+        pa_log_error("file file_info_remove  failed parameters NULL");
+        return -1;
+    }
+
+    file_info_deinit(info->file_info);
+    list_remove(&info->item);
+    free(info);
+    return 0;
+}
+
+static int file_info_open( char * file_path, struct listnode *head) {
+    struct listnode *item;
+    struct listnode *item2;
+    struct file_info_item * info_item = NULL;
+    struct file_info *file_info;
+
+    if(!list_empty(head)){
+        list_for_each_safe(item, item2, head) {
+            info_item = node_to_item(item, struct file_info_item, item);
+            if (strcmp(info_item->file_info->file_path,  file_path) == 0)  {
+                pa_log_error("file_info already existed:%s", file_path);
+                return -1;
+            }
+        }
+    }
+
+     file_info = file_info_init(file_path);
+     if (!file_info) {
+        pa_log_error("file_info_open:file_info_init init failed: :%s", file_path);
+        return -1;
+     }
+
+      return file_info_add(file_info, head);
+}
+
+static int file_info_close( char * file_path, struct listnode *head) {
+    struct listnode *item;
+    struct listnode *item2;
+    struct file_info_item * info_item = NULL;
+
+    if(!list_empty(head)){
+        list_for_each_safe(item, item2, head) {
+            info_item = node_to_item(item, struct file_info_item, item);
+            if (strcmp(info_item->file_info->file_path,  file_path) == 0)  {
+                file_info_remove(info_item);
+                break;
+            }
+        }
+    }
+    return 0;
+}
+
+static int read_dir_file_info(struct listnode *head,const char *dirname)
+{
+    char devname[1024];
+    char *filename;
+    DIR *dir;
+    int ret;
+    struct dirent *de;
+    struct stat s_buf;
+
+    dir = opendir(dirname);
+    if(dir == NULL)
+        return -1;
+    strcpy(devname, dirname);
+    filename = devname + strlen(devname);
+    *filename++ = '/';
+    while((de = readdir(dir))) {
+        if(de->d_name[0] == '.' &&
+           (de->d_name[1] == '\0' ||
+            (de->d_name[1] == '.' && de->d_name[2] == '\0')))
+            continue;
+        strcpy(filename, de->d_name);
+        ret = stat(devname,&s_buf);
+        pa_log_info("state ret:%d, filename:%s, dir:%d, reg:%d",ret, devname, S_ISDIR(s_buf.st_mode), S_ISREG(s_buf.st_mode));
+        if(!S_ISDIR(s_buf.st_mode)) {
+            file_info_open(devname, head);
+        }
+    }
+    closedir(dir);
+    return 0;
+}
+
+/* This funcation is used to filter information for all files store in dirent named by "/dev/input".
+ * Because we only care about input-events related to 3.5mm headset. */
+static void file_info_filter_and_set_callback(struct listnode *head) {
+    struct listnode *item = NULL;
+    struct listnode *item2 = NULL;
+    struct file_info_item *info_item = NULL;
+
+    if (!list_empty(head)) {
+        list_for_each_safe(item, item2, head) {
+            info_item = node_to_item(item, struct file_info_item, item);
+            if (!strcmp(info_item->file_info->dev_name, "sprdphone Headset Jack")) {
+                info_item->event_process = sprd_headset_jk_process;
+            } else if (!strcmp(info_item->file_info->dev_name, "sprdphone Headset Keyboard")) {
+                info_item->event_process = sprd_headset_kb_process;
+            } else {
+                file_info_remove(info_item);
+            }
+        }
+    }
+
+    return;
+}
+
+static int file_info_release_all(struct listnode *head) {
+    struct listnode *item;
+    struct listnode *item2;
+    struct file_info_item * info_item = NULL;
+
+    if(!list_empty(head)){
+        list_for_each_safe(item, item2, head) {
+            info_item = node_to_item(item, struct file_info_item, item);
+            if (info_item)  {
+                file_info_remove(info_item);
+            }
+        }
+    }
+    return 0;
+}
+
+static int dir_event_process(struct listnode *head, int fd, const char *device_path )
+{
+    int res;
+    int ret;
+    char devname[1024];
+    char *filename;
+    char event_buf[512];
+    int event_size;
+    int event_pos = 0;
+    struct inotify_event *event;
+
+    res = read(fd, event_buf, sizeof(event_buf));
+    if(res < (int)sizeof(*event)) {
+        if(errno == EINTR)
+            return 0;
+        pa_log_error("could not get event, ret:%d, %s\n", ret, strerror(errno));
+        return 1;
+    }
+
+    strcpy(devname, device_path);
+    filename = devname + strlen(devname);
+    *filename++ = '/';
+
+    while(res >= (int)sizeof(*event)) {
+        event = (struct inotify_event *)(event_buf + event_pos);
+        if(event->len) {
+            strcpy(filename, event->name);
+            if(event->mask & IN_CREATE) {
+                struct stat s_buf;
+                ret = stat(filename,&s_buf);
+                pa_log_debug("dir_event_process:state ret:%d, filename:%s, dir:%d, reg:%d",
+                    ret, filename, S_ISDIR(s_buf.st_mode), S_ISREG(s_buf.st_mode));
+                if(!S_ISDIR(s_buf.st_mode)) {
+                    ret = file_info_open(filename, head);
+                }
+            }
+            else {
+                pa_log_debug("dir_event_process in:file_info_close:%s", filename);
+                ret = file_info_close(filename, head);
+            }
+            if (ret < 0) {
+                pa_log_error("notify_event_process:file_info_open:error:%d, mask:%x", ret, event->mask);
+            }
+        }
+        event_size = sizeof(*event) + event->len;
+        res -= event_size;
+        event_pos += event_size;
+    }
+
+    return 0;
+}
+
+static int  input_initial_state_check(struct userdata *u, struct listnode *head) {
+    int ret;
+    struct listnode *item;
+    struct listnode *item2;
+    struct file_info_item * info_item = NULL;
+
+    if (!list_empty(head)) {
+            list_for_each_safe(item, item2, head) {
+                info_item = node_to_item(item, struct file_info_item, item);
+                if(info_item->file_info->fd >=0 ) {
+                    if (mystrstr(info_item->file_info->dev_name, "sprdphone Headset Jack")) {
+                         uint16_t switch_state;
+                        ret = ioctl(info_item->file_info->fd, EVIOCGSW(1), &switch_state);
+                        if (ret < 0) {
+                            pa_log_error("could not get switch state, %s, dev name:%s", strerror(errno), info_item->file_info->dev_name);
+                            return -1;
+                        }
+                        pa_log_debug("input_initial_state_check,switch state is %x", switch_state);
+                        if (switch_state &0x4 ) {
+                            route_sink_headphone_port(u, true);
+                        } else {
+                            route_sink_headphone_port(u, false);
+                        }
+
+                        if (switch_state &0x10 ) {
+                            route_source_headphone_port(u, true);
+                        } else {
+                            route_source_headphone_port(u, false);
+                        }
+                        return 0;
+                }
+            }
+        }
+    }
+    return -1;
+}
+
+static int pipe_init( char * pipe_path) {
+    int fd = 0;
+
+    if(!pipe_path) {
+        return -1;
+    }
+    pa_log_debug("pipe_init in");
+   if (access(pipe_path, R_OK) != 0) {
+        pa_log_debug("pipe_init  file exist");
+
+        if (mkfifo(pipe_path,S_IFIFO|0666) <0) {
+            if (errno != EEXIST) {
+                pa_log_error("%s create audio fifo error %s\n",__FUNCTION__,strerror(errno));
+                return -1;
+            }
+        }
+
+        if(chmod(pipe_path, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH) != 0) {
+            pa_log_error("%s Cannot set RW to \"%s\": %s", __FUNCTION__,pipe_path, strerror(errno));
+            return -1;
+        }
+    }
+    fd = open(pipe_path, O_RDWR);
+
+     if ((fcntl(fd,F_SETFL,O_NONBLOCK)) < 0) {
+        pa_log_error("pipe:(%s) fd(%d) fcntl error.", pipe_path, fd);
+        close(fd);
+        return -1;
+    }
+    pa_log_debug("pipe_init ok");
+
+    return fd;
+}
+
+static int pipe_deinit( int fd) {
+    if (fd < 0) {
+        pa_log_error("empty_pipe:fd is error");
+        return -1;
+    }
+    return close(fd);
+}
+
+static void pipe_empty(int fd) {
+    char buff[16];
+    int ret;
+    pa_log_info("pipe_empty:in");
+    if (fd < 0) {
+        pa_log_error("empty_pipe:fd is error");
+        return;
+    }
+
+    do {
+        ret = read(fd, &buff, sizeof(buff));
+    } while (ret > 0 || (ret < 0 && errno == EINTR));
+    pa_log_info("pipe_empty:out");
+}
+
+static void pipe_wake(int fd) {
+    char fake[5] = "fake";
+    int w_size = 0;
+
+    if (fd < 0) {
+        pa_log_error("empty_pipe:fd is error");
+        return;
+    }
+     w_size = write(fd, fake, sizeof(fake));
+
+     return w_size >0 ? 0:-1;
+}
+
+static void thread_func(void *userdata) {
+    struct userdata *u = userdata;
+    int ret;
+
+    struct listnode *item;
+    struct listnode *item2;
+    struct file_info_item * info_item = NULL;
+
+    int fd;
+    int maxfd = 0;
+    fd_set fds_monitor;
+    const char *device_path = "/dev/input";
+    struct listnode file_info_list;
+    list_init(&file_info_list);
+
+    pa_assert(u);
+
+    ret = read_dir_file_info(&file_info_list, device_path);
+    input_initial_state_check(u, &file_info_list);
+    file_info_filter_and_set_callback(&file_info_list);
+
+    sprd_headset_info_init(userdata);
+
+    fd = inotify_init();
+    if (fd < 0) {
+        pa_log_error("Thread inotify_init failed:%s", strerror(errno));
+        goto fail;
+    }
+
+    ret = inotify_add_watch(fd, device_path, IN_DELETE | IN_CREATE);
+     if(ret < 0) {
+        pa_log_error( "cannot add watch for %s, %s\n", device_path, strerror(errno));
+        goto fail;
+    }
+
+    if((fcntl(fd,F_SETFL,O_NONBLOCK))<0) {
+        pa_log_error("fcntl set O_NONBLOCK error.");
+    }
+
+    while (!u->thread_exit) {
+        FD_ZERO(&fds_monitor);
+        FD_SET(fd ,&fds_monitor);
+        maxfd = fd;
+        if (u->devm_wake_pipe ) {
+            FD_SET(u->devm_wake_pipe,&fds_monitor);
+            if (u->devm_wake_pipe > maxfd ) {
+                maxfd = u->devm_wake_pipe;
+            }
+        }
+
+        if (!list_empty(&file_info_list)) {
+            list_for_each_safe(item, item2, &file_info_list) {
+                info_item = node_to_item(item, struct file_info_item, item);
+                FD_SET(info_item->file_info->fd,&fds_monitor) ;
+                if (maxfd < info_item->file_info->fd)
+                    maxfd = info_item->file_info->fd;
+            }
+        }
+        maxfd++;
+        pa_log_debug("select in maxfdr:%d", maxfd);
+        ret = select(maxfd, &fds_monitor, NULL, NULL, NULL);
+        pa_log_debug("select out :%d", ret);
+        if (ret <= 0) {
+            pa_log_error("select out error:%d", ret);
+            continue;
+        }
+
+        if ((u->devm_wake_pipe >= 0) && FD_ISSET(u->devm_wake_pipe,&fds_monitor) )  {
+            pipe_empty (u->devm_wake_pipe); 
+        }
+
+        if (FD_ISSET(fd,&fds_monitor) ) {
+            dir_event_process(&file_info_list,  fd, device_path);
+        }
+
+        if (!list_empty(&file_info_list)) {
+            list_for_each_safe(item, item2, &file_info_list) {
+                info_item = node_to_item(item, struct file_info_item, item);
+                if(FD_ISSET(info_item->file_info->fd, &fds_monitor) ) {
+                    pa_log_debug("select out and input event proc: file name:%s,dev-name:%s", info_item->file_info->file_path, info_item->file_info->dev_name);
+                    info_item->event_process(u, info_item);               
+                }
+            }
+        }
+   }
+fail:
+    pa_log_info("Thread shutting down start");
+    file_info_release_all(&file_info_list);
+    pa_log_info("Thread shutting down end");
+}
+
+
 int pa__init(pa_module*m) {
     pa_modargs *ma = NULL;
     struct userdata *u;
@@ -1550,7 +2332,8 @@ int pa__init(pa_module*m) {
     uint32_t idx;
     bool do_routing = false, on_hotplug = true, on_rescue = true;
     uint32_t total_devices;
-
+    char *thread_name = NULL;
+    pa_log_info("Successfully peter devicemanager opened database file ");
     pa_assert(m);
 
     if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
@@ -1675,6 +2458,20 @@ int pa__init(pa_module*m) {
     route_sink_inputs(u, NULL);
     route_source_outputs(u, NULL);
 
+    u->devm_wake_pipe = pipe_init(WAKE_FILE_PATH);
+    if (u->devm_wake_pipe >= 0) {
+        u->thread_exit = false;
+        thread_name = pa_sprintf_malloc("dev-manager-%s", pa_strnull(fname));
+        if (!(u->thread = pa_thread_new(thread_name, thread_func, u))) {
+            pa_log("Failed to create thread.");
+            pipe_deinit(u->devm_wake_pipe);
+            u->devm_wake_pipe = -1;
+            goto fail;
+        }
+    }
+    pa_xfree(thread_name);
+    thread_name = NULL;
+
 #ifdef DUMP_DATABASE
     dump_database(u);
 #endif
@@ -1699,6 +2496,14 @@ void pa__done(pa_module*m) {
     if (!(u = m->userdata))
         return;
 
+    if (u->thread) {	
+        u->thread_exit = true;
+        if (u->devm_wake_pipe >= 0) {
+            pipe_wake (u->devm_wake_pipe);
+        }
+        pa_thread_free(u->thread);
+    }
+
     if (u->subscription)
         pa_subscription_free(u->subscription);
 
diff --git a/src/modules/module-device-restore.c b/src/modules/module-device-restore.c
index d15d9ff..edc18b0 100755
--- a/src/modules/module-device-restore.c
+++ b/src/modules/module-device-restore.c
@@ -815,9 +815,13 @@ static pa_hook_result_t sink_port_hook_callback(pa_core *c, pa_sink *sink, struc
             pa_log_info("Restoring volume for sink %s.", sink->name);
             v = e->volume;
             pa_cvolume_remap(&v, &e->channel_map, &sink->channel_map);
+            //pa_log_debug("restore volume, volume[0] is %d, volume[1] is %d", v.values[0], v.values[1]);
             pa_sink_set_volume(sink, &v, true, false);
 
-            sink->save_volume = true;
+            /* Why set save_volume true? After restore, the volume of current "sink+port" store in database
+             * not modified, include the previous "sink+port". If set it true, when we switch port in this sink,
+             * the volume of current port maybe store in next port. */
+            //sink->save_volume = true;
         }
 
         if (u->restore_muted && e->muted_valid) {
@@ -1264,11 +1268,47 @@ int pa__init(pa_module*m) {
     pa_log_info("Successfully opened database file '%s'.", fname);
     pa_xfree(fname);
 
-    PA_IDXSET_FOREACH(sink, m->core->sinks, idx)
-        subscribe_callback(m->core, PA_SUBSCRIPTION_EVENT_SINK|PA_SUBSCRIPTION_EVENT_NEW, sink->index, u);
+    /* This part is used by restore device volume which stores in database managed by module-device-manager.
+     * Because of we load module-device-restore after module-unisoc-card, when load module-unisoc-card, pulseaudio
+     * will new a sink and a source, in this process pulseaudio will use module-device-restore which not be loaded,
+     * so when we load module-device-restore, we must store device information which not be stored in database using by
+     * subscribe_callback. And restore device which is stored in database using by pa_hook_fire. */
+    PA_IDXSET_FOREACH(sink, m->core->sinks, idx) {
+        pa_device_port *active_port, *p;
+        void *state;
+        if (sink && sink->name && !strcmp(sink->name, "alsa_output.0.music-playback-output")) {
+            pa_log_info("device(sink) restore fire!");
+            active_port = sink->active_port;
+            PA_HASHMAP_FOREACH(p, sink->ports, state) {
+                //pa_hook_fire(&sink->core->hooks[PA_CORE_HOOK_SINK_PORT_CHANGED], sink);
+                if (!perportentry_read(u, "sink:alsa_output.0.music-playback-output", p->name)) {
+                    sink->save_volume = true;
+                    sink->active_port = p;
+                    subscribe_callback(m->core, PA_SUBSCRIPTION_EVENT_SINK|PA_SUBSCRIPTION_EVENT_NEW, sink->index, u);
+                }
+            }
+            sink->active_port = active_port;
+            pa_hook_fire(&sink->core->hooks[PA_CORE_HOOK_SINK_PORT_CHANGED], sink);
+        }
+    }
 
-    PA_IDXSET_FOREACH(source, m->core->sources, idx)
-        subscribe_callback(m->core, PA_SUBSCRIPTION_EVENT_SOURCE|PA_SUBSCRIPTION_EVENT_NEW, source->index, u);
+    PA_IDXSET_FOREACH(source, m->core->sources, idx) {
+        pa_device_port *active_port, *p;
+        void *state;
+        if (source && source->name && !strcmp(source->name, "alsa_input.0.record-stereo-input")) {
+            pa_log_info("device(source) restore fire!");
+            active_port = source->active_port;
+            PA_HASHMAP_FOREACH(p, source->ports, state) {
+                if (!perportentry_read(u, "source:alsa_input.0.record-stereo-input", p->name)) {
+                    source->save_volume = true;
+                    source->active_port = p;
+                    subscribe_callback(m->core, PA_SUBSCRIPTION_EVENT_SOURCE|PA_SUBSCRIPTION_EVENT_NEW, source->index, u);
+                }
+            }
+            source->active_port = active_port;
+            pa_hook_fire(&source->core->hooks[PA_CORE_HOOK_SOURCE_PORT_CHANGED], source);
+        }
+    }
 
     pa_modargs_free(ma);
     return 0;
diff --git a/src/modules/module-udev-detect.c b/src/modules/module-udev-detect.c
index d119f96..eb58bc8 100755
--- a/src/modules/module-udev-detect.c
+++ b/src/modules/module-udev-detect.c
@@ -91,6 +91,25 @@ static const char* const valid_modargs[] = {
     NULL
 };
 
+static char *mystrstr(char *s1 , char *s2)
+{
+     if (*s1 == 0) {
+        if (*s2) return(char*)NULL;
+            return (char*)s1;
+    }
+    while (*s1) {
+        int i = 0;
+        while (1) {
+            if (s2[i] == 0) return s1;
+            if (s2[i] != s1[i]) break;
+            i++;
+        }
+        s1++;
+    }
+    return (char*)NULL;
+}
+
+
 static int setup_inotify(struct userdata *u);
 
 static void device_free(struct device *d) {
@@ -308,7 +327,12 @@ static void verify_access(struct userdata *u, struct device *d) {
              * inotify and can then recheck. */
 
             busy = is_card_busy(path_get_card_id(d->path));
-            pa_log_debug("%s is busy: %s", d->path, pa_yes_no(busy));
+            pa_log_debug("card:%s,%s is busy: %s", d->card_name,d->path, pa_yes_no(busy));
+
+            if (!(mystrstr(d->path, "usb") || mystrstr(d->path, "USB"))) {
+                pa_log_info("alsa_card.0 ignore:%s\n", d->path);
+                busy = true;
+            }
 
             if (!busy) {
 
diff --git a/src/pulse/context.c b/src/pulse/context.c
index a056c2d..5e520ff 100755
--- a/src/pulse/context.c
+++ b/src/pulse/context.c
@@ -66,6 +66,16 @@
 #include "internal.h"
 #include "context.h"
 
+#ifndef PA_PULSE_RUNTIME_PATH
+#define PA_PULSE_RUNTIME_PATH "/mnt/data/.config/pulse"
+#endif
+#ifndef PA_PULSE_STATE_PATH
+#define PA_PULSE_STATE_PATH "/mnt/data/.config/pulse"
+#endif
+#ifndef PA_XDG_CONFIG_HOME
+#define PA_XDG_CONFIG_HOME "/mnt/data/.config"
+#endif
+
 void pa_command_extension(pa_pdispatch *pd, uint32_t command, uint32_t tag, pa_tagstruct *t, void *userdata);
 static void pa_command_enable_srbchannel(pa_pdispatch *pd, uint32_t command, uint32_t tag, pa_tagstruct *t, void *userdata);
 static void pa_command_disable_srbchannel(pa_pdispatch *pd, uint32_t command, uint32_t tag, pa_tagstruct *t, void *userdata);
@@ -832,6 +842,13 @@ static int try_next_connection(pa_context *c) {
     pa_assert(c);
     pa_assert(!c->client);
 
+	if (!getenv("PULSE_RUNTIME_PATH"))
+		pa_set_env("PULSE_RUNTIME_PATH", PA_PULSE_RUNTIME_PATH);
+	if (!getenv("PULSE_STATE_PATH"))
+		pa_set_env("PULSE_STATE_PATH", PA_PULSE_STATE_PATH);
+	if (!getenv("XDG_CONFIG_HOME"))
+		pa_set_env("XDG_CONFIG_HOME", PA_XDG_CONFIG_HOME);
+
     for (;;) {
         pa_xfree(u);
         u = NULL;
@@ -979,6 +996,13 @@ int pa_context_connect(
     PA_CHECK_VALIDITY(c, !(flags & ~(PA_CONTEXT_NOAUTOSPAWN|PA_CONTEXT_NOFAIL)), PA_ERR_INVALID);
     PA_CHECK_VALIDITY(c, !server || *server, PA_ERR_INVALID);
 
+	if (!getenv("PULSE_RUNTIME_PATH"))
+		pa_set_env("PULSE_RUNTIME_PATH", PA_PULSE_RUNTIME_PATH);
+	if (!getenv("PULSE_STATE_PATH"))
+		pa_set_env("PULSE_STATE_PATH", PA_PULSE_STATE_PATH);
+	if (!getenv("XDG_CONFIG_HOME"))
+		pa_set_env("XDG_CONFIG_HOME", PA_XDG_CONFIG_HOME);
+
     if (server)
         c->conf->autospawn = false;
     else
diff --git a/src/pulsecore/creds.h b/src/pulsecore/creds.h
index 9fdbb4f..c6e1de4 100755
--- a/src/pulsecore/creds.h
+++ b/src/pulsecore/creds.h
@@ -36,7 +36,7 @@ typedef struct pa_cmsg_ancil_data pa_cmsg_ancil_data;
 
 #if defined(SCM_CREDENTIALS)
 
-#define HAVE_CREDS 1
+//#define HAVE_CREDS 1
 
 struct pa_creds {
     gid_t gid;
diff --git a/src/pulsecore/memblock.c b/src/pulsecore/memblock.c
index fb83dac..9ff758d 100755
--- a/src/pulsecore/memblock.c
+++ b/src/pulsecore/memblock.c
@@ -1516,3 +1516,45 @@ int pa_memexport_put(pa_memexport *e, pa_memblock *b, pa_mem_type_t *type, uint3
 
     return 0;
 }
+
+int pa_memexport_put1(pa_memblock *b, pa_mem_type_t *type, uint32_t *block_id,
+                     uint32_t *shm_id, size_t *offset, size_t * size) {
+    pa_shm  *memory;
+    struct memexport_slot *slot;
+    void *data;
+
+    pa_assert(b);
+    pa_assert(type);
+    pa_assert(block_id);
+    pa_assert(shm_id);
+    pa_assert(offset);
+    pa_assert(size);
+
+    *block_id = 0;
+
+/*     pa_log("Got block id %u", *block_id); */
+
+    data = pa_memblock_acquire(b);
+
+    if (b->type == PA_MEMBLOCK_IMPORTED) {
+        pa_assert(b->per_type.imported.segment);
+        memory = &b->per_type.imported.segment->memory;
+    } else {
+        pa_assert(b->pool);
+        memory = &b->pool->memory;
+    }
+
+    *type = memory->type;
+    *shm_id = memory->id;
+    if(data >= memory->ptr) {
+        *offset = (size_t) ((uint8_t*) data - (uint8_t*) memory->ptr);
+    } else {
+        *offset = 0;
+    }
+    *size = b->length;
+
+    pa_memblock_release(b);
+
+    return 0;
+}
+
diff --git a/src/pulsecore/protocol-native.c b/src/pulsecore/protocol-native.c
index 7245741..3e36a6b 100755
--- a/src/pulsecore/protocol-native.c
+++ b/src/pulsecore/protocol-native.c
@@ -2639,13 +2639,13 @@ static void command_auth(pa_pdispatch *pd, uint32_t command, uint32_t tag, pa_ta
                 if (memcmp(ac, cookie, PA_NATIVE_COOKIE_LENGTH) == 0)
                     success = true;
         }
-
+#if 0
         if (!success) {
             pa_log_warn("Denied access to client with invalid authentication data.");
             pa_pstream_send_error(c->pstream, tag, PA_ERR_ACCESS);
             return;
         }
-
+#endif
         c->authorized = true;
         if (c->auth_timeout_event) {
             c->protocol->core->mainloop->time_free(c->auth_timeout_event);
@@ -2675,7 +2675,7 @@ static void command_auth(pa_pdispatch *pd, uint32_t command, uint32_t tag, pa_ta
             do_shm = false;
     }
 #endif
-
+	do_shm = true;
     pa_log_debug("Negotiated SHM: %s", pa_yes_no(do_shm));
     pa_pstream_enable_shm(c->pstream, do_shm);
 
diff --git a/src/pulsecore/pstream.c b/src/pulsecore/pstream.c
index 3b94a3a..894edf8 100755
--- a/src/pulsecore/pstream.c
+++ b/src/pulsecore/pstream.c
@@ -640,6 +640,7 @@ static void prepare_next_write_item(pa_pstream *p) {
         flags = (uint32_t) (p->write.current->seek_mode & PA_FLAG_SEEKMASK);
 
         if (p->use_shm) {
+            int ret;
             pa_mem_type_t type;
             uint32_t block_id, shm_id;
             size_t offset, length;
@@ -648,18 +649,30 @@ static void prepare_next_write_item(pa_pstream *p) {
             pa_mempool *current_pool = pa_memblock_get_pool(p->write.current->chunk.memblock);
             pa_memexport *current_export;
 
-            if (p->mempool == current_pool)
-                pa_assert_se(current_export = p->export);
+            if (p->mempool == current_pool) {
+                current_export = p->export;
+                //pa_log("current_export is %d, but ignore", current_export);
+            }
             else
                 pa_assert_se(current_export = pa_memexport_new(current_pool, memexport_revoke_cb, p));
 
-            if (pa_memexport_put(current_export,
+            if (current_export) {
+                ret = pa_memexport_put(current_export,
                                  p->write.current->chunk.memblock,
                                  &type,
                                  &block_id,
                                  &shm_id,
                                  &offset,
-                                 &length) >= 0) {
+                                 &length);
+            } else {
+                ret = pa_memexport_put1(p->write.current->chunk.memblock,
+                                 &type,
+                                 &block_id,
+                                 &shm_id,
+                                 &offset,
+                                 &length);
+            }
+            if (ret >= 0) {
 
                 if (type == PA_MEM_TYPE_SHARED_POSIX)
                     send_payload = false;
@@ -677,7 +690,8 @@ static void prepare_next_write_item(pa_pstream *p) {
                 }
 
                 if (send_payload) {
-                    pa_assert_se(pa_memexport_process_release(current_export, block_id) == 0);
+                    if (current_export)
+                        pa_assert_se(pa_memexport_process_release(current_export, block_id) == 0);
                 } else {
                     flags |= PA_FLAG_SHMDATA;
                     if (pa_mempool_is_remote_writable(current_pool))
diff --git a/src/pulsecore/shm.c b/src/pulsecore/shm.c
index 0742cb8..2dc643d 100755
--- a/src/pulsecore/shm.c
+++ b/src/pulsecore/shm.c
@@ -155,7 +155,8 @@ static int sharedmem_create(pa_shm *m, pa_mem_type_t type, size_t size, mode_t m
 #ifdef HAVE_SHM_OPEN
     case PA_MEM_TYPE_SHARED_POSIX:
         segment_name(fn, sizeof(fn), m->id);
-        fd = shm_open(fn, O_RDWR|O_CREAT|O_EXCL, mode);
+        
+        fd = shm_open(fn, O_RDWR|O_CREAT|O_EXCL, 0644);
         do_unlink = true;
         break;
 #endif
diff --git a/src/pulsecore/sink.c b/src/pulsecore/sink.c
index 55e9af3..bc01144 100755
--- a/src/pulsecore/sink.c
+++ b/src/pulsecore/sink.c
@@ -3394,7 +3394,7 @@ int pa_sink_set_port(pa_sink *s, const char *name, bool save) {
     pa_device_port *port;
 
     pa_sink_assert_ref(s);
-    pa_assert_ctl_context();
+    //pa_assert_ctl_context();
 
     if (!s->set_port) {
         pa_log_debug("set_port() operation not implemented for sink %u \"%s\"", s->index, s->name);
diff --git a/src/pulsecore/socket-server.c b/src/pulsecore/socket-server.c
index bc5116a..05ab3f1 100755
--- a/src/pulsecore/socket-server.c
+++ b/src/pulsecore/socket-server.c
@@ -108,7 +108,13 @@ static void callback(pa_mainloop_api *mainloop, pa_io_event *e, int fd, pa_io_ev
 
     if ((nfd = pa_accept_cloexec(fd, NULL, NULL)) < 0) {
         pa_log("accept(): %s", pa_cstrerror(errno));
-        goto finish;
+        /*Bad file descriptor Bug 1715527*/
+        if(errno == EBADF) {
+            pa_log("server listen socket fd:%d is closed, quit", fd);
+            mainloop->quit(mainloop, 0);
+            return;
+        }
+        goto finish;	
     }
 
     if (!s->on_connection) {
@@ -198,10 +204,12 @@ pa_socket_server* pa_socket_server_new_unix(pa_mainloop_api *m, const char *file
 #endif
 
     if (fd < 0) {
+        pa_log_info("pa_socket_server_new_unix pa_socket_cloexec :%s", filename);
         if ((fd = pa_socket_cloexec(PF_UNIX, SOCK_STREAM, 0)) < 0) {
             pa_log("socket(PF_UNIX): %s", pa_cstrerror(errno));
             goto fail;
         }
+        pa_log_info("pa_socket_server_new_unix pa_listen_socket fd is :%d", fd);
 
         memset(&sa, 0, sizeof(sa));
         sa.sun_family = AF_UNIX;
diff --git a/src/pulsecore/source.c b/src/pulsecore/source.c
index 855d3de..c61f725 100755
--- a/src/pulsecore/source.c
+++ b/src/pulsecore/source.c
@@ -2661,7 +2661,7 @@ int pa_source_set_port(pa_source *s, const char *name, bool save) {
     pa_device_port *port;
 
     pa_source_assert_ref(s);
-    pa_assert_ctl_context();
+    //pa_assert_ctl_context();
 
     if (!s->set_port) {
         pa_log_debug("set_port() operation not implemented for source %u \"%s\"", s->index, s->name);
-- 
2.17.1

